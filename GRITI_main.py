#Start of new dynamic distiller of data: GRITI (General Resource for Ionospheric Transient Investigations) 
#RD on 8/23/2018
#
import os 
import numpy as np
import datetime
import warnings
import gc
import configparser
from subfun_date_to_dayNum import subfun_date_to_dayNum
from subfun_dayNum_to_date import subfun_dayNum_to_date
from subfun_dateORdayNum_to_fullRange import subfun_dateORdayNum_to_fullRange
from subfun_monthNum_to_word import subfun_monthNum_to_word
from subfun_strfind import strfind

from GRITI_import_TEC_Madrigal import GRITI_import_TEC_Madrigal
# from GRITI_import_TEC_Madrigal_V2preV3 import GRITI_import_TEC_Madrigal
from GRITI_import_TEC_otherSources import GRITI_import_TEC_otherSources
from GRITI_import_TEC_LISN import GRITI_import_TEC_LISN
from GRITI_import_ISR_Haystack import GRITI_import_ISR_Haystack
from GRITI_import_ISR_Pokerflat import GRITI_import_ISR_Pokerflat
# from GRITI_import_AMPERE import GRITI_import_AMPERE
from GRITI_import_AMPERE_preprepared import GRITI_import_AMPERE_preprepared as GRITI_import_AMPERE
from GRITI_import_Kp import GRITI_import_Kp
from GRITI_import_OMNI import GRITI_import_OMNI

from GRITI_keo_keogrammer import GRITI_keo_keogrammer
from GRITI_keo_plot import GRITI_keo_plot
from GRITI_keo_plot_wSun import GRITI_keo_plot_wSun
from GRITI_keo_plot_sunCentered import GRITI_keo_plot_sunCentered

from GRITI_spectral_6minAnalysisPlot import GRITI_spectral_6minAnalysisPlot

from GRITI_TEC_randomSynth import GRITI_TEC_randomSynth
from GRITI_TEC_keo import GRITI_TEC_keo
from GRITI_TEC_keo_plot_TEC import GRITI_TEC_keo_plot_TEC
from GRITI_TEC_keo_fancyPlot_TEC import GRITI_TEC_keo_fancyPlot_TEC
from GRITI_TEC_keo_fancyPlot_TEC_wDayNite import GRITI_TEC_keo_fancyPlot_TEC_wDayNite
from GRITI_TEC_keo_fancyPlot_TECnISR import GRITI_TEC_keo_fancyPlot_TECnISR
from GRITI_TEC_keo_fancyPlot_TECnNoise import GRITI_TEC_keo_fancyPlot_TECnNoise
from GRITI_TEC_keo_plot_TEC_cutOut import GRITI_TEC_keo_plot_TEC_cutOut
from GRITI_TEC_keo_fancyPlot_TEC_noiseAllViews import GRITI_TEC_keo_fancyPlot_TEC_noiseAllViews

from GRITI_TEC_avgPt import GRITI_TEC_avgPt
from GRITI_TEC_avgPt_timeMatch import GRITI_TEC_avgPt_timeMatch
from GRITI_TEC_avgPt_HP_timeMatch_plotWithISR_cutOut import GRITI_TEC_avgPt_HP_timeMatch_plotWithISR_cutOut
from GRITI_TEC_avgPt_HP_timeMatch_POPL_plotWithISR_cutOut import GRITI_TEC_avgPt_HP_timeMatch_POPL_plotWithISR_cutOut
from GRITI_TEC_avgPt_HP_timeMatch_POPL_fancyPlot_plotWithISR_cutOut import GRITI_TEC_avgPt_HP_timeMatch_POPL_fancyPlot_plotWithISR_cutOut
from GRITI_TEC_avgPt_HP_timeMatch_plotWithISR_ZenithOnly_cutOut import GRITI_TEC_avgPt_HP_timeMatch_plotWithISR_ZenithOnly_cutOut
from GRITI_TEC_avgPt_HP_timeMatch_POPL_plotWithISR_ZenithOnly_cutOut import GRITI_TEC_avgPt_HP_timeMatch_POPL_plotWithISR_ZenithOnly_cutOut
from GRITI_TEC_avgPt_HP_timeMatch_scargleWithISR_cutOut import GRITI_TEC_avgPt_HP_timeMatch_scargleWithISR_cutOut
from GRITI_TEC_avgPt_HP_timeMatch_POPL_scargleWithISR_cutOut import GRITI_TEC_avgPt_HP_timeMatch_POPL_scargleWithISR_cutOut
from GRITI_TEC_avgPt_HP_timeMatch_POPLnAMPERE_plotWithISR_ZenithOnly_cutOut import GRITI_TEC_avgPt_HP_timeMatch_POPLnAMPERE_plotWithISR_ZenithOnly_cutOut

from GRITI_ISR_Haystack_plot_POPL_HP import GRITI_ISR_Haystack_plot_POPL_HP
from GRITI_ISR_Haystack_fancyPlot_POPL_HP_wDayNite import GRITI_ISR_Haystack_fancyPlot_POPL_HP_wDayNite
from GRITI_ISR_Haystack_plot_POPL_HP_cutOut import GRITI_ISR_Haystack_plot_POPL_HP_cutOut
from GRITI_ISR_Haystack_plot_POPL import GRITI_ISR_Haystack_plot_POPL
from GRITI_ISR_Haystack_plot_POPL_limited import GRITI_ISR_Haystack_plot_POPL_limited
from GRITI_ISR_Haystack_plot_POPL_scargleSet import GRITI_ISR_Haystack_plot_POPL_scargleSet
from GRITI_ISR_Haystack_plot_POPL_FFTSet import GRITI_ISR_Haystack_plot_POPL_FFTSet
#older SNR options - switched to POPL going forward
from GRITI_ISR_Haystack_plot_SNR_HP import GRITI_ISR_Haystack_plot_SNR_HP
from GRITI_ISR_Haystack_plot_SNR import GRITI_ISR_Haystack_plot_SNR
from GRITI_ISR_Haystack_plot_SNR_limited import GRITI_ISR_Haystack_plot_SNR_limited
from GRITI_ISR_Haystack_plot_scargleSet import GRITI_ISR_Haystack_plot_scargleSet
#other non-SNR or POPL stuff
from GRITI_ISR_Haystack_plot_ionVel import GRITI_ISR_Haystack_plot_ionVel
from GRITI_ISR_Haystack_plot_ionVel_cutOut import GRITI_ISR_Haystack_plot_ionVel_cutOut
from GRITI_ISR_Haystack_plot_ionVel_HP import GRITI_ISR_Haystack_plot_ionVel_HP
from GRITI_ISR_Haystack_plot_ionVel_HP_cutOut import GRITI_ISR_Haystack_plot_ionVel_HP_cutOut
#----Pokerflat ISR plots-----
from GRITI_ISR_Pokerflat_plot_POPL_HP import GRITI_ISR_Pokerflat_plot_POPL_HP
from GRITI_ISR_Pokerflat_plot_POPL import GRITI_ISR_Pokerflat_plot_POPL
from GRITI_ISR_Pokerflat_plot_POPL_limited import GRITI_ISR_Pokerflat_plot_POPL_limited

from GRITI_OMNI_plot import GRITI_OMNI_plot
from GRITI_OMNI_plot_scargle import GRITI_OMNI_plot_scargle
from GRITI_OMNI_plot_FFT import GRITI_OMNI_plot_FFT
from GRITI_Kp_plot import GRITI_Kp_plot
from GRITI_KpOMNI_fancyPlot import GRITI_KpOMNI_fancyPlot

from GRITI_AMPERE_integrator import GRITI_AMPERE_integrator

from GRITI_import_Mag_NRCan import GRITI_import_Mag_NRCan
from GRITI_Mag_keo import GRITI_Mag_keo
from GRITI_Mag_keo_plot import GRITI_Mag_keo_plot


from GRITI_combinedPlot_keo_TEC_n_AMPERE_1Dintegration import GRITI_combinedPlot_keo_TEC_n_AMPERE_1Dintegration
from GRITI_combinedPlot_keo_TEC_n_AMPERE_1Dintegration_auroralZone import GRITI_combinedPlot_keo_TEC_n_AMPERE_1Dintegration_auroralZone
from GRITI_combinedPlot_keo_TEC_n_AMPERE_1Dintegration_auroralZone_spectra import GRITI_combinedPlot_keo_TEC_n_AMPERE_1Dintegration_auroralZone_spectra

import matplotlib.cbook #basemap uses something that'll be depreciated in matplotlib, ignore that warning
warnings.filterwarnings("ignore",category=matplotlib.cbook.mplDeprecation); #basemap uses something that'll be depreciated in matplotlib, ignore that warning

settings = {}; #prep a settings dictionary

np.random.seed(seed=1776); #prime the random number consistency #1784
#-----Data Types Supported-----
dataTypes = ['TEC','ISR','AMPERE','OMNI','Kp','Mag']; #list of the data types supported

#-----Read in Config-----
config = configparser.ConfigParser(); #prep the config parser
config.read('GRITI_main_config.ini'); #read the config file
config_sects = config.sections(); #get the sections in the config file
settings_config = {}; #prep a dict
for i in range(0,len(config_sects)):
    config_items = config.items(config_sects[i]); #get the items in a single section of the config
    settings_config[config_sects[i]] = {}; #prep a sub-dict with the section name
    for j in range(0,len(config_items)):
        settings_config[config_sects[i]][config_items[j][0]] = config_items[j][1].replace('os.getcwd()',os.getcwd()); #record the items and their results in the sub-dict
        if( config_sects[i] == 'paths' ):
            settings_config[config_sects[i]][config_items[j][0]] = settings_config[config_sects[i]][config_items[j][0]].replace('+',''); #only replace +'s on the paths
        #END IF
    #END FOR j
#END FOR i
settings['config'] = settings_config; #record
#testing stuff
import sys
import time
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable
import matplotlib.colorbar as pltCB
BasemapFixDir = settings_config['paths']['basemapfix']; #directory as a variable
os.environ["PROJ_LIB"] = BasemapFixDir; #hack beacuse people are awful coders
from mpl_toolkits.basemap import Basemap
import cartopy as cartopy #cartopy replaces basemap b/c it's updated
from matplotlib.path import Path
from subfun_lombscargle import subfun_lombscargle
from matplotlib.ticker import FormatStrFormatter
from subfun_highpass import subfun_highpass

from matplotlib.colors import ListedColormap
from GRITI_movieMaker_subfun_dataGridder import GRITI_movieMaker_subfun_dataGridder
from GRITI_movieMaker_subfun_dayniteCalc import GRITI_movieMaker_subfun_dayniteCalc

#==============PLOT STANDARDIZATION STUFF==============
FONT_axisTick = 19; #small font (tick mark font size) 15
FONT_axisLabel = 23; #medium font (labels) 17 
FONT_title = 23; #big font (title only really) 20
FONT_grandiose = 26; #big font (title only really) 20

PLOT_lineWidth = {
    'thicc':4.00,
    'double plus':3.00,
    'plus':2.25,
    'regular plus':2.00,
    'regular':1.75,
    'smol':1.25,
    'smoller':1,
    }; #standardized line width Thicc / DoublePlus / Plus / RegularPlus / Regular / Smol
PLOT_color = ['xkcd:purple','xkcd:green','xkcd:blue','xkcd:pink',
     'xkcd:brown','xkcd:brick red','xkcd:grey','xkcd:orange',
     'xkcd:teal','xkcd:midnight purple','xkcd:magenta','xkcd:goldenrod',
     'xkcd:forest green','xkcd:tan','xkcd:periwinkle','xkcd:salmon']; #color set for plotting
PLOT_color.extend((np.random.randint(0,high=256,size=(200,3))/255).tolist()); #make sure there's enough colors forever
PLOT_lineStyle = ['-','--','-.',':']*25;

import matplotlib.font_manager as fm #import font manager you know
FONT_axisTickFM = fm.FontProperties(family='arial', weight='bold', size=FONT_axisTick); #these are font properties, some plot stuff has this and it tells it all in one go #inconsistent
FONT_axisLabelFM = fm.FontProperties(family='arial', weight='bold', size=FONT_axisLabel); #these are font properties, some plot stuff has this and it tells it all in one go #inconsistent
FONT_titleFM = fm.FontProperties(family='arial', weight='bold', size=FONT_title); #these are font properties, some plot stuff has this and it tells it all in one go #inconsistent
FONT_grandioseFM = fm.FontProperties(family='arial', weight='bold', size=FONT_grandiose); #these are font properties, some plot stuff has this and it tells it all in one go #inconsistent

plt.rcParams['font.weight'] = 'bold'; #sents default font weight to bold for everything else
plt.rcParams['axes.labelweight'] = 'bold'; #sets default font weight to bold for axis labels
plt.rc('font', size=FONT_axisTick); #default text size
#plt.rc('axes', titlesize=FONT_axisTick); # axes title text size
#plt.rc('axes', labelsize=FONT_axisTick); #x and y label font size
plt.rc('xtick', labelsize=FONT_axisTick); #x tick label font size
plt.rc('ytick', labelsize=FONT_axisTick); #y tick label font size
plt.rc('legend', fontsize=FONT_axisLabel); #legend fornt size
plt.rc('figure', titlesize=FONT_title); #figure title font size (this one didn't do anything, so 2nd here also)
plt.rc('axes', titlesize=FONT_title); #figure title font size (this one did work)
plt.rcParams['axes.labelsize'] = FONT_axisLabel; #try this one also
#plt.rc('text', fontsize=FONT_axisTick); #figure text font size

#testing stuff - does nothing right now
FLG_derivatate = 0; #the flag # is the derivative order (e.g. 1 is 1st deriv, 2 is 2nd deriv)

#Important stuff
FLG_fancyPlot = 1; #with this flag on, any plot that has a fancy plot mode for papers is activated. if it doesn't have a fancy plot mode, nothing changes
journal_width_1C = 3.5; #plot width for a single column plot
journal_width_2C = 7.5; #plot width for a double column plot (full page width)
journal_height_max = 9.8; #plot height limit (can be less)
journal_dpi = 300; #pixels per inch


#==============User Inputs==============
#Date range goes Year-Month-Day
#dateRange = np.array([[2014,7,30],[2014,8,1]],dtype="int16"); #dates are in int16 because they can be
dateRange = np.array([[2013,5,6],[2013,5,8]],dtype="int16"); #dates are in int16 because they can be
# dateRange = np.array([[2013,5,4],[2013,5,9]],dtype="int16"); #dates are in int16 because they can be
# dateRange = np.array([[2013,4,30],[2013,5,14]],dtype="int16"); #dates are in int16 because they can be
#dateRange = np.array([[2013,11,6],[2013,11,8]],dtype="int16"); #dates are in int16 because they can be
#dateRange = np.array([[2016,11,29],[2016,11,29]],dtype="int16"); #dates are in int16 because they can be
# dateRange = np.array([[2016,11,28],[2016,11,30]],dtype="int16"); #dates are in int16 because they can be
# dateRange = np.array([[2016,11,28],[2016,12,2]],dtype="int16"); #dates are in int16 because they can be
#dateRange = np.array([[2015,2,11],[2015,2,13]],dtype="int16"); #dates are in int16 because they can be
#dateRange = np.array([[2015,3,16],[2015,3,18]],dtype="int16"); #dates are in int16 because they can be
# dateRange = np.array([[2011,3,11],[2011,3,11]],dtype="int16"); #dates are in int16 because they can be
# dateRange = np.array([[2017,3,14],[2017,3,16]],dtype="int16"); #dates are in int16 because they can be
# dateRange = np.array([[2017,3,12],[2017,3,16]],dtype="int16"); #dates are in int16 because they can be
# dateRange = np.array([[2010,5,25],[2010,5,27]],dtype="int16"); #dates are in int16 because they can be
#dates better go earlier -> later
#print("{}".format(dateRange))

#Choose time reference to use for comparison between different data types
time_Reference = 'ISR';
#Options are currently supported data types:
#TEC
#ISR
#AMPERE
ISR_zenithMISA = 0; #0 for Zenith, 1 for MISA for when one ISR comparison is relevant

folder = [os.getcwd()]; #current working directory, leave it as this call usually
folder.append('E:\\Big Data'); #place to save data files to (or read from!)
folder.append(folder[0]+'\\Plots'); #place to save data files to (or read from!)
folder.append(folder[0]+'\\fancyPlots'); #place to save data files to (or read from!)
#folder var structure: 0 = running folder, 1 = data folder, 2 = plots folder, 3 = fancyPlots folder
ffmpegLocale = 'E:\\Utilities\\FFmpeg\\bin\\ffmpeg.exe'; #place where ffmpeg.exe is

settings_paths = {
    'cwd':os.getcwd(),
    'data':settings_config['paths']['data'],
    'plots':settings_config['paths']['plots'],
    'fancyPlots':settings_config['paths']['fancyplots'],
    'ffmpeg':settings_config['paths']['ffmpeg'],
    'cache':settings_config['paths']['cache'],
    };

#--- Ensure plots folder and fancy plots folder exists ---
if( os.path.isdir(folder[2]) == 0 ): #check if the folder exists
    #if not, make it
    os.makedirs(folder[2]);
    print('NOTA BENE: MAIN - Created plots directory: '+folder[2]+'\n');
#END IF
if( os.path.isdir(folder[3]) == 0 ): #check if the folder exists
    #if not, make it
    os.makedirs(folder[3]);
    print('NOTA BENE: MAIN - Created fancyPlots directory: '+folder[3]+'\n');
#END IF

#-----General Plotting Settings-----
settings_spectra = { 
    'windowLength':110, #window length [window type is hamming] - can cause issues if too little data [smooths noise]
    'window type':'hamm', #window type for high-passing
    'window':np.hamming(110),
    'nfft':{'30sec':6144,'1min':3072,'6min':512}, #nfft number
    'noverlap':100, #no overlap number - can cause issues if too little data [smooths noise]
    'period limit max':240*60, #sec, time to limit the freq analysis plots to show (maximum)
    'period limit min':30*60, #sec, time to limit the freq analysis plots to show (minimum)
    'filter order':42, #order of filter
    'filter cutoff period':3*3600, #sec, filter cut off period [defined in hours, coverted to seconds]
    'savgol filter period':180*60, #sec, Sav-Gol filter period [defined in minutes, coverted to seconds]
    'savgol filter order':1 #order of the Sav-Gol fit, 3 is default, 1 is linear
    };

plot_periodLim_max = settings_spectra['period limit max']; #min, time to limit the freq analysis plots to show
# Xaxisvar_SCARGLE = 0:10:plot_Freq_Lim; #create a periodogram x axis tick

#mill for square Mercator style
#robin for oval shape (only for global plots! reverts to stereographic if not global)
#stere for curved projection stuff
#npstere for polar projection stuff
geoMap_projectionStyle = 'mill'; #type the word in
settings_map = {}; #prep a dict


plotLatRange = [35,50]; #latitude limit for plotting
plotLongRange = [-85,-60]; #longitude limit for plotting
#-90 to 90 is world, 35 to 50 is good for USA East Coast
#-180 to 180 is world, -85 to -60 is good for USA East Coast

plotLatRange = [-90,90]; #latitude limit for plotting
plotLongRange = [-180,180]; #longitude limit for plotting
#-90 to 90 is world, 35 to 50 is good for USA East Coast
#-180 to 180 is world, -85 to -60 is good for USA East Coast

# plotLatRange = [0,90]; #latitude limit for plotting
# plotLongRange = [-180,180]; #longitude limit for plotting

# plotLatRange = [30,50]; #latitude limit for USA West Coast
# plotLongRange = [-130,-110]; #longitude limit for USA West Coast

# plotLatRange = [10,50]; #latitude limit for plotting ENITRE USA
# plotLongRange = [-125,-60]; #longitude limit for plotting ENITRE USA

# plotLatRange = [-50,50]; #latitude limit for plotting USA and SA
# plotLongRange = [-80,-50]; #longitude limit for plotting USA and SA

# plotLatRange = [10,25]; #latitude limit for plotting Arecibo
# plotLongRange = [-75,-50]; #longitude limit for plotting Arecibo

# plotLatRange = [-25,25]; #latitude limit for plotting lower North America & Upper SA
# plotLongRange = [-120,-50]; #longitude limit for plotting lower North America & Upper SA

# plotLatRange = [30,75]; #latitude limit for plotting # #-90 to 90 is world, 35 to 50 is good for USA East Coast
# plotLongRange = [-125,-60]; #longitude limit for plotting usa

# plotLatRange = [30,75]; #latitude limit for USA & ALASKA & CANADA & GREENLAND KINDA
# plotLongRange = [-165,-30]; #longitude limit for USA & ALASKA & CANADA & GREENLAND KINDA (GREENLAND IF -30 not -60)

# plotLatRange = [30,75]; #latitude limit for ALASKA & 1/2 of USA/CANADA
# plotLongRange = [-165,-100]; #longitude limit for ALASKA & 1/2 of USA/CANADA

# plotLatRange = [25,50]; #latitude limit for plotting EAST HALF OF USA
# plotLongRange = [-120,-60]; #longitude limit for plotting EAST HALF OF USA

# plotLatRange = [30,75]; #latitude limit for plotting EAST HALF OF USA/CANADA
# plotLongRange = [-100,-60]; #longitude limit for plotting EAST HALF OF USA/CANADA

# plotLatRange = [25,55]; #latitude limit for plotting EAST HALF OF USA/CANADA
# plotLongRange = [-100,-60]; #longitude limit for plotting EAST HALF OF USA/CANADA

# plotLatRange = [0,75]; #latitude limit for North America & Europe
# plotLongRange = [-180,45]; #longitude limit for North America & Europe

# plotLatRange = [-90,90]; #latitude limit for North & South America
# plotLongRange = [-180,-20]; #longitude limit for North & South America

plotLatRange = [-90,25]; #latitude limit for Up to Mexico & South America
plotLongRange = [-120,-20]; #longitude limit for Up to Mexico & South America

plotLatRange = [-90,5]; #latitude limit for South America
plotLongRange = [-100,-25]; #longitude limit for South America

# plotLatRange = [30,75]; #latitude limit for Europe
# plotLongRange = [-15,40]; #longitude limit for Europe

# plotLatRange = [30,75]; #latitude limit for Europe small bit
# plotLongRange = [5,40]; #longitude limit for Europe small bit

# plotLatRange = [30,46]; #good for Japan close up
# plotLongRange = [130,146]; #good for Japan close up

# plotLatRange = [20,55]; #good for Japan a bit farther away
# plotLongRange = [115,160]; #good for Japan a bit farther away

# plotLatRange = [15,90]; #latitude limit for top bit of globe
# plotLongRange = [-180,180]; #longitude limit for top bit of globe

# plotLatRange = [30,75]; #latitude limit for 30 to -30, edge of USA to edge of Europe
# plotLongRange = [-30,30]; #longitude limit for 30 to -30, edge of USA to edge of Europe

# plotLatRange = [15,60]; #good for Japan a bit farther away
# plotLongRange = [55,100]; #good for Japan a bit farther away

# plotLatRange = [-15,15]; #good for Malaysia/Indonesia
# plotLongRange = [90,120]; #good for Malaysia/Indonesia



plot_Scatter_Point_Size = 325; #arb. scatter pt size to make it big and easy to see

pointAltitude = 300; #km, altitude where most e-'s are (F region max - assumed)

filter_cutoffPeriod = 2*3600; #sec, cut off period to high pass filter at (high pass removes anything higher period than # (e.g. 2) hr)
#used in ISR and TEC processing 

time_cutout_range = [18*3600,35*3600]; #sec, cut-out this time period for comparison between the ISR & GPS data at the best possible time to compare (night)
# time_cutout_range = [(18-12)*3600,(35-12)*3600]; #sec, cut-out this time period for comparison between the ISR & GPS data at the best possible time to compare (night)
time_cutout_range = [-16*3600,-12*3600]; #sec, cut-out this time period for comparison between the ISR & GPS data at the best possible time to compare (night)
time_cutout_range = [-12*3600,-4*3600]; #sec, cut-out this time period for comparison between the ISR & GPS data at the best possible time to compare (night)
# time_cutout_range = [-2*3600,48*3600]; #sec, cut-out this time period for comparison between the ISR & GPS data at the best possible time to compare (night)
# time_cutout_range = [10*3600,18*3600]; #sec, cut-out this time period for comparison between the ISR & GPS data at the best possible time to compare (night)
time_cutout_range_delay_AMPERE = +1.0; #affects AMPERE data b/c it can have propagation delays to get to the direct measurements at sites (from GPS-TEC or ISR)
#1 hr = JH aligned to 65 deg latitude - for 700 m/s speed and 87.8 deg originating latitude
#1.66 hr = JH aligned to 55 deg latitude
#2 hr = JH aligned to 42.6 deg latitude [MH latitude]
time_cutout_range_delay_OMNI = time_cutout_range_delay_AMPERE+4.0; #affects AMPERE data b/c it can have propagation delays to get to the direct measurements at sites (from GPS-TEC or ISR)
#OMNI delay should be a mostly static offset from the AMPERE data, while the AMPERE data changes with what latitude you want it to coincide with [so scale OMNI delay off of AMPERE w/ a static offset]

#-----TEC import options-----
settings_TEC_import = { 
    'TEC_maxAmpAllowed':2, #TECU, max val allowed - it is a forced cutoff value (ref data had a max of 396 it seems)
    'TEC_timeTolerance':0.1, #0.1:10% so time tolerance is within 10%. So for 30 sec time steps, 10% time tolerance will make 27-33 sec time stamps be 30 sec time stamps
    'TEC_minElevation':30, #deg, [min elevation angle used to process data, min elevation angle accepted after data is processed]
    'TEC_minimumTimeGap':5*60, #sec, how long to accept a gap in a satellite observation before calling it a new, unrelated observation
    'TEC_deltaTEC_compareValue':6, #median comparator number for choosing stuff on the edges that are out of an acceptable range, inspired by https://stackoverflow.com/questions/11686720/is-there-a-numpy-builtin-to-reject-outliers-from-a-list
    'TEC_dataRate':30, #sec/datapt, the data rate. No super easy way to get it out of the data automatically, so it's a variable to control
    'filter_savGolPeriod':60*60, #sec, filter period for the Sav-Gol filter
    'order_savGol':1, #order of the Sav-Gol fit, 3 is default, 1 is linear
    'web_base_name':settings_config['login Madrigal']['name'], #put your name here (for spaces use +'s instead)
    'web_base_email':settings_config['login Madrigal']['email'], #put your email here
    'web_base_affil':settings_config['login Madrigal']['affil'], #put your affiliation here (school etc)
    'web_LISN_creden_user':settings_config['login LISN']['user'], #put your LISN user here
    'web_LISN_creden_pass':settings_config['login LISN']['pass'], #put your LISN password here
    'FLG_dataAggregation':0, #0 don't aggregate nearby TEC values with a site/sat combo, 1 aggregate nearby TEC values with a site/sat combo for MORE DATA PER DATA [does not work atm, may never]
    'TEC_dataAgg_timeAdditionLimit':1*60*60, #sec, time to add on to a satellite's visible time before calling it quits
    'TEC_dataAgg_distToPts':20, #km, distance to extended points for TEC data to exist
    'TEC_dataLimPercent':0.05, #0.05:5%, cut out times with very low data content (less than 5% of the mean data content #)
    'TEC_deltaLim':0.5, #unrelated to above, value between fit/real data to find where ends of the fit where it starts diverging
    'FLG_reqPaddedDays':0, #requires padded days if 1, doesn't require them if 0
    'FLG_deleteOrig':0, #deletes original files if 1, doesn't delete original files if 0 (original being ones DL'd from Madrigal)
    'FLG_deleteUnfilt':0, #deletes unfiltered middle-stage files if 1, doesn't delete unfiltered files if 0 (makes recalc's faster if they're kept)
    'FLG_overwrite':0, #recalcs & overwrites files even if they're there if 1, doesn't recalc and uses files if they're there if 0
    };

Re = 6371.0; #km, Earth mean Radius
#from http://nssdc.gsfc.nasa.gov/planetary/factsheet/earthfact.html

MillstoneMISA_azimuth = 168.5; #deg Azimuth from North towards East (assuming geo - none specified)
MillstoneMISA_elev = 66.26; #deg elevation
MillstoneZenith_elev = 88; #deg elevation
#Lat and long reference points
latLong_ref = [];
latLong_refIndex = np.array( (0,1) ); #which one to use
#Location of Millstone Hill
latMillstone = 42.6233; #Deg North MH
longMillstone = -71.4882; #Deg East MH (71.4882 deg West)
# longMillstone = 15; #Deg East, forces it into Europe
#Location of Arecibo
# latMillstone = 18+20/60+36.6/3600; #Deg North AO
# longMillstone = -(66+45/60+11.1/60); #Deg East AO (67some deg West)
# latMillstone = 34+51/60+8/3600; #Deg North - Japan MU radar
# longMillstone = 136+6/60+32/3600; #Deg West - Japan MU radar
# latMillstone = 59; #Deg North - europe
# longMillstone = 10; #Deg West - europe
# longMillstone = -120; #Deg West - west USA
# longMillstone = -150; #Deg West - Alaska
# longMillstone = 63; #Deg North - Alaska
latLong_ref.append( [latMillstone,longMillstone] ); #record it in the multi-dimensional list *TOP DANGER*
latMillstoneMISA = latMillstone + np.sin( (MillstoneMISA_azimuth+90)*np.pi/180 )*(((pointAltitude/np.tan(MillstoneMISA_elev*np.pi/180) )/Re)*180/np.pi); #deg North (see spreadsheet titled ISR Angle Calc)
longMillstoneMISA = longMillstone - np.cos( (MillstoneMISA_azimuth+90)*np.pi/180 )*(((pointAltitude/np.tan(MillstoneMISA_elev*np.pi/180) )/Re)*180/np.pi); #deg East at MISA (Azimuth is clockwise - cosine gets a negative)
latLong_ref.append( [latMillstoneMISA,longMillstoneMISA] ); #record it in the multi-dimensional list *TOP DANGER*
# latMillstone = 42.6233 - (100/Re)*(180/pi); #Deg North
# plotLatRange = [latMillstone-24,latMillstone+8]; #new latitude limit for plotting
# plotLongRange = [longMillstone-8,longMillstone+8]; #new longitude limit for plotting
# longMillstone = -74.0; #deg east, philly
# longMillstone = 23+10/60; #deg west, Kalix Sweeden (over south africa)
# longMillstone = 140+52/60; #deg west, Sendai Japan (over Eastern Japan)
# longMillstone = 119+44/60+49/3600; #deg west, Marble Bar Australia (over East China/West Australia)
# latMillstone = mean(plotLatRange); #center
# longMillstone = mean(plotLongRange); #center
# latMillstone = 38; #put at 38 deg N
# longMillstone = 37.5; #put at 54 deg E

#==============TEC Data Options==============
FLG_TEC_use = [2,]; #0 uses all TEC sources and combines. 
#Can combine numbers bellow in an array like [2,3,5] to get just those data sources
#1 - Pre-processed data (alternate to 2, will not combine with 2)
#2 - Madrigal Database TEC (will not combine with 1)
#3 - LISN Database TEC
FLG_TEC_noise = 0; #0 regular data
#1 replace TEC values with Gaussian noise - keep time/location
#2 replace TEC values with Gaussian noise and a synthetic wave - keep time/location
noise_background_mean = 0; #delta_vTEC, avg of noise background
noise_background_stdev = 0.3168; #delta_vTEC, standard dev of noise background taken from all vTEC data
#----synthetic wave parameters----
wave_N = 3000; #splits lat/long ranges into chunks
wave_period = np.zeros(2); #preallocate
wave_waveLength = np.zeros(2); #preallocate
wave_angle = np.zeros(2); #preallocate
wave_phase = np.zeros(2); #preallocate
wave_amp = np.zeros(2); #preallocate
wave_period[0] = 1.0; #hr, period of wave
wave_waveLength[0] = 200; #km, wavelength of wave given in paper EPS_2008_Seker
# wave_waveLength = 700; #km, wavelength of wave
# wave_waveLength[0] = 4000; #km, wavelength of wave
# wave_waveLength = 1.21*2800; #km, wavelength of wave
wave_angle[0] = 135; #deg, angle of wave direction
wave_phase[0] = 0; #deg, 0 to 360, phase of wave
wave_amp[0] = 0.15; #delta_vTEC, amplitude of wave
#2ND WAVE
wave_period[1] = 1.5; #hr, period of wave
wave_waveLength[1] = 200; #km, wavelength of wave given in paper EPS_2008_Seker
# wave_waveLength[1] = 700; #km, wavelength of wave
# wave_waveLength[1] = 1.21*2800; #km, wavelength of wave
wave_angle[1] = 135; #deg, angle of wave direction
wave_phase[1] = 0; #deg, 0 to 360, phase of wave
wave_amp[1] = 0.00; #delta_vTEC, amplitude of wave
wave_latRange = np.array([-90,90]); #arcdeg, latitude range maximum
wave_longRange = np.array([-180,180]); #arcdeg, longitude range maximum

#==============TEC Averaging Options==============
#main TEC settings
TEC_plotLimValu = 0.5; #TECU, limit (+ and -) for plotting the TEC movie and other plots too
settings_TEC = {
    'plot lim':np.array( (-0.5,0.5) ), #TECU, limit (+ and -) for plotting the TEC movie and other plots too
    'colormap':'jet', #TEC colormap
    'data type':'TEC', #main data type
    'name':'delta-vTEC', #TEC data type name
    'units':' [TECU]', #TEC unit
    'scatter size':40, #kinda arbitrary scatter pt size used for TEC scatter plots
    'source to use':FLG_TEC_use,
    }; #prep some TEC settings
#!!!-----0 for off, 1 for on-----!!!
FLG_avg_anyAngle = 0; #averaging TEC in bands, needed for anything with _anyAngle
FLG_avg_anyAngle_plot = 0; #averaging TEC in bands
FLG_avg_anyAngle_plot_timeCutout = 0; #Uses the time cutout range defined below
#[ONLY FANCY PLOTS]
FLG_TEC_keo_dataDensity = 0; #shows the data density for the period involved and the area involved
FLG_avg_anyAngle_plot_wNoise = 0; #[ONLY FANCY PLOT]
FLG_avg_anyAngle_plot_noiseAllViews = 0; #[ONLY FANCY PLOT]only works if latRange=[-90,90]&longRange=[-180,180] - plots time series, east coast noise, world noise in 2 directions (0 and 90)

FLG_combinedPlot_keo_TEC_n_AMPERE_1Dintegration = 0; #plots avg'd TEC and AMPERE data integrated in the zone
FLG_AMPERE_upTo90 = 1; #0 integrates AMPERE in the TEC averaging zone, 1 integrates AMPERE in the longitudes and min latitude, but max latitude is set to 90
FLG_combinedPlot_keo_TEC_n_AMPERE_1Dintegration_auroralZone = 0; #plots avg'd TEC and AMPERE data integrated in the entire auroral zone (high latitude)
FLG_combinedPlot_keo_TEC_n_AMPERE_1Dintegration_auroralZone_spectra = 0; #Scargle or FFT TEC at chosen line lat/long and AMPERE data integrated in entire auroral zone
FLG_combinedPlot_keo_TEC_n_AMPERE_1Dintegration_auroralZone_spectra_timeMatch = 0; #Scargle or FFT TEC at chosen line lat/long and AMPERE data integrated in entire auroral zone matched to a time frame

FLG_FFTthruTime_KEOnAvgPtnAMPEREintegrated = 0; #perform FFT power spectra walking through time on TEC Keogram & TEC at a pt & AMPERE integrated

FLG_keo_stacker = 0; #stacks keogram days ontop of eachother
FLG_keo_stackerPlot = 0; #plots the stacked keograms

FLG_avg_anyAngle_zenithOrMISA = 0; #0 for plot vs Zenith ISR, 1 for plot vs MISA ISR
FLG_avg_anyAngle_timeMatch_n_HP_Scargle = 0; #Scargles the data
FLG_avg_anyAngle_Scargle_FFT = 1; #0 for Scargle, 1 for FFT
#FLG_avg_anyAngle_fullTime = 1; #0 for match to Zenith/MISA (norm), 1 for full time (will break stuff later I bet)
#-----Settings for above plots-----
avg_anyAngle = 90; #deg, user defined angle
avg_anyAngle_Width_orig = 360; #arcdeg, total width - not an angle in this instance [put 360 for 0/90/180/270 because the code will autotruncate that
avg_anyAngle_N = 200; #number of chunks to split the range into  [reg 200]
avg_anyAngle_polarMode = 0; #0 for regular plotting, 1 for polar plotting of the averaging area
avg_anyAngle_45vsLatLong = 1; #0 for longitude on xaxis on a 45 degree angle (or multiple of it), 1 for latitude on xaxis
avg_anyAngle_Zoom = 5; #+/-# arcdeg around the Millstone Hill beam of choice, zoom for the time-cut plot
keo_TEC_dataName = 'delta-vTEC'; #set data name without units
keo_TEC_dataName_wUnits = 'delta-vTEC [TECU]'; #set data name with units
keo_TEC_colorMap = 'jet'; #set colormap to use
settings_TEC['keo'] = {
    'keo angle':90, #deg, user defined angle
    'keo width orig':360, #arcdeg, total width - not an angle in this instance [put 360 for 0/90/180/270 because the code will autotruncate that
    'keo N':200, #number of chunks to split the range into  [reg 200]
    'keo polar mode':0, #0 for regular plotting, 1 for polar plotting of the averaging area
    'keo 45 lat or long':1, #0 for longitude on xaxis on a 45 degree angle (or multiple of it), 1 for latitude on xaxis
    'keo zoom':5, #+/-# arcdeg around the Millstone Hill beam of choice, zoom for the time-cut plot
    'keo data type':settings_TEC['data type'], #set the main data type
    'keo name':settings_TEC['name'], #set data name without units
    'keo units':settings_TEC['units'], #set data name with units
    'keo colormap':settings_TEC['colormap'], #set colormap to use
    'keo plot lim':settings_TEC['plot lim'], #TECU, limit (+ and -) for plotting the TEC 
    'keo scatter size':settings_TEC['scatter size'], #kinda arbitrary scatter pt size used for TEC scatter plots
    'source to use':settings_TEC['source to use'], #records the data sources
    }; #dict of settings
#other types of plots!

#---Double Keo settings---
#This is for a double keo w/ AMPERE data overlay and some plots
FLG_doubleKeo = 0; #double keo enable
FLG_doubleKeo_plot = 0; #double keo plot (2 plots the 2 keos on the same plot with an defined overlap latitude)
FLG_doubleKeo_plot_timeCutout = 0; #plots double keo with the time cutout (2 plots the 2 keos on the same plot with an defined overlap latitude)
doubleKeo_latLong = [[[50,75],[-15,40]],[[25,50],[-100,-60]]]; #the 2 sets of lat and long coords
# doubleKeo_latLong = [[[25,50],[-100,-60]],[[25,50],[-165,-100]]]; #the 2 sets of lat and long coords [west USA]
doubleKeo_angle_orig = [90,90]; #deg, user defined angle
doubleKeo_width_orig = [360,360]; #arcdeg, total width - not an angle in this instance
doubleKeo_N = [200,200]; #number of chunks to split the range into  [reg 200]
doubleKeo_45vsLatLong = [0,0]; #0 for longitude on xaxis on a 45 degree angle (or multiple of it), 1 for latitude on xaxis
FLG_doubleKeo_AMPERE_integrateMethod = [2,2]; #0 for averaging within the respective keogram area, 1 for latitudes max is the pole, 2 for a set upper latitude value, 3 for entire hemisphere (based on plot range which hemisphere)
doubleKeo_AMPERE_integrateMethod_val = 75; #degc, latitude value to go up to if FLG_doubleKeo_AMPERE_integrateMethod==2
FLG_doubleKeo_AMPERE_filtMethod = 'none'; #can be None, high-pass, low-pass, Sav-Gol - filters the data before displaying
doubleKeo_AMPERE_plotLim = 20000; #plot limit for AMPERE data, set to False for no limit
doubleKeo_AMPERE_timeDelay = [+1.2, +2.0]; #1 for europe, 1.66 for USA, 2.5 for Japan
doubleKeo_AMPERE_latAlign = [65, latMillstone]; #65 lat in europe, 42.6233 lat in USA east coast
doubleKeo_niteTimes = [[-7.5,5],[0.5,11.35]]; #'nite' times in UT for Europe/USA East Coast [make 1st entry False to disable and use auto-nite detection based on location/date]
doubleKeo_arrowTimes = [-11.567,-10.786]; #[arrow time] for both ends of the arrow. Last one is the arrow head side
#3 set below
# doubleKeo_latLong = [[[30,75],[-15,40]],[[30,75],[-100,-60]],[[30,75],[-165,-100]]]; #the 2 sets of lat and long coords
# doubleKeo_angle_orig = [90,90,90]; #deg, user defined angle
# doubleKeo_width_orig = [360,360,360]; #arcdeg, total width - not an angle in this instance
# doubleKeo_N = [200,200,200]; #number of chunks to split the range into  [reg 200]
# doubleKeo_45vsLatLong = [0,0,0]; #0 for longitude on xaxis on a 45 degree angle (or multiple of it), 1 for latitude on xaxis
# FLG_doubleKeo_AMPERE_integrateMethod = [0,0,0]; #0 for averaging within the respective keogram area, 1 for latitudes max is the pole
# doubleKeo_AMPERE_timeDelay = [+1.0, +1.66, +1.66]; #1 for europe, 1.66 for USA
# doubleKeo_AMPERE_latAlign = [65, latMillstone, latMillstone]; #65 lat in europe, 42.6233 lat in USA east coast
# doubleKeo_AMPERE_niteTimes = [[-8,5],[-1,10],[0.5,18]]; #'nite' times in UT for Europe/USA East Coast
FLG_doubleKeo_xcorr = 0; #calcs cross-correlation spectra and correlation coefficients between the keo and the AMPERE data
doubleKeo_xcorr_TEC_filtMethod = 'high-pass & 0 mean'; #can be None, 0 mean, high-pass, low-pass, Sav-Gol - filters the data before displaying
doubleKeo_xcorr_AMPERE_filtMethod = 'high-pass & 0 mean'; #can be None, 0 mean, high-pass, low-pass, Sav-Gol - filters the data before displaying [this is in addition to upper filter option, ideally use this if upper is 'none']
# doubleKeo_xcorr_AMPERE_filtMethod = 'none'; #can be None, 0 mean, high-pass, low-pass, Sav-Gol - filters the data before displaying [this is in addition to upper filter option, ideally use this if upper is 'none']
doubleKeo_xcorr_noiseIterations = 100; #iterations to run the noise on
doubleKeo_xcorr_timeRangePer = [[-16*3600,-12*3600],[-12*3600,-4*3600]]; #sec, time range cutout per keo, each keo gets a specific time range cutout and the results are plotted separately (put False as 1st entry to disable)
doubleKeo_xcorr_timeRangeSlam = [False,[-16*3600,-12*3600],[-12*3600,-4*3600]]; #sec, time range cutout per keo, combines time ranges from different keos into one congituous thing (put False as 1st entry to disable)

#---Keo for TEC & Magnetometer---
FLG_doubleKeo_TECnMag = 0; #activate this combo
doubleKeo_TECnMag_TEC_latLong = [[25,50],[-100,-60]]; #the 2 sets of lat and long coords
doubleKeo_TECnMag_TEC_angleOrig = 90; #deg, user defined angle
doubleKeo_TECnMag_TEC_widthOrig = 360; #arcdeg, total width - not an angle in this instance [put 360 for 0/90/180/270 because the code will autotruncate that
doubleKeo_TECnMag_TEC_N = 200; #number of chunks to split the range into  [reg 200]
doubleKeo_TECnMag_TEC_polarMode = 0; #0 for regular plotting, 1 for polar plotting of the averaging area
doubleKeo_TECnMag_TEC_45vsLatLong = 1; #0 for longitude on xaxis on a 45 degree angle (or multiple of it), 1 for latitude on xaxis
doubleKeo_TECnMag_TEC_dataName = 'delta-vTEC'; #set data name without units
doubleKeo_TECnMag_TEC_dataName_wUnits = 'delta-vTEC [TECU]'; #set data name with units
doubleKeo_TECnMag_TEC_colorMap = 'jet'; #set colormap to use
doubleKeo_TECnMag_Mag_angle = 90; #deg, user defined angle
doubleKeo_TECnMag_Mag_width = 360; #arcdeg, total width - not an angle in this instance
doubleKeo_TECnMag_Mag_N = 5; #number of chunks to split the range into  [reg 8]
doubleKeo_TECnMag_Mag_polarMode = 0; #0 for regular plotting, 1 for polar plotting of the averaging area
doubleKeo_TECnMag_Mag_45vsLatLong = 1; #0 for longitude on xaxis on a 45 degree angle (or multiple of it), 1 for latitude on xaxis
doubleKeo_TECnMag_Mag_plotLimVal = [-15,15]; #nT, plot limit values
# doubleKeo_TECnMag_Mag_plotLimVal = None; #disable
doubleKeo_TECnMag_Mag_filtMethod = 'savgol'; #can be None, 0 mean, high-pass, low-pass, Sav-Gol - filters the data before displaying
#less important settings for plotting
doubleKeo_TECnMag_Mag_colorMap = 'jet'; #sets the colorbar used
doubleKeo_TECnMag_Mag_normalize = 1; #1 normalizes, 0 doesn't normalize - magnetic field magnitude drops with latitude, normalization keeps it "more comparable" in a way but also not kinda cause it's an absolute number that means things
doubleKeo_TECnMag_Mag_setPlotRange = 1; #1 sets plot range manually, 0 automagically figures it out based on the magnetometers in use
doubleKeo_TECnMag_Mag_setPlotRange_range = [ [50,85],[-100,-50] ]; #full range is around [ [40,85],[-125,-50] ]
doubleKeo_TECnMag_Mag_setStations = 1; #1 sets stations to use, 0 uses all stations
doubleKeo_TECnMag_Mag_setStations_names = ['EUA','RES','CBB','BLC','IQA','SNK','STJ','OTT'];#'BLC','BRD','CBB','EUA','FCC','IQA','MEA','OTT','RES','SNK','STJ','VIC','YKC' #names of the magnetometer stations

#-----0 for off, 1 for on-----
FLG_activityIndex = 0; #calculates an activity index for the delta-vTEC across the globe

#-----0 for off, 1 for on-----
FLG_avgPt = 0; #averaging TEC at a point, need for anything with _avgPt - also high-pass filters the data
FLG_avgPt_timeMatch = 0; #for TEC - set to ISR cadence & high-pass, for ISR - average #pointAltitude# altitude ISR line by +/- #avgPt_ISRavgAlt# km
#[not needed]FLG_avgPt_HP_timeMatch_POPL = 0; #for TEC - set to ISR cadence & high-pass, for ISR - average #pointAltitude# altitude ISR line by +/- #avgPt_ISRavgAlt# km
FLG_avgPt_HP_timeMatch_plotWithISR_cutOut = 0; #plot the above data with ISR plots, cut out for the time period defined by time_cutout_range
FLG_avgPt_HP_timeMatch_POPL_plotWithISR_cutOut = 0; #plot the above data with ISR plots, cut out for the time period defined by time_cutout_range
FLG_avgPt_HP_timeMatch_plotWithISR_ZenithOnly_cutOut = 0; #plot the above data with ISR plots, cut out for the time period defined by time_cutout_range
FLG_avgPt_HP_timeMatch_POPL_plotWithISR_ZenithOnly_cutOut = 0; #plot the above data with ISR plots, cut out for the time period defined by time_cutout_range
FLG_avgPt_HP_timeMatch_scargleWithISR_cutOut = 0; #scargle the TEC & ISR time series data
FLG_avgPt_HP_timeMatch_POPL_scargleWithISR_cutOut = 0; #scargle the TEC & ISR time series data
FLG_avgPt_HP_timeMatch_POPLnOMNI_scargleORfft_cutOut = 0; #fft or scargle (depending on if there's gaps or not) the TEC & ISR time series data
FLG_avgPt_HP_timeMatch_POPL_CPSD_cutOut = 0; #perform CPSD between TEC & ISR over designated time cutout range (all time series data)
FLG_avgPt_HP_timeMatch_POPLnTECNOISE_CPSD_cutOut = 0; #!!ONLY FANCY PLOT!! perform CPSD between TEC & ISR & TEC noise
FLG_avgPt_HP_timeMatch_POPLnTECNOISE_FFT_cutOut = 0; #!!ONLY FANCY PLOT!! perform FFT on TEC & ISR & TEC noise
FLG_avgPt_HP_timeMatch_POPLnOMNI_CPSD_cutOut = 0; #perform CPSD between TEC & ISR and BzGSM & ISR over designated time cutout range (all time series data)
FLG_avgPt_HP_timeMatch_POPLnOMNI_FFT_cutOut = 0; #perform FFT on TEC & ISR * OMNI over designated time cutout range (all time series data)
FLG_avgPt_HP_timeMatch_POPLnOMNInTECNOISE_CPSD_cutOut = 0; #perform CPSD between TEC & ISR and BzGSM & TEC NOISE averaged over # iterations  over designated time cutout range (all time series data)
FLG_avgPt_HP_timeMatch_POPLnOMNInTECNOISE_FFT_cutOut = 0; #perfom FFT power spectra on TEC & ISR & OMNI BzGSM (or whatever is selected) & TEC NOISE averaged over # iterations (all time series data)
FLG_avgPt_HP_timeMatch_POPLnAMPERE_FFT_cutOut = 0; #perform FFT on TEC & ISR & AMPERE over designated time cutout range (all time series data)
FLG_avgPt_HP_timeMatch_POPLnAMPERE_plotWithISR_ZenithOnly_cutOut = 0; #plot the above data with ISR plots, cut out for the time period defined by time_cutout_range
FLG_AMPERE_log = 1; #makes AMPERE be log
FLG_AMPERE_hp = 1; #makes AMPERE be high-passed (happens after log if log is on, b/c HP can make negative values)
avgPt_TECnoise_iterations = 100; #number of iterations of noise to average together
FLG_avgPt_HP_timeMatch_FFTthruTime_POPLnOMNI = 0; #perform FFT power spectra walking through time on TEC & ISR & OMNI
thruTime_width = 12; #hrs to FFT/CPSD together
thruTime_step = 1; #hrs to step forward by before spectral analysing the _width

#-----Settings for above plots-----
avgPt_pointRadius = 50; #km, radius around the point to search for nearby points
avgPt_ISRavgAlt = 25; #km, +/- altitude range to average ISR by
avgPt_coords = np.array( ((latMillstone, longMillstone),(latMillstoneMISA,longMillstone)) ); #set the coordinates to average around
avgPt_coordsName = ['Millstone Hill ISR','Millstone Hill ISR MISA Beam Location at '+str(pointAltitude)+' km']; #name for it, for plotting
avgPt_plotLatMax = 4; #degc, for avg radius visualization plot, amount to go up/down in lat by wrt the avgPt_coords point specified - long scales automagically so circle is circular
dataReject = 2;#ratio that is multiplied by variance and used to determine how much data to eject
dataRejectMax = 4*dataReject; #maximum multiplier to reach
dataRejectLimit = 25; #percentage, limit on how much data can be jetisoned
dataRejectOrig = dataReject; #record original value
dataRejectLimitOrig = dataRejectLimit; #record original value
settings_map['site coords'] = avgPt_coords;
settings_map['site names'] = avgPt_coordsName;

#==============TEC Noise Options==============
FLG_multiRunNoise_avgPt_HP_timeMatch = 0; #runs multiple iterations of noise generation to yield multiple realizations of the noise for analysis with the avgPt scheme

#==============ISR Plotting Options==============
#choose the data type to plot
#ISR_type = 'SNR'; #Signal-to-noise ratio - not on many datasets
ISR_type = 'POPL'; #calibrated electron density (#/m^3) assuming Temp Elec == Temp Ion, Range Squared Corrected
#ISR_type = 'Ne'; #calibrated electron density (#/m^3), no assuming Te==Ti, so more NaNs when can't calc it

FLG_ISR_data = 0; #turn on ISR data import only, so it can be used for comparison with other data types
#-----0 for off, 1 for on-----
FLG_ISR_plot_POPL_HP = 0; #plot ISR POPL HP results, both bands
FLG_ISR_plot_POPL_HP_cutOut = 0; #plot ISR POPL HP results, both bands for a time cutout range
FLG_ISR_plot_POPL = 0; #plot ISR POPL no filter results, both bands
FLG_ISR_plot_POPL_limited = 0; #plot ISR POPL no filter results, both bands, limited C axis to ISR_plotLimValu like in the POPL HP plots

FLG_ISR_plot_POPL_ScargleSet = 0; #shows both bands POPL/POPL HP/Scargle of SNR HP all at 300 km altitude
FLG_ISR_plot_POPL_FFTSet = 0; #shows both bands POPL/POPL HP/FFT of SNR HP all at 300 km altitude

ISR_plotLimValu = 0.1; #unitless SNR, limit (+ and -) for plotting ISR stuff
ISR_POPL_plotLimValu_noFilt = np.array( (1*10**11, 8*10**11) ); #e-/m^3 POPL, limit (- and +) for plotting ISR stuff
#ISR_POPL_plotLimValu = np.array( (-2*10**10, 2*10**10) ); #e-/m^3 POPL, limit (- and +) for plotting ISR stuff (no range-squared correction)
ISR_POPL_plotLimValu = np.array( (-2*10**5, 2*10**5) ); #e-/m^3 POPL, limit (- and +) for plotting ISR stuff
ISR_RTI_heightLimValues = (90, 550); #km, min and max ylim to apply to ISR RTI plots

#-----Pokerflat ISR Stuff-----
FLG_ISR_Pokerflat_plot_POPL_HP = 0; #plot ISR POPL HP results, both bands
FLG_ISR_Pokerflat_plot_POPL = 0; #plot ISR POPL no filter results, both bands
FLG_ISR_Pokerflat_plot_POPL_limited = 0; #plot ISR POPL no filter results, both bands, limited C axis to ISR_plotLimValu like in the POPL HP plots

ISR_Pokerflat_PrefferedElevation = 90; #deg, elevation angle to plot. To plot all use -1, or a range [90,80] - it gets the ones closest to the ones you wanted (so if 80.88 is a thing, it'll choose that for 80)
ISR_Pokerflat_RTI_heightLimValues = (90, 550); #km, min and max ylim to apply to ISR RTI plots
#ISR_POPL_plotLimValu = np.array( (-9*10**10, 9*10**10) ); #e-/m^3 POPL, limit (- and +) for plotting ISR stuff

#-----0 for off, 1 for on-----
FLG_ISR_plot_ionVel = 0; #plots ion velocity for Zenith and MISA
FLG_ISR_plot_ionVel_cutOut = 0; #plots ion velocity for Zenith and MISA for the time limit specified above
FLG_ISR_plot_ionVel_hp = 0; #plots ion velocity for Zenith and MISA that is filtered
FLG_ISR_plot_ionVel_hp_cutOut = 0; #plots ion velocity for Zenith and MISA that is filtered for the time limit specified above
#------Settings for above plots-----
ISR_ionVel_plotLimValu_noFilt = np.array( (-20, 20) ); #m/s, ion velocity plot limit
ISR_ionVel_plotLimValu = np.array( (-5, 5) ); #m/s, ion velocity plot limit

#-----0 for off, 1 for on-----
FLG_ISR_plot_SNR_HP = 0; #plot ISR SNR HP results, both bands
FLG_ISR_plot_SNR = 0; #plot ISR SNR no filter results, both bands
FLG_ISR_plot_SNR_limited = 0; #plot ISR SNR no filter results, both bands, limited C axis to ISR_plotLimValu like in the SNR HP plots

FLG_ISR_plot_ScargleSet = 0; #shows both bands SNR/SNR HP/Scargle of SNR HP all at 300 km altitude
#-----Settings for above plots-----

#not implemented
FLG_ISR_AMPERE_CPSD_cutOut = 0; #perform CPSD between ISR & JH over designated time cutout range (all time series data)

#==============Kp and OMNI Plotting Options==============
#-----0 for off, 1 for on-----
FLG_Kp_plot = 0; #plot Kp for the time period (data from internet)
FLG_OMNI_plot = 0; #plot OMNI for the time period (data from internet)
FLG_OMNI_plot_scargle = 0; #plot scargle of an OMNI data time series (data from internet)
FLG_OMNI_plot_FFT = 0; #plot FFT of an OMNI data time series (data from internet)
FLG_OMNI_stacker = 0; #stack an OMNI data type
FLG_OMNI_stacker_FFT = 0; #get spectra of that stacked OMNI data type
OMNI_FFT_filtMethod = 'High-Pass'; #options are none, High-Pass, Low-Pass, Sav-Gol
#-----Settings for above plots-----
#Things to think about plotting
#  Bz GSM , Vsw, Psw, SYM/H, Bz GSE, AE
OMNI_plotSet_name = ['Bz GSM','Vsw','Psw','SYM/H']; #names of OMNI data to be plotted in large plot
# OMNI_plotSet_name = ['Bx GSE & GSM','By GSE','Bz GSE']; #names of OMNI data to be plotted in large plot
OMNI_plot_name = 'Bz GSM'; #name of OMNI data to be plotted in detailed analysis
OMNI_plot_scargle_name = 'Bz GSM'; #name of OMNI data to be scargle'd
OMNI_plot_scargle_highpassOption = 3; #0 no high-pass, just original data | 1 for original data & high-passed data | 2 for just high-passed data
                                      #3 for original data & delta-data [like how TEC is calc'd] |  
FLG_FFTthruTime_KEOnAMPEREnOMNIintegrated = 0; #perform FFT power spectra walking through time on TEC Keogram & OMNI & AMPERE integrated
FLG_FFTthruTime_KEOnAMPEREnOMNIintegrated_OMNIindexes = ['Bz GSM','Vsw','Psw','SYM/H']; #OMNI indexes to use
FLG_FFTthruTime_KEOnAMPEREnOMNIintegrated_upTo90 = 2; #0 for averaging within the respective keogram area, 1 for latitudes max is the pole, 2 for a set upper latitude value, 3 for entire hemisphere (all longitudes, 0-90 latitudes)
FFTthruTime_KEOnAMPEREnOMNIintegrated_AMPERE_upToVal = 75; #degc, latitude value to go up to if FLG_doubleKeo_AMPERE_integrateMethod==2
FLG_FFTthruTime_KEOnOMNIintegrated = 0; #perform FFT power spectra walking through time on TEC Keogram & OMNI [same settings as above]

#==============AMPERE Plotting Options==============
#-----0 for off, 1 for on-----
#NOTE the 3 below use the TEC settings above for the same plot styles
FLG_AMPERE_avg_anyAngle = 0; #averaging AMPERE data in bands, needed for anything with _anyAngle
FLG_AMPERE_avg_anyAngle_plot = 0; #averaging AMPERE data in bands
FLG_AMPERE_avg_anyAngle_plot_timeCutout = 0; #Uses the time cutout range defined below
FLG_AMPERE_keo_spectra = 0; #spectra plot of the AMPERE keogram
FLG_AMPERE_keo_plot_wSun = 0; #Plots keogram of AMPERE data with sun location plotted as well
FLG_AMPERE_keo_plot_wSunCenter = 0; #plots keogram of AMPERE data with keo pixel under the sun at the center of the plot (it's magic)
FLG_AMPERE_keo_spectra_wSunCenter = 0; #spectra plot of the sun-centered keogram pixel line (it's magic)
#except for
#AMPERE_avg_anyAngle_Ndeg = 1.8; #arcdeg, width of the lines - the N# will be calculated off of this
# AMPERE_plotLimValu = [1,25]; #erg/(cm^2*sec), low and high limits for plotting joule heating - taken from example video (seems Joule Heating low end limit is 1 - nothing less than 1)
# AMPERE_plotLimValu = [1,5]; #erg/(cm^2*sec), low and high limits for plotting joule heating - taken from example video (seems Joule Heating low end limit is 1 - nothing less than 1)
#AMPERE_plotLimValu = [0,2]; #for log10 plotting
AMPERE_plotLimValu = [-np.inf, np.inf]; #no limit
AMPERE_keo_spectra_filtMethod = 'high-pass'; #options are none, high-pass, low-pass, Sav-Gol
AMPERE_keo_spectra_spectraMethod = 'fft'; #options are FFT, FFT no norm, Lomb-Scargle

FLG_AMPERE_integrate_plot = 0; #plot AMPERE integrated across the northern and southern hemispheres vs time
FLG_AMPERE_integrate_scargle = 0; #plot scargle of AMPERE integrated across the defined integration areavs periods [NOT YET]
FLG_AMPERE_integrate_FFT = 0; #plot FFT of AMPERE integrated across the defined integration area vs periods [NOT YET]
FLG_AMPERE_integrate_limArea_plot = 0; #plot AMPERE integrated across the a plot range area vs time
FLG_AMPERE_integrate_limArea_scargle = 0; #plot the scargle  of the AMPERE integrated across the a plot range area
FLG_AMPERE_integrate_andOMNI_AE_plot = 0; #plot AMPERE integrated along with OMNI's AE index vs time
FLG_AMPERE_integrate_andOMNI_AE_plot_scargle = 0; #plot the scargle of the AMPERE integrated along with OMNI's AE index
FLG_AMPERE_integrate_stacker = 0; #stacks integrated AMPERE across the defined integration area vs time
FLG_AMPERE_integrate_stacker_FFT = 0; #plot FFT of integrated AMPEREacross the defined integration area vs periods
#-----Settings for above plots-----
AMPERE_integrateMethod = 2; #0 for averaging within the defined plot area, 1 for latitudes max is the pole, 2 for a set upper latitude value, 3 for entire hemisphere (all longitudes, 0-90 latitudes)
AMPERE_integrateMethod_val = 75; #degc, latitude value to go up to if AMPERE_integrateMethod==2
AMPERE_integrateMethod_log = 0; #log or don't log the integrated AMPERE data
AMPERE_integrateFFT_filtMethod = 'high-pass'; #options are none, high-pass, low-pass, Sav-Gol
# 'Ped' = Pedersen Conductance [?]
# 'Hall' = Hall Conductance [?]
# 'JH' = Joule Heat [ergs/(cm^2*sec)]
# 'elec poten' = Electric Potential [?]
# 'field-aligned current' = Field-Algined Current [?]
AMPERE_dataType = 'field-aligned current'; #choose a data type from the above list to plot/investigate

locAMPERE_pedersenC = 0; #0 = Pedersen Conductance [?]
locAMPERE_hallC = 1; #1 = Hall Conductance [?]
locAMPERE_jouleHeating = 2; #2 = Joule Heat [ergs/(cm^2*sec)]
locAMPERE_elecPoten = 3; #3 = Electric Potential [?]
locAMPERE_fieldC = 4; #4 = Field-Algined Current [?]
AMPERE_plot_indexes = np.array( (0,1,2,3,4) ); #indexes for AMPERE data to plot up
AMPERE_plot_labels = ['Pedersen Cond. [?]','Hall Cond. [?]','Joule Heating [ergs/(cm$^2$sec)]','Elec. Poten. [?]','Field-Aligned Curr. [?]']; #labels for the indexes above
AMPERE_plot_index = 4; #index for AMPERE data to be plotted - 2 is joule heating
AMPERE_plot_scargle_index = 4; #index for AMPERE data to be scargle'd - 2 is joule heating
AMPERE_integrate_highpassOption = 1; #0 no high-pass, just original data | 1 for just high-passed data
AMPERE_colorMap = ListedColormap( np.hstack(( np.array( ( (np.linspace(1,0.492063492063492,128)),(np.linspace(1,0.507936507936508,128)),(np.linspace(1,1,128)) ) ) , np.array( ( (np.linspace(0.492063492063492,1,128)) , (np.linspace(0.507936507936508,0,128)) , (np.linspace(1,1,128)) ) ) )).T ); #white to purpleblue to pink (based off of 'cool')

settings_AMPERE = {
    'data type':AMPERE_dataType,
    'integrate method':AMPERE_integrateMethod,
    'integrate method lat val':AMPERE_integrateMethod_val,
    'integrate method log':AMPERE_integrateMethod_log,
    'labels':{
        'Ped':'Pederson Cond.',
        'Hall':'Hall Cond.',
        'JH':'Joule Heating',
        'elec poten':'Elec. Poten.',
        'field-aligned current':'Field-Aligned Curr.',
        },
    'units':{
        'Ped':' [?]',
        'Hall':' [?]',
        'JH':' [ergs/(cm$^2$sec)]',
        'elec poten':' [?]',
        'field-aligned current':' [?]',
        },
    'colormap':AMPERE_colorMap,
    };
settings['AMPERE'] = settings_AMPERE; #set these settings

#==============Magnetometer Plotting Options==============
#v import
Mag_delta_method = 'savgol'; #can be None, 0 mean, high-pass, low-pass, Sav-Gol - filters the data before displaying
#v import
FLG_Mag_viewAll_magF = 0; #plots all of the Mag sites on a plot as multiple time series
FLG_Mag_viewAll_magF_FFT = 0; #plots FFT of all of the Mag sites on a plot as multiple time series
FLG_Mag_geoPlot = 0; #plots the geographic locations of the Mag sites

FLG_Mag_keo = 0; #makes a keogram of the magnetometer data (there's only a few sites, so keep the N down)
FLG_Mag_keo_plot = 0; #plots the keogram of the magnetometer data (there's only a few sites, so keep the N down)
#-----Settings for above plots-----
Mag_keo_angle_orig = 90; #deg, user defined angle
Mag_keo_width_orig = 360; #arcdeg, total width - not an angle in this instance
Mag_keo_N = 5; #number of chunks to split the range into  [reg 8]
Mag_keo_polarMode = 0; #0 for regular plotting, 1 for polar plotting of the averaging area
Mag_keo_45vsLatLong = 0; #0 for longitude on xaxis on a 45 degree angle (or multiple of it), 1 for latitude on xaxis
Mag_keo_plotLimVal = [-25,25]; #nT, plot limit values
Mag_keo_plotLimVal = None; #disable plot lim val
#less important settings for plotting
Mag_keo_colorbar = 'jet'; #sets the colorbar used
Mag_keo_normalize = 1; #1 normalizes, 0 doesn't normalize - magnetic field magnitude drops with latitude, normalization keeps it "more comparable" in a way but also not kinda cause it's an absolute number that means things
Mag_keo_setPlotRange = 0; #1 sets plot range manually, 0 automagically figures it out based on the magnetometers in use
Mag_keo_setPlotRange_range = [ [55,85],[-100,-50] ]; #full range is around [ [40,85],[-125,-50] ]
Mag_keo_setStations = 1; #1 sets stations to use, 0 uses all stations
Mag_keo_setStations_names = ['EUA','RES','CBB','IQA','FCC','SNK','STJ','OTT'];#'BLC','BRD','CBB','EUA','FCC','IQA','MEA','OTT','RES','SNK','STJ','VIC','YKC' #names of the magnetometer stations
# Mag_keo_setStations_names = ['VIC','BRD','OTT','STJ']; #get em rollin

settings_Mag = {
    'delta method':Mag_delta_method,
    'keo plot name':'Magnitude of Magnetic Field [nT]', #label for plotting
    'keo angle':Mag_keo_angle_orig, #orig b/c this can be adjusted slightly if 0 or 90
    'keo width orig':Mag_keo_width_orig, #orig b/c this can be adjusted if it's bigger than the averaging area [easy way to guarantee full coverage is to set to 360]
    'keo N':Mag_keo_N, #number of times to split the area the keogram covers
    'keo polar mode':Mag_keo_polarMode,
    'keo 45 lat/long':Mag_keo_45vsLatLong,
    'keo plot lim value':Mag_keo_plotLimVal,
    'keo colorbar':Mag_keo_colorbar,
    'keo normalize':Mag_keo_normalize,
    'keo set plot range':Mag_keo_setPlotRange,
    'keo set plot range range':Mag_keo_setPlotRange_range,
    'keo set stations':Mag_keo_setStations,
    'keo set stations names':Mag_keo_setStations_names
    };
settings['Mag'] = settings_Mag; #set these settings

#==============Machine Learning Options==============
FLG_magicks = 0; #1 for on, 0 for off



#==============Movie Snaps Options==============
#-----0 for off, 1 for on-----
FLG_enable_movieSnaps = 0; #1 for on, 0 for off 
#-----Settings for above plots-----
snaps_type = 1; #see below, the numbering mimics gif_Type's numbering
#1 = stationary data points
#5 = stationary data points + AMPERE data on same plot (no time average for TEC)

snaps_auto = 1; #if 0, uses snaps_Times - otherwise will generate them from snaps_Auto_settings
#MAKE SURE THEY'RE EVEN!
snaps_times = [ 16, 17, 18, 19 ]; #input some times in hrs for when to take snaps - best way is to make a movie, then choose the times

#Otherwise will automatically generate
#snaps_auto_start = -15.25; #hr, time to start
#snaps_auto_start = -13.00; #hr, time to start

#snaps_auto_start = 18; #hr, time to start
#snaps_auto_start = 20.25; #hr, time to start

#snaps_auto_start = 24; #hr, time to start

# snaps_auto_start = 30; #hr, time to start

# snaps_auto_start = 13.50; #hr, time to start

snaps_auto_start = -12; #hr, time to start [-11, 20 min steps, 6 steps is nice too]

snaps_auto_step = 30; #min, time to step
snaps_auto_stepsToTake = 9; #gotta be even, steps to take after the start
#4-8 is a good limit of steps to take.
snaps_dayNiteLine = 2; #0 for no dayNite line, 1 for dayNite line on, 2 for shading of nite time
snaps_dayNiteText = 0; #0 for no dayNite text, 1 for dayNite text on
#for the grid spacing, auto makes the Size variable figure out the spaces, otherwise if auto 0 then the direct Spaces is used
FLG_snaps_grid_spaces_auto = 1; #1 to automatically find it based off of the Lat_Size in degc
#good for east-coast sized / japan
#snaps_Grid_Lat_Size = 0.4; #degc, how long a avg square is in latitude, longitude will be calc'd based on figure size
#good for europe sized
snaps_Grid_Lat_Size = 1; #degc, how long a avg square is in latitude, longitude will be calc'd based on figure size
#good for world
#snaps_Grid_Lat_Spaces = 150; #how many spaces to break the latitude range up into (only for stationary data points)
#snaps_Grid_Long_Spaces = 300; #how many spaces to break the longitude range up into (only for stationary data points)
#below good for smaller zones (Japan)
snaps_Grid_Lat_Spaces = 40; #how many spaces to break the latitude range up into (only for stationary data points)
snaps_Grid_Long_Spaces = 80; #how many spaces to break the longitude range up into (only for stationary data points)

#==============Movie Options==============
#-----0 for off, 1 for on-----
FLG_enable_movieCreation = 0; #1 for on, 0 for off 
#-----Settings for above plots-----
gif_Type = 7; #see below
#0 = moving data points (Fastest, confusing to actually see what up)
#1 = stationary data points
#2 = stationary data points + Zenith ISR overlay on 2nd plot
#3 = stationary data points + MISA ISR overlay on 2nd plot
#4 = stationary data points + AMPERE data on same plot with time average to AMPERE data (every 10 min)
#5 = stationary data points + AMPERE data on same plot (no time average for TEC)
#6 = stationary data points + AMPERE data on same plot (no time average for TEC) + TEC plot with line for current time
#7 = stationary data points + AMPERE data on same plot (no time average for TEC) + 2 TEC plots with line for current time
#8 = stationary data points + OMNI Index of User Choice data on same plot (no time average for TEC)
#9 = stationary data points + AMPERE data on same plot (no time average for TEC) + OMNI Index of User Choice data on 2nd plot (no time average for TEC)
gif_TimeAvg = 6; #min, how many minutes to average into one picture (only used with gif_Type chosen appropriately)
gif_MP4 = 1; #1 for MP4, 0 for gif
gif_dayNiteLine = 2; #0 for no dayNite line, 1 for dayNite line on, 2 for daynite shadowing - no text here so setting irrelevant
gif_dayNiteText = 1; #0 for no dayNite text, 1 for dayNite text on
gif_spin = 0; #0 for no spin and sun moves along perimiter, 1 for spin whole plot with sun always at top of plot
gif_timeLim = 0; #0 for no time limit, 1 for time limit
gif_timeLimRange = np.array([-24,-23]); #hr, hours to limit the movie to
gif_timeDelay = 1; #1 uses time delay for non-direct electron data, 0 ignores the time delay
#good for world
#gif_Grid_Lat_Spaces = 150; #how many spaces to break the latitude range up into (only for stationary data points)
#gif_Grid_Long_Spaces = 300; #how many spaces to break the longitude range up into (only for stationary data points)
#below good for smaller zones (Japan)
#gif_Grid_Lat_Spaces = 80; #how many spaces to break the latitude range up into (only for stationary data points)
#gif_Grid_Long_Spaces = 160; #how many spaces to break the longitude range up into (only for stationary data points)
#ABOVE is depreciated, switched to always square - see gif_Grid_Div now
gif_Grid_Div = 0.75; #number of blocks to divide a 1 deg by 1 deg square into (so 1 would mean a 1x1 block isn't divided, 4 would mean a 1x1 block is divided into 4 parts, and you can actually divide it however you like not just by powers of 4)

gif_ContinentFill = 1; #1 turns on coloring land/water, 0 only does continent outlines
gif_ContientColor = 'xkcd:dusty green'; #sets the land color (if gif_ContinentFill = 1)
gif_ContinentWaterColor = 'xkcd:powder blue'; #sets the water color (if gif_ContinentFill = 1)
gif_Millstone_Marker_Color = 'xkcd:violet'; #sets the color of the Millstone Hill ISR Zenith marker on maps
gif_Millstone_Marker = (8, 2, 0); #sets the marker used to denote the Millstone Hill ISR Zenith marker on maps (8 spokes, asterisk shape, 0 degrees of rotation)

gif_DesiredMaxRunTime = 120; #sec, desired max run time (to keep video limited) - if calc'd over this it will bump from 30 FPS to 60 FPS
gif_FLGdisableFPSShift = 1; #use this to disable the jump to 60 FPS if it makes it go too fast (0 allow 60 FPS jump, 1 disabled)
gif_DesiredFrameTime = 0.35; #sec, desired time between frame for MP4 (how long a frame is on the screen)
gif_Delay = 0.05; #s, time between gif frames
gif_figureSize = np.array((1920, 949)); #pixels, these values make it fit pretty good, as that's a maximized window's size for a 1080p monitor (W x H in pixels)
gif_figurePPI = 100; #pixels per inch, called DPI in matplotlib, figureSize/figurePPI makes it inches which is what matplotlib uses - 100 is what my 1080p monitor did

gif_Save_Locale = settings_config['paths']['plots']; #location of gif (saves in a folder called Plots within the main directory where the code is run)

gif_Name = 'vTEC_movie'; #name of movie to make

gif_Scatter_Point_Size_TEC = 20; #arb. size to make points
gif_Millstone_Marker_Size = 20; #arb. size to make a marker (bigger than the scatter pt size btw)
gif_Scatter_Point_Size_AMPERE = 50; #arb. size to make points

#settings for mapping
settings_map['lat range'] = plotLatRange; #degc; set lat range
settings_map['long range'] = plotLongRange; #degc; set long range
settings_map['world color'] = True; #True turns on coloring land/water; False only does continent outlines
settings_map['land color'] = 'xkcd:dusty green'; #sets the land color (if world color = True)
settings_map['water color'] = 'xkcd:powder blue'; #sets the water color (if world color = True)
settings_map['site marker color'] = 'xkcd:violet'; #sets the color of the marker for the Location Of Interest (usually ISR location) on map
settings_map['site marker type'] = (8, 2, 0); #sets the marker used to denote the ocation Of Interest (usually ISR location) marker on maps (8 spokes; asterisk shape; 0 degrees of rotation)
settings_map['site marker size'] = 20; #sets maker size (bigger than the scatter pt size btw)
settings_map['TEC scatter size'] = 20; #arb. size to make points
settings_map['AMPERE scatter size'] = 50; #arb. size to make points
    

#FOR gif_Type = 6/7 since it has a keogram subplot, this is the range to use:
gif_plotLatRange = [30,50]; #latitude limit for USA
gif_plotLongRange = [-125,-60]; #longitude limit for USA
gif_zoneName = 'USA'; #name it to make it shorter
gif2_plotLatRange = [30,75]; #latitude limit for Europe
gif2_plotLongRange = [-15,40]; #longitude limit for Europe
gif2_zoneName = 'Europe'; #name it to make it shorter
#these must be within the actual plotLatRange and plotLongRange to work
gif_avg_anyAngle_orig = 90; #deg, user defined angle
gif_avg_anyAngle_Width_orig = 360; #arcdeg, total width - not an angle in this instance
gif_avg_anyAngle_N = 200; #number of chunks to split the range into 
gif_avg_anyAngle_polarMode = 0; #0 for regular plotting, 1 for polar plotting of the averaging area
gif_avg_anyAngle_45vsLatLong = 0; #0 for longitude on xaxis on a 45 degree angle (or multiple of it), 1 for latitude on xaxis

#for movie stuff


#!!!END OF SETTINGS!!!
#==============Get Good Time Keeping==============
dateRange_dayNum = subfun_date_to_dayNum(dateRange); #call function to get the date range into dayNumber form (easy to work with)
(dateRange_full, dateRange_dayNum_full) = subfun_dateORdayNum_to_fullRange(dateRange_dayNum); #call fun to get fully enumerated days between range
dateRange_dayNum_zeroHr = dateRange_dayNum_full[np.int16( np.floor((len(dateRange_dayNum_full[:,0]) - 1)/2) ),:]; #choose day for when "0 hr" is - makes plots nice, no day units just hr units
dateRange_zeroHr = dateRange_full[np.int16( np.floor((len(dateRange_dayNum_full[:,0]) - 1)/2) ),:]; #choose day for when "0 hr" is - makes plots nice, no day units just hr units
dateRange_zeroHr_monthName = subfun_monthNum_to_word(dateRange_zeroHr[1])[0]; #get the month name for plotting uses
dateRange_zeroHr_hrOffset = np.int16( np.floor((len(dateRange_dayNum_full[:,0]) - 1)/2) )*24; #put in the hour offset that makes a 0 to 72 hour range into the right -24 to 48 hour range (ALWAYS SUBTRACT)
dateRange_zeroHr_hrBounds = np.array( [-dateRange_zeroHr_hrOffset , dateRange_dayNum_full.shape[0]*24 - dateRange_zeroHr_hrOffset] ); #create hour date range and put zero hour at desired time
dateRange_zeroHr_hrs = np.arange(0,dateRange_dayNum_full.shape[0]*24+24,24) - dateRange_zeroHr_hrOffset; #hr, the hours that split the day wrt the zero hour day
if( (dateRange_zeroHr[2] == 1) | (dateRange_zeroHr[2] == 21) ): #makes a suffix for the day
    dateRange_zeroHr_dayPostfix = 'st'; #appropriate abbrevs for beauty
elif( (dateRange_zeroHr[2] == 2) | (dateRange_zeroHr[2] == 22) ):
    dateRange_zeroHr_dayPostfix = 'nd'; #appropriate abbrevs for beauty
elif( (dateRange_zeroHr[2] == 3) | (dateRange_zeroHr[2] == 33) ):
    dateRange_zeroHr_dayPostfix = 'rd'; #appropriate abbrevs for beauty
else:
    dateRange_zeroHr_dayPostfix = 'th'; #appropriate abbrevs for beauty
#END IF
dateRange_numDays = dateRange_dayNum_full.shape[0]; #get the number of days

time_cutout_range = np.array(time_cutout_range); #convert to numpy array
time_cutout_range_delayed_AMPERE = time_cutout_range + time_cutout_range_delay_AMPERE; #hrs, adjust for a delay with datasets that may have a delay
time_cutout_range_delayed_OMNI = time_cutout_range + time_cutout_range_delay_OMNI; #hrs, adjust for a delay with datasets that may have a delay


#==============Prepare the AMPERE N# based off of the arcdeg requested==============
#if( avg_anyAngle == 0 ): #0 corresponds to longitude slices
#    AMPERE_avg_anyAngle_N = np.int64(np.round((np.max(plotLongRange) - np.min(plotLongRange))/AMPERE_avg_anyAngle_Ndeg)); #set the # of slices to occur based on the arcdeg distance between each slice
#elif( avg_anyAngle == 90 ): #90 corresponds to latitude slices
#    AMPERE_avg_anyAngle_N = np.int64(np.round((np.max(plotLatRange) - np.min(plotLatRange))/AMPERE_avg_anyAngle_Ndeg)); #set the # of slices to occur based on the arcdeg distance between each slice
#else: #otherwise there's an angle involved so give up
AMPERE_avg_anyAngle_N = avg_anyAngle_N; #just use the orig one - it's on an angle and more math is needed
#END IF

#==============Declare TEC Filtered File Layout==============
#Integer Layout
#0 = Satellite ID [# that corresponds to GPS sat]
locInt_sat = 0; #index where sat ID is
#1 = Year timestamp [years]
locInt_year = 1; #index where year timestamp is
#2 = Day Number timestamp [days]
locInt_dayNum = 2; #index where day number timestamp is
#3 = Hour timestamp [hrs]
locInt_hour = 3; #index where hour timestamp is
#4 = Minute timestamp [mins]
locInt_min = 4; #index where minute timestamp is
#5 = Second timestamp [secs]
locInt_sec = 5; #index where second timestamp is
locInt_size = 6; #size of the int variable

#Float Layout
#0 = current time in day format [days] - does not support years
locFloat_time = 0; #index where time in days is
#1 = geodedic latitude [arcdeg]
locFloat_lat = 1; #index where geodedic latitude is
#2 = longitude [arcdeg]
locFloat_long = 2; #index where longitude is
#3 = elevation [deg]
locFloat_elev = 3; #index where elevation is
#4 = delta-TEC "kinda de-biased TEC" [TECU]
locFloat_dTEC = 4; #index where delta-TEC is
#5 = delta-TEC error [TECU]
locFloat_dTECerr = 5; #index where the delta-TEC error is
locFloat_size = 6; #size of float variable

#String Layout
#[] = Receiver Site Name (there's no dim on this one) - use .decode('UTF-8') to make it a string again
locString_site = 0; #index where site name is
locString_size = 1; #size of string layout

#==============Declare Preprepared AMPERE File Layout==============
locAMPERE_pedersenC = 0; #0 = Pedersen Conductance [?]
locAMPERE_hallC = 1; #1 = Hall Conductance [?]
locAMPERE_jouleHeating = 2; #2 = Joule Heat [ergs/(cm^2*sec)]
locAMPERE_elecPoten = 3; #3 = Electric Potential [?]
locAMPERE_fieldC = 4; #4 = Field-Algined Current [?]
locAMPERE_time = 5; #5 = time [days] - does not support years 
locAMPERE_lat = 6; #6 = latitude [arcdeg]
locAMPERE_long = 7; #7 = longitude [arcdeg]

#==============Prepare the ISR plotting for the type of data chosen==============
if( ISR_type == 'SNR' ):
    ISR_type_dataName = 'SNP3'; #data name for SNR is SNP3
elif( ISR_type == 'POPL' ):
    ISR_type_dataName = ['POP','POPL']; #data name for POPL is POPL (I guess it could be POP too - the L seems to indicate log10(POP) )
elif( ISR_type == 'Ne' ):
    ISR_type_dataName = ['NE','NEL']; #data name for Ne is Ne (or NEL if it's the log10(NE) )
#END IF


#==============If doubleKeo is on, make sure the plot lat/long ranges are large enough==============
if( FLG_doubleKeo_plot >= 1 ):
    doubleKeo_latMax = np.max(doubleKeo_latLong[0][0]); #prep
    doubleKeo_latMin = np.min(doubleKeo_latLong[0][0]); #prep
    doubleKeo_longMax = np.max(doubleKeo_latLong[0][1]); #prep
    doubleKeo_longMin = np.min(doubleKeo_latLong[0][1]); #prep
    for i in range(0,len(doubleKeo_latLong)):
        if( np.max(doubleKeo_latLong[i][0]) > doubleKeo_latMax ):
            doubleKeo_latMax = np.max(doubleKeo_latLong[i][0]); #update
        #END IF
        if( np.min(doubleKeo_latLong[i][0]) < doubleKeo_latMin ):
            doubleKeo_latMin = np.min(doubleKeo_latLong[i][0]); #update
        #END IF
        if( np.max(doubleKeo_latLong[i][1]) > doubleKeo_longMax ):
            doubleKeo_longMax = np.max(doubleKeo_latLong[i][1]); #update
        #END IF
        if( np.min(doubleKeo_latLong[i][1]) < doubleKeo_longMin ):
            doubleKeo_longMin = np.min(doubleKeo_latLong[i][1]); #update
        #END IF
    #END FOR i
    if( doubleKeo_latMax > np.max(plotLatRange) ):
        print('WARNING: Plot lat range maximum of '+str(np.max(plotLatRange))+' degc is less than the double keo required max lat of '+str(doubleKeo_latMax)+' degc. Increasing plotLatRange max to match.');
        plotLatRange[np.where(plotLatRange == np.max(plotLatRange))[0].item()] = doubleKeo_latMax; #increase the plot range accordingly
    #END IF
    if( doubleKeo_latMin < np.min(plotLatRange) ):
        print('WARNING: Plot lat range minumum of '+str(np.min(plotLatRange))+' degc is less than the double keo required min lat of '+str(doubleKeo_latMin)+'. Increasing plotLatRange min to match.');
        plotLatRange[np.where(plotLatRange == np.min(plotLatRange))[0].item()] = doubleKeo_latMin; #increase the plot range accordingly
    #END IF
    if( doubleKeo_longMax > np.max(plotLongRange) ):
        print('WARNING: Plot long range maximum of '+str(np.max(plotLongRange))+' degc is less than the double keo required max long of '+str(doubleKeo_longMax)+'. Increasing plotLongRange max to match.');
        plotLongRange[np.where(plotLongRange == np.max(plotLongRange))[0].item()] = doubleKeo_longMax; #increase the plot range accordingly
    #END IF
    if( doubleKeo_longMin < np.min(plotLongRange) ):
        print('WARNING: Plot long range minumum of '+str(np.min(plotLongRange))+' degc is less than the double keo required min long of '+str(doubleKeo_longMin)+'. Increasing plotLongRange min to match.');
        plotLongRange[np.where(plotLongRange == np.min(plotLongRange))[0].item()] = doubleKeo_longMin; #increase the plot range accordingly
    #END IF
    
    #Verify if mode 2 is possible
    if( FLG_doubleKeo_plot == 2 ):
        if( np.any(np.array(doubleKeo_angle_orig) == 90) | np.any(np.array(doubleKeo_angle_orig) == 0) ): #only works on 0 or 90 degrees
            if( np.all(np.array(doubleKeo_angle_orig) == doubleKeo_angle_orig[0]) == True ): #the angles have to be the same as well
                doubleKeo_latLongComb = np.empty( (len(doubleKeo_latLong),2) );
                for i in range(0,len(doubleKeo_latLong)):
                    doubleKeo_latLongComb[i,:] = doubleKeo_latLong[i][0]; #pull it out
                #END FOR i
                doubleKeo_latLongComb = np.sort(doubleKeo_latLongComb,axis=1);
                uniques, indxs, cnts = np.unique(doubleKeo_latLongComb.flatten(), return_index=True,return_counts=True);
                if( (len(doubleKeo_latLong)-1 == np.sum(cnts == 2)) & np.all(cnts[1:-1] == 2) ):
                    doubleKeo_alignments = uniques[1:-1]; #places where the lines of separation need to be drawn
                else:
                    print('WARNING: doubleKeo is set to mode 2, but the keogram [latitude or longitudes] don\'t match up. Reverting to mode 1.');
                    FLG_doubleKeo_plot = 1; #set the flag to mode 1
                #END IF
            else:
                print('WARNING: doubleKeo is set to mode 2, but keogram angles do not match. Reverting to mode 1.');
                FLG_doubleKeo_plot = 1; #set the flag to mode 1
            #END IF
        else:
            print('WARNING: doubleKeo is set to mode 2, but keogram angles must be 0 or 90 to make mode 2 work. Reverting to mode 1.');
            FLG_doubleKeo_plot = 1; #set the flag to mode 1
        #END IF
    #END IF
#END IF
if( FLG_doubleKeo_TECnMag == 1 ):
    doubleKeo_latMax = np.max(doubleKeo_TECnMag_TEC_latLong[0]); #prep
    doubleKeo_latMin = np.min(doubleKeo_TECnMag_TEC_latLong[0]); #prep
    doubleKeo_longMax = np.max(doubleKeo_TECnMag_TEC_latLong[1]); #prep
    doubleKeo_longMin = np.min(doubleKeo_TECnMag_TEC_latLong[1]); #prep
    if( doubleKeo_latMax > np.max(plotLatRange) ):
        print('WARNING: Plot lat range maximum of '+str(np.max(plotLatRange))+' degc is less than the double keo required max lat of '+str(doubleKeo_latMax)+' degc. Increasing plotLatRange max to match.');
        plotLatRange[np.where(plotLatRange == np.max(plotLatRange))[0].item()] = doubleKeo_latMax; #increase the plot range accordingly
    #END IF
    if( doubleKeo_latMin < np.min(plotLatRange) ):
        print('WARNING: Plot lat range minumum of '+str(np.min(plotLatRange))+' degc is less than the double keo required min lat of '+str(doubleKeo_latMin)+'. Increasing plotLatRange min to match.');
        plotLatRange[np.where(plotLatRange == np.min(plotLatRange))[0].item()] = doubleKeo_latMin; #increase the plot range accordingly
    #END IF
    if( doubleKeo_longMax > np.max(plotLongRange) ):
        print('WARNING: Plot long range maximum of '+str(np.max(plotLongRange))+' degc is less than the double keo required max long of '+str(doubleKeo_longMax)+'. Increasing plotLongRange max to match.');
        plotLongRange[np.where(plotLongRange == np.max(plotLongRange))[0].item()] = doubleKeo_longMax; #increase the plot range accordingly
    #END IF
    if( doubleKeo_longMin < np.min(plotLongRange) ):
        print('WARNING: Plot long range minumum of '+str(np.min(plotLongRange))+' degc is less than the double keo required min long of '+str(doubleKeo_longMin)+'. Increasing plotLongRange min to match.');
        plotLongRange[np.where(plotLongRange == np.min(plotLongRange))[0].item()] = doubleKeo_longMin; #increase the plot range accordingly
    #END IF
#END IF

#==============Figure out what data types are needed==============
FLG_dataTypes = np.zeros(len(dataTypes),dtype=np.int8); #prime the needed flag (supports all data types)
FLG_TECloc = dataTypes.index("TEC"); #get the index for TEC
FLG_ISRloc = dataTypes.index("ISR"); #get the index for ISR
FLG_AMPEREloc = dataTypes.index("AMPERE"); #get the index for AMPERE
FLG_Kploc = dataTypes.index("Kp"); #get the index for K[]
FLG_OMNIloc = dataTypes.index("OMNI"); #get the index for OMNI
FLG_Magloc = dataTypes.index("Mag"); #get the index for Mag
#-----NOW CHOOSE WHICH DATA TYPES TO USE-----
#~~~PREDOMINANTLY TEC STUFF~~~
if( FLG_avg_anyAngle == 1 ):
    #TURN ON TEC
    FLG_dataTypes[FLG_TECloc] = 1; #turn on flag for getting TEC data
#END IF
if( FLG_avg_anyAngle_plot == 1 ):
    FLG_avg_anyAngle = 1; #this is required for above to work
    FLG_dataTypes[FLG_TECloc] = 1; #turn on flag for getting TEC data
#END IF
if( FLG_avg_anyAngle_plot_timeCutout == 1 ):
    FLG_avg_anyAngle = 1; #this is required for above to work
    FLG_dataTypes[FLG_TECloc] = 1; #turn on flag for getting TEC data
#END IF
if( FLG_TEC_keo_dataDensity == 1 ):
    FLG_avg_anyAngle = 1; #this is required for above to work
    FLG_dataTypes[FLG_TECloc] = 1; #turn on flag for getting TEC data
#END IF
if( FLG_avg_anyAngle_plot_wNoise == 1 ):
    FLG_avg_anyAngle = 1; #this is required for above to work
    FLG_dataTypes[FLG_TECloc] = 1; #turn on flag for getting TEC data
#END IF
if( FLG_avg_anyAngle_plot_noiseAllViews == 1 ):
    #TURN ON TEC
    FLG_dataTypes[FLG_TECloc] = 1; #turn on flag for getting TEC data
#END IF
if( FLG_combinedPlot_keo_TEC_n_AMPERE_1Dintegration == 1 ):
    FLG_avg_anyAngle = 1; #avg any angle is needed for this
    FLG_dataTypes[FLG_TECloc] = 1; #turn on flag for getting TEC data
    FLG_dataTypes[FLG_AMPEREloc] = 1; #turn on flag for getting AMPERE data
#END IF
if( FLG_combinedPlot_keo_TEC_n_AMPERE_1Dintegration_auroralZone == 1 ):
    FLG_avg_anyAngle = 1; #avg any angle is needed for this
    FLG_dataTypes[FLG_TECloc] = 1; #turn on flag for getting TEC data
    FLG_dataTypes[FLG_AMPEREloc] = 1; #turn on flag for getting AMPERE data
#END IF
if( (FLG_combinedPlot_keo_TEC_n_AMPERE_1Dintegration_auroralZone_spectra == 1) | (FLG_combinedPlot_keo_TEC_n_AMPERE_1Dintegration_auroralZone_spectra_timeMatch == 1) ):
    FLG_avg_anyAngle = 1; #avg any angle is needed for this
    FLG_dataTypes[FLG_TECloc] = 1; #turn on flag for getting TEC data
    FLG_dataTypes[FLG_AMPEREloc] = 1; #turn on flag for getting AMPERE data
#END IF
if( FLG_keo_stacker == 1 ):
    FLG_avg_anyAngle = 1; #avg any angle is needed for this
    FLG_dataTypes[FLG_TECloc] = 1; #turn on flag for getting TEC data
#END IF
if( FLG_keo_stackerPlot == 1 ):
    FLG_avg_anyAngle = 1; #avg any angle is needed for this
    FLG_keo_stacker = 1; #need the stacker to plot the stack result
    FLG_dataTypes[FLG_TECloc] = 1; #turn on flag for getting TEC data
#END IF
if( FLG_doubleKeo >= 1 ):
    FLG_dataTypes[FLG_TECloc] = 1; #turn on flag for getting TEC data
    FLG_dataTypes[FLG_AMPEREloc] = 1; #turn on flag for getting AMPERE data
#END IF
if( FLG_doubleKeo_plot >= 1 ):
    FLG_doubleKeo = 1; #needs double keo, make sure it on
    FLG_dataTypes[FLG_TECloc] = 1; #turn on flag for getting TEC data
    FLG_dataTypes[FLG_AMPEREloc] = 1; #turn on flag for getting AMPERE data
#END IF
if( FLG_doubleKeo_plot_timeCutout >= 1 ):
    FLG_doubleKeo = 1; #needs double keo, make sure it on
    FLG_dataTypes[FLG_TECloc] = 1; #turn on flag for getting TEC data
    FLG_dataTypes[FLG_AMPEREloc] = 1; #turn on flag for getting AMPERE data
#END IF
if( FLG_doubleKeo_xcorr == 1 ):
    FLG_doubleKeo = 1; #needs double keo, make sure it on
    FLG_dataTypes[FLG_TECloc] = 1; #turn on flag for getting TEC data
    FLG_dataTypes[FLG_AMPEREloc] = 1; #turn on flag for getting AMPERE data
#END IF
if( FLG_doubleKeo_TECnMag == 1 ):
    FLG_dataTypes[FLG_TECloc] = 1; #turn on flag for getting TEC data
    FLG_dataTypes[FLG_Magloc] = 1; #turn on flag for getting Magnetometer data
#END IF
if( FLG_activityIndex == 1):
    #TURN ON TEC
    FLG_dataTypes[FLG_TECloc] = 1; #turn on flag for getting TEC data
    FLG_dataTypes[FLG_AMPEREloc] = 1; #turn on flag for getting AMPERE data
#END IF
if( FLG_avgPt == 1 ):
    #TURN ON TEC
    FLG_dataTypes[FLG_TECloc] = 1; #turn on flag for getting TEC data
#END IF
if( FLG_avgPt_timeMatch == 1 ):
    FLG_avgPt = 1; #this reqs avg pt
    #TURN ON TEC
    FLG_dataTypes[FLG_TECloc] = 1; #turn on flag for getting TEC data
    FLG_dataTypes[FLG_ISRloc] = 1; #turn on flag for getting ISR data
#END IF
if( FLG_avgPt_HP_timeMatch_plotWithISR_cutOut == 1 ):
    FLG_avgPt = 1; #this reqs avg pt
    FLG_avgPt_timeMatch = 1; #this reqs avg pt time match
    #TURN ON TEC
    FLG_dataTypes[FLG_TECloc] = 1; #turn on flag for getting TEC data
    FLG_dataTypes[FLG_ISRloc] = 1; #turn on flag for getting ISR data
#END IF
if( FLG_avgPt_HP_timeMatch_POPL_plotWithISR_cutOut == 1 ):
    FLG_avgPt = 1; #this reqs avg pt
    FLG_avgPt_timeMatch = 1; #this reqs avg pt time match
    #TURN ON TEC
    FLG_dataTypes[FLG_TECloc] = 1; #turn on flag for getting TEC data
    FLG_dataTypes[FLG_ISRloc] = 1; #turn on flag for getting ISR data
#END IF
if( FLG_avgPt_HP_timeMatch_plotWithISR_ZenithOnly_cutOut == 1 ):
    FLG_avgPt = 1; #this reqs avg pt
    FLG_avgPt_timeMatch = 1; #this reqs avg pt time match
    #TURN ON TEC
    FLG_dataTypes[FLG_TECloc] = 1; #turn on flag for getting TEC data
    FLG_dataTypes[FLG_ISRloc] = 1; #turn on flag for getting ISR data
#END IF
if( FLG_avgPt_HP_timeMatch_POPL_plotWithISR_ZenithOnly_cutOut == 1 ):
    FLG_avgPt = 1; #this reqs avg pt
    FLG_avgPt_timeMatch = 1; #this reqs avg pt time match
    #TURN ON TEC
    FLG_dataTypes[FLG_TECloc] = 1; #turn on flag for getting TEC data
    FLG_dataTypes[FLG_ISRloc] = 1; #turn on flag for getting ISR data
#END IF
if( FLG_avgPt_HP_timeMatch_scargleWithISR_cutOut == 1 ):
    FLG_avgPt = 1; #this reqs avg pt
    FLG_avgPt_timeMatch = 1; #this reqs avg pt time match
    #TURN ON TEC
    FLG_dataTypes[FLG_TECloc] = 1; #turn on flag for getting TEC data
    FLG_dataTypes[FLG_ISRloc] = 1; #turn on flag for getting ISR data
#END IF
if( FLG_avgPt_HP_timeMatch_POPL_scargleWithISR_cutOut == 1 ):
    FLG_avgPt = 1; #this reqs avg pt
    FLG_avgPt_timeMatch = 1; #this reqs avg pt time match
    #TURN ON TEC
    FLG_dataTypes[FLG_TECloc] = 1; #turn on flag for getting TEC data
    FLG_dataTypes[FLG_ISRloc] = 1; #turn on flag for getting ISR data
#END IF
if( FLG_avgPt_HP_timeMatch_POPLnOMNI_scargleORfft_cutOut == 1 ):
    FLG_avgPt = 1; #this reqs avg pt
    FLG_avgPt_timeMatch = 1; #this reqs avg pt time match
    #TURN ON TEC
    FLG_dataTypes[FLG_TECloc] = 1; #turn on flag for getting TEC data
    FLG_dataTypes[FLG_ISRloc] = 1; #turn on flag for getting ISR data
    FLG_dataTypes[FLG_OMNIloc] = 1; #turn on flag for getting OMNI data
#END IF
if( FLG_avgPt_HP_timeMatch_POPL_CPSD_cutOut == 1 ):
    FLG_avgPt = 1; #this reqs avg pt
    FLG_avgPt_timeMatch = 1; #this reqs avg pt time match
    #TURN ON TEC
    FLG_dataTypes[FLG_TECloc] = 1; #turn on flag for getting TEC data
    FLG_dataTypes[FLG_ISRloc] = 1; #turn on flag for getting ISR data
#END IF
if( FLG_avgPt_HP_timeMatch_POPLnTECNOISE_CPSD_cutOut == 1 ):
    FLG_avgPt = 1; #this reqs avg pt
    FLG_avgPt_timeMatch = 1; #this reqs avg pt time match
    #TURN ON TEC
    FLG_dataTypes[FLG_TECloc] = 1; #turn on flag for getting TEC data
    FLG_dataTypes[FLG_ISRloc] = 1; #turn on flag for getting ISR data
#END IF
if( FLG_avgPt_HP_timeMatch_POPLnTECNOISE_FFT_cutOut == 1 ):
    FLG_avgPt = 1; #this reqs avg pt
    FLG_avgPt_timeMatch = 1; #this reqs avg pt time match
    #TURN ON TEC
    FLG_dataTypes[FLG_TECloc] = 1; #turn on flag for getting TEC data
    FLG_dataTypes[FLG_ISRloc] = 1; #turn on flag for getting ISR data
#END IF
if( FLG_avgPt_HP_timeMatch_POPLnOMNI_CPSD_cutOut == 1 ):
    FLG_avgPt = 1; #this reqs avg pt
    FLG_avgPt_timeMatch = 1; #this reqs avg pt time match
    #TURN ON TEC
    FLG_dataTypes[FLG_TECloc] = 1; #turn on flag for getting TEC data
    FLG_dataTypes[FLG_ISRloc] = 1; #turn on flag for getting ISR data
    FLG_dataTypes[FLG_OMNIloc] = 1; #turn on flag for getting OMNI data
#END IF
if( FLG_avgPt_HP_timeMatch_POPLnOMNI_FFT_cutOut == 1 ):
    FLG_avgPt = 1; #this reqs avg pt
    FLG_avgPt_timeMatch = 1; #this reqs avg pt time match
    #TURN ON TEC
    FLG_dataTypes[FLG_TECloc] = 1; #turn on flag for getting TEC data
    FLG_dataTypes[FLG_ISRloc] = 1; #turn on flag for getting ISR data
    FLG_dataTypes[FLG_OMNIloc] = 1; #turn on flag for getting OMNI data
#END IF
if( FLG_avgPt_HP_timeMatch_POPLnOMNInTECNOISE_CPSD_cutOut == 1 ):
    FLG_avgPt = 1; #this reqs avg pt
    FLG_avgPt_timeMatch = 1; #this reqs avg pt time match
    #TURN ON TEC
    FLG_dataTypes[FLG_TECloc] = 1; #turn on flag for getting TEC data
    FLG_dataTypes[FLG_ISRloc] = 1; #turn on flag for getting ISR data
    FLG_dataTypes[FLG_OMNIloc] = 1; #turn on flag for getting OMNI data
#END IF
if( FLG_avgPt_HP_timeMatch_POPLnOMNInTECNOISE_FFT_cutOut == 1 ):
    FLG_avgPt = 1; #this reqs avg pt
    FLG_avgPt_timeMatch = 1; #this reqs avg pt time match
    #TURN ON TEC
    FLG_dataTypes[FLG_TECloc] = 1; #turn on flag for getting TEC data
    FLG_dataTypes[FLG_ISRloc] = 1; #turn on flag for getting ISR data
    FLG_dataTypes[FLG_OMNIloc] = 1; #turn on flag for getting OMNI data
#END IF
if( FLG_avgPt_HP_timeMatch_POPLnAMPERE_plotWithISR_ZenithOnly_cutOut == 1 ):
    FLG_avgPt = 1; #this reqs avg pt
    FLG_avgPt_timeMatch = 1; #this reqs avg pt time match
    #TURN ON TEC
    FLG_dataTypes[FLG_TECloc] = 1; #turn on flag for getting TEC data
    FLG_dataTypes[FLG_ISRloc] = 1; #turn on flag for getting ISR data
    FLG_dataTypes[FLG_AMPEREloc] = 1; #turn on flag for getting AMPERE data
#END IF
if( FLG_avgPt_HP_timeMatch_POPLnAMPERE_FFT_cutOut == 1 ):
    FLG_avgPt = 1; #this reqs avg pt
    FLG_avgPt_timeMatch = 1; #this reqs avg pt time match
    #TURN ON TEC
    FLG_dataTypes[FLG_TECloc] = 1; #turn on flag for getting TEC data
    FLG_dataTypes[FLG_ISRloc] = 1; #turn on flag for getting ISR data
    FLG_dataTypes[FLG_AMPEREloc] = 1; #turn on flag for getting AMPERE data
#END IF
if( FLG_avgPt_HP_timeMatch_FFTthruTime_POPLnOMNI == 1 ):
    FLG_avgPt = 1; #this reqs avg pt
    FLG_avgPt_timeMatch = 1; #this reqs avg pt time match
    #TURN ON TEC
    FLG_dataTypes[FLG_TECloc] = 1; #turn on flag for getting TEC data
    FLG_dataTypes[FLG_ISRloc] = 1; #turn on flag for getting ISR data
    FLG_dataTypes[FLG_OMNIloc] = 1; #turn on flag for getting OMNI data
#END IF
if( FLG_FFTthruTime_KEOnAvgPtnAMPEREintegrated == 1 ):
    FLG_avg_anyAngle = 1; #this reqs keo
    FLG_avgPt = 1; #this reqs avg pt
    FLG_avgPt_timeMatch = 0; #cannot time match as it is set up now
    #TURN ON TEC
    FLG_dataTypes[FLG_TECloc] = 1; #turn on flag for getting TEC data
    FLG_dataTypes[FLG_AMPEREloc] = 1; #turn on flag for getting AMPERE data
#END IF
if( FLG_FFTthruTime_KEOnAMPEREnOMNIintegrated == 1 ):
    FLG_avg_anyAngle = 1; #this reqs keo
    # FLG_avgPt = 1; #this reqs avg pt
    # FLG_avgPt_timeMatch = 0; #cannot time match as it is set up now
    #TURN ON TEC
    FLG_dataTypes[FLG_TECloc] = 1; #turn on flag for getting TEC data
    FLG_dataTypes[FLG_AMPEREloc] = 1; #turn on flag for getting AMPERE data
    FLG_dataTypes[FLG_OMNIloc] = 1; #turn on flag for getting OMNI data
#END IF
if( FLG_FFTthruTime_KEOnOMNIintegrated == 1 ):
    FLG_avg_anyAngle = 1; #this reqs keo
    # FLG_avgPt = 1; #this reqs avg pt
    # FLG_avgPt_timeMatch = 0; #cannot time match as it is set up now
    #TURN ON TEC
    FLG_dataTypes[FLG_TECloc] = 1; #turn on flag for getting TEC data
    FLG_dataTypes[FLG_OMNIloc] = 1; #turn on flag for getting OMNI data
#END IF
if( FLG_magicks == 1 ):
    #TURN ON TEC
    FLG_dataTypes[FLG_TECloc] = 1; #turn on flag for getting TEC data
    FLG_dataTypes[FLG_AMPEREloc] = 1; #turn on flag for getting AMPERE data
#END IF
if( (FLG_enable_movieSnaps == 1) ): #movieSnaps shares the same data reqs as movieCreation
    #TURN ON TEC
    FLG_dataTypes[FLG_TECloc] = 1; #turn on flag for getting TEC data
    #CHECK IF OTHER DATA TYPES ARE INVOLVED TOO
    if( (snaps_type == 2) | (snaps_type == 3) ):
        FLG_dataTypes[FLG_ISRloc] = 1; #turn on flag for getting ISR data
    if( (snaps_type == 4) | (snaps_type == 5) ):
        FLG_dataTypes[FLG_AMPEREloc] = 1; #turn on flag for getting AMPERE data
    #END IF
    if( (snaps_type == 6) ):
        FLG_dataTypes[FLG_OMNIloc] = 1; #turn on flag for getting OMNI data
    #END IF
    if( (snaps_type == 7) ):
        FLG_dataTypes[FLG_OMNIloc] = 1; #turn on flag for getting OMNI data
        FLG_dataTypes[FLG_AMPEREloc] = 1; #turn on flag for getting AMPERE data
    #END IF
#END IF
if( (FLG_enable_movieCreation == 1) ): #movieSnaps shares the same data reqs as movieCreation
    #TURN ON TEC
    FLG_dataTypes[FLG_TECloc] = 1; #turn on flag for getting TEC data
    #CHECK IF OTHER DATA TYPES ARE INVOLVED TOO
    if( (gif_Type == 2) | (gif_Type == 3) ):
        FLG_dataTypes[FLG_ISRloc] = 1; #turn on flag for getting ISR data
    if( (gif_Type == 4) | (gif_Type == 5)| (gif_Type == 6)| (gif_Type == 7) ):
        FLG_dataTypes[FLG_AMPEREloc] = 1; #turn on flag for getting AMPERE data
    #END IF
    if( (gif_Type == 8) ):
        FLG_dataTypes[FLG_OMNIloc] = 1; #turn on flag for getting OMNI data
    #END IF
    if( (gif_Type == 9) ):
        FLG_dataTypes[FLG_OMNIloc] = 1; #turn on flag for getting OMNI data
        FLG_dataTypes[FLG_AMPEREloc] = 1; #turn on flag for getting AMPERE data
    #END IF
#END IF
    
#~~~PREDOMINANTLY ISR STUFF~~~
if( FLG_ISR_data == 1 ):
    #TURN ON ISR
    FLG_dataTypes[FLG_ISRloc] = 1; #turn on flag for getting ISR data
#END IF
if( FLG_ISR_plot_POPL_HP == 1 ):
    #TURN ON ISR
    FLG_dataTypes[FLG_ISRloc] = 1; #turn on flag for getting ISR data
#END IF 
if( FLG_ISR_plot_POPL_HP_cutOut == 1 ):
    #TURN ON ISR
    FLG_dataTypes[FLG_ISRloc] = 1; #turn on flag for getting ISR data
#END IF
if( FLG_ISR_plot_POPL == 1 ):
    #TURN ON ISR
    FLG_dataTypes[FLG_ISRloc] = 1; #turn on flag for getting ISR data
#END IF
if( FLG_ISR_plot_POPL_limited == 1 ):
    #TURN ON ISR
    FLG_dataTypes[FLG_ISRloc] = 1; #turn on flag for getting ISR data
#END IF  
if( FLG_ISR_plot_POPL_ScargleSet == 1 ):
    #TURN ON ISR
    FLG_dataTypes[FLG_ISRloc] = 1; #turn on flag for getting ISR data
#END IF  
if( FLG_ISR_plot_POPL_FFTSet == 1 ):
    #TURN ON ISR
    FLG_dataTypes[FLG_ISRloc] = 1; #turn on flag for getting ISR data
#END IF  
if( FLG_ISR_plot_SNR_HP == 1 ):
    #TURN ON ISR
    FLG_dataTypes[FLG_ISRloc] = 1; #turn on flag for getting ISR data
#END IF
if( FLG_ISR_plot_SNR == 1 ):
    #TURN ON ISR
    FLG_dataTypes[FLG_ISRloc] = 1; #turn on flag for getting ISR data
#END IF
if( FLG_ISR_plot_SNR_limited == 1 ):
    #TURN ON ISR
    FLG_dataTypes[FLG_ISRloc] = 1; #turn on flag for getting ISR data
#END IF  
if( FLG_ISR_plot_ScargleSet == 1 ):
    #TURN ON ISR
    FLG_dataTypes[FLG_ISRloc] = 1; #turn on flag for getting ISR data
#END IF  
if( FLG_ISR_plot_ionVel == 1 ):
    #TURN ON ISR
    FLG_dataTypes[FLG_ISRloc] = 1; #turn on flag for getting ISR data
#END IF  
if( FLG_ISR_plot_ionVel_cutOut == 1 ): 
    #TURN ON ISR
    FLG_dataTypes[FLG_ISRloc] = 1; #turn on flag for getting ISR data
#END IF
if( FLG_ISR_plot_ionVel_hp == 1 ):
    #TURN ON ISR
    FLG_dataTypes[FLG_ISRloc] = 1; #turn on flag for getting ISR data
#END IF 
if( FLG_ISR_plot_ionVel_hp_cutOut == 1 ):
    #TURN ON ISR
    FLG_dataTypes[FLG_ISRloc] = 1; #turn on flag for getting ISR data
#END IF
    
#~~~PREDOMINANTLY Kp STUFF~~~
if( FLG_Kp_plot == 1 ):
    #TURN ON Kp
    FLG_dataTypes[FLG_Kploc] = 1; #turn on flag for getting Kp data
#END IF
#~~~PREDOMINANTLY OMNI STUFF~~~
if( FLG_OMNI_plot == 1 ):
    #TURN ON OMNI
    FLG_dataTypes[FLG_OMNIloc] = 1; #turn on flag for getting OMNI data
#END IF
if( FLG_OMNI_plot_scargle == 1 ):
    #TURN ON OMNI
    FLG_dataTypes[FLG_OMNIloc] = 1; #turn on flag for getting OMNI data
#END IF
if( FLG_OMNI_plot_FFT == 1 ):
    #TURN ON OMNI
    FLG_dataTypes[FLG_OMNIloc] = 1; #turn on flag for getting OMNI data
#END IF
if( FLG_OMNI_stacker == 1 ):
    #TURN ON OMNI
    FLG_dataTypes[FLG_OMNIloc] = 1; #turn on flag for getting OMNI data
#END IF
if( FLG_OMNI_stacker_FFT == 1 ):
    #TURN ON OMNI
    FLG_dataTypes[FLG_OMNIloc] = 1; #turn on flag for getting OMNI data
#END IF
#~~~PREDOMINATELY AMPERE STUFF~~~
if( FLG_AMPERE_avg_anyAngle == 1 ):
    #TURN ON TEC
    FLG_dataTypes[FLG_AMPEREloc] = 1; #turn on the flag for getting AMPERE data
#END IF
if( FLG_AMPERE_avg_anyAngle_plot == 1):
    FLG_AMPERE_avg_anyAngle = 1; #turn this on, it's req
    FLG_dataTypes[FLG_AMPEREloc] = 1; #turn on the flag for getting AMPERE data
#END IF
if( FLG_AMPERE_avg_anyAngle_plot_timeCutout == 1):
    FLG_AMPERE_avg_anyAngle = 1; #turn this on, it's req
    FLG_dataTypes[FLG_AMPEREloc] = 1; #turn on the flag for getting AMPERE data
#END IF
if( FLG_AMPERE_keo_spectra == 1):
    FLG_AMPERE_avg_anyAngle = 1; #turn this on, it's req
    FLG_dataTypes[FLG_AMPEREloc] = 1; #turn on the flag for getting AMPERE data
#END IF
if( FLG_AMPERE_keo_plot_wSun == 1 ):
    FLG_AMPERE_avg_anyAngle = 1; #turn this on, it's req
    FLG_dataTypes[FLG_AMPEREloc] = 1; #turn on the flag for getting AMPERE data
#END IF
if( FLG_AMPERE_keo_plot_wSunCenter == 1 ):
    FLG_AMPERE_avg_anyAngle = 1; #turn this on, it's req
    FLG_dataTypes[FLG_AMPEREloc] = 1; #turn on the flag for getting AMPERE data
#END IF
if( FLG_AMPERE_keo_spectra_wSunCenter == 1 ):
    FLG_AMPERE_avg_anyAngle = 1; #turn this on, it's req
    FLG_AMPERE_keo_plot_wSunCenter = 1; #turn this on, it's req
    FLG_dataTypes[FLG_AMPEREloc] = 1; #turn on the flag for getting AMPERE data
#END IF
if( FLG_AMPERE_integrate_plot == 1 ):
    #TURN ON AMPERE
    FLG_dataTypes[FLG_AMPEREloc] = 1; #turn on the flag for getting AMPERE data
#END IF
if( FLG_AMPERE_integrate_FFT == 1 ):
    #TURN ON AMPERE
    FLG_dataTypes[FLG_AMPEREloc]   = 1; #turn on the flag for getting AMPERE data
#END IF
if( FLG_AMPERE_integrate_scargle == 1 ):
    #TURN ON AMPERE
    FLG_dataTypes[FLG_AMPEREloc]   = 1; #turn on the flag for getting AMPERE data
#END IF
if( FLG_AMPERE_integrate_limArea_plot == 1 ):
    #TURN ON AMPERE
    FLG_dataTypes[FLG_AMPEREloc] = 1; #turn on the flag for getting AMPERE data
#END IF
if( FLG_AMPERE_integrate_limArea_scargle == 1 ):
    #TURN ON AMPERE
    FLG_dataTypes[FLG_AMPEREloc] = 1; #turn on the flag for getting AMPERE data
#END IF
if( FLG_AMPERE_integrate_stacker == 1 ):
    #TURN ON AMPERE
    FLG_dataTypes[FLG_AMPEREloc] = 1; #turn on the flag for getting AMPERE data
#END IF
if( FLG_AMPERE_integrate_stacker_FFT == 1 ):
    FLG_AMPERE_integrate_stacker = 1; #need integrator to run
    #TURN ON AMPERE
    FLG_dataTypes[FLG_AMPEREloc] = 1; #turn on the flag for getting AMPERE data
#END IF
if( FLG_AMPERE_integrate_andOMNI_AE_plot == 1 ):
    #TURN ON AMPERE
    FLG_dataTypes[FLG_AMPEREloc] = 1; #turn on the flag for getting AMPERE data
    #TURN ON OMNI
    FLG_dataTypes[FLG_OMNIloc] = 1; #turn on flag for getting OMNI data
#END IF
if( FLG_AMPERE_integrate_andOMNI_AE_plot_scargle == 1 ):
    #TURN ON AMPERE
    FLG_dataTypes[FLG_AMPEREloc] = 1; #turn on the flag for getting AMPERE data
    #TURN ON OMNI
    FLG_dataTypes[FLG_OMNIloc] = 1; #turn on flag for getting OMNI data
#END IF
#~~~PREDOMINATELY MAG STUFF~~~
if( FLG_Mag_viewAll_magF == 1 ):
    #TURN ON Mag
    FLG_dataTypes[FLG_Magloc] = 1; #turn on the flag for getting Mag data
#END IF
if( FLG_Mag_viewAll_magF_FFT == 1 ):
    #TURN ON Mag
    FLG_dataTypes[FLG_Magloc] = 1; #turn on the flag for getting Mag data
#END IF
if( FLG_Mag_geoPlot == 1 ):
    #TURN ON Mag
    FLG_dataTypes[FLG_Magloc] = 1; #turn on the flag for getting Mag data
#END IF
if( FLG_Mag_keo == 1 ):
    #TURN ON Mag
    FLG_dataTypes[FLG_Magloc] = 1; #turn on the flag for getting Mag data
#END IF
if( FLG_Mag_keo_plot== 1 ):
    FLG_Mag_keo = 1; #keo req for the plot, make sure it's on
    #TURN ON Mag
    FLG_dataTypes[FLG_Magloc] = 1; #turn on the flag for getting Mag data
#END IF

data = {}; #prep data holder

#-----Deal with time reference issues----- 
#Support for TEC time reference  
if( (time_Reference == 'TEC') & (FLG_dataTypes[FLG_TECloc] == 0) ):
    print("WARNING: Time reference chosen was >"+time_Reference+"< but no TEC data is being imported for analysis. Switching to next avail time reference. Printing currently activated instruments:"); #print warning if time refernece won't exist
    for i in range(0,len(dataTypes)):
        print(dataTypes[i]+"\t"+str(FLG_dataTypes[i])); #report the data type and if it is on or not
    #END FOR i
    if( np.sum(FLG_dataTypes) != 0 ): #make sure at least one data type is on
        time_Reference = dataTypes[np.where(FLG_dataTypes == 1)[0][0]];
        print("Chose >"+time_Reference+"< as the new time reference.\n")
    else: #otherwise ditch it
        print("Looks like no data types are selected currently, so... Exiting.");
        # import sys #yolo
        sys.crash();
    #END IF
    data['time ref name'] = time_Reference; #record
#END IF
#Support for ISR time reference  
if( (time_Reference == 'ISR') & (FLG_dataTypes[FLG_ISRloc] == 0) ):
    print("WARNING: Time reference chosen was >"+time_Reference+"< but no ISR data is being imported for analysis. Switching to next avail time reference. Printing currently activated instruments:"); #print warning if time refernece won't exist
    for i in range(0,len(dataTypes)):
        print(dataTypes[i]+"\t"+str(FLG_dataTypes[i])); #report the data type and if it is on or not
    #END FOR i
    if( np.sum(FLG_dataTypes) != 0 ): #make sure at least one data type is on
        time_Reference = dataTypes[np.where(FLG_dataTypes == 1)[0][0]];
        print("Chose >"+time_Reference+"< as the new time reference.\n")
    else: #otherwise ditch it
        print("Looks like no data types are selected currently, so... Exiting.");
        # import sys #yolo
        sys.crash();
    #END IF
#END IF
#Support for AMPERE time reference  
if( (time_Reference == 'AMPERE') & (FLG_dataTypes[FLG_AMPEREloc] == 0) ):
    print("WARNING: Time reference chosen was >"+time_Reference+"< but no AMPERE data is being imported for analysis. Switching to next avail time reference. Printing currently activated instruments:"); #print warning if time refernece won't exist
    for i in range(0,len(dataTypes)):
        print(dataTypes[i]+"\t"+str(FLG_dataTypes[i])); #report the data type and if it is on or not
    #END FOR i
    if( np.sum(FLG_dataTypes) != 0 ): #make sure at least one data type is on
        time_Reference = dataTypes[np.where(FLG_dataTypes == 1)[0][0]];
        print("Chose >"+time_Reference+"< as the new time reference.\n")
    else: #otherwise ditch it
        print("Looks like no data types are selected currently, so... Exiting.");
        # import sys #yolo
        sys.crash();
    #END IF
#END IF
#Support for OMNI time reference  
if( (time_Reference == 'OMNI') & (FLG_dataTypes[FLG_OMNIloc] == 0) ):
    print("WARNING: Time reference chosen was >"+time_Reference+"< but no OMNI data is being imported for analysis. Switching to next avail time reference. Printing currently activated instruments:"); #print warning if time refernece won't exist
    for i in range(0,len(dataTypes)):
        print(dataTypes[i]+"\t"+str(FLG_dataTypes[i])); #report the data type and if it is on or not
    #END FOR i
    if( np.sum(FLG_dataTypes) != 0 ): #make sure at least one data type is on
        time_Reference = dataTypes[np.where(FLG_dataTypes == 1)[0][0]];
        print("Chose >"+time_Reference+"< as the new time reference.\n")
    else: #otherwise ditch it
        print("Looks like no data types are selected currently, so... Exiting.");
        # import sys #yolo
        sys.crash();
    #END IF
#END IF
#Support for Kp time reference  
if( (time_Reference == 'Kp') & (FLG_dataTypes[FLG_Kploc] == 0) ):
    print("WARNING: Time reference chosen was >"+time_Reference+"< but no Kp data is being imported for analysis. Switching to next avail time reference. Printing currently activated instruments:"); #print warning if time refernece won't exist
    for i in range(0,len(dataTypes)):
        print(dataTypes[i]+"\t"+str(FLG_dataTypes[i])); #report the data type and if it is on or not
    #END FOR i
    if( np.sum(FLG_dataTypes) != 0 ): #make sure at least one data type is on
        time_Reference = dataTypes[np.where(FLG_dataTypes == 1)[0][0]];
        print("Chose >"+time_Reference+"< as the new time reference.\n")
    else: #otherwise ditch it
        print("Looks like no data types are selected currently, so... Exiting.");
        # import sys #yolo
        sys.crash();
    #END IF
#END IF
#Support for Mag time reference  
if( (time_Reference == 'Mag') & (FLG_dataTypes[FLG_Magloc] == 0) ):
    print("WARNING: Time reference chosen was >"+time_Reference+"< but no Mag data is being imported for analysis. Switching to next avail time reference. Printing currently activated instruments:"); #print warning if time refernece won't exist
    for i in range(0,len(dataTypes)):
        print(dataTypes[i]+"\t"+str(FLG_dataTypes[i])); #report the data type and if it is on or not
    #END FOR i
    if( np.sum(FLG_dataTypes) != 0 ): #make sure at least one data type is on
        time_Reference = dataTypes[np.where(FLG_dataTypes == 1)[0][0]];
        print("Chose >"+time_Reference+"< as the new time reference.\n")
    else: #otherwise ditch it
        print("Looks like no data types are selected currently, so... Exiting.");
        # import sys #yolo
        sys.crash(); #crash it
    #END IF
#END IF


#plot help with autotick calculating
plotLongRange_autoTick = (np.max(plotLongRange) - np.min(plotLongRange))/25; #tries to split the longitude range into 25 parts (based off of 360/15+1)
if( plotLongRange_autoTick > 14 ):
    plotLongRange_autoTick = 30; #sets the tick setting to 15 arcdegrees per tick
elif( plotLongRange_autoTick > 10 ):
    plotLongRange_autoTick = 15; #sets the tick setting to 15 arcdegrees per tick
elif( plotLongRange_autoTick > 5 ):
    plotLongRange_autoTick = 10; #sets the tick setting to 10 arcdegrees per tick
elif( plotLongRange_autoTick > 2 ):
    plotLongRange_autoTick = 5; #sets the tick setting to 5 arcdegrees per tick
elif( plotLongRange_autoTick > 1 ):
    plotLongRange_autoTick = 2; #sets the tick setting to 5 arcdegrees per tick
elif( plotLongRange_autoTick >= 0.6 ): #0.6 because 15/25 = 0.6, so there will be enough 1 arcdeg ticks
    plotLongRange_autoTick = 1; #sets the tick setting to 1 arcdegree per tick
else:
    plotLongRange_autoTick = (np.max(plotLongRange) - np.min(plotLongRange))/15; #just goes for it if it's a super tiny range
#END IF
plotLongRange_autoTick_Crunched = (np.max(plotLongRange) - np.min(plotLongRange))/13; #tries to split the longitude range into 25 parts (based off of 360/15+1)
if( plotLongRange_autoTick_Crunched > 10 ):
    plotLongRange_autoTick_Crunched = 15; #sets the tick setting to 15 arcdegrees per tick
elif( plotLongRange_autoTick_Crunched > 5 ):
    plotLongRange_autoTick_Crunched = 10; #sets the tick setting to 10 arcdegrees per tick
elif( plotLongRange_autoTick_Crunched > 2 ):
    plotLongRange_autoTick_Crunched = 5; #sets the tick setting to 5 arcdegrees per tick
elif( plotLongRange_autoTick_Crunched > 1 ):
    plotLongRange_autoTick_Crunched = 2; #sets the tick setting to 5 arcdegrees per tick
elif( plotLongRange_autoTick_Crunched >= 0.6 ): #0.6 because 15/25 = 0.6, so there will be enough 1 arcdeg ticks
    plotLongRange_autoTick_Crunched = 1; #sets the tick setting to 1 arcdegree per tick
else:
    plotLongRange_autoTick_Crunched = (np.max(plotLongRange) - np.min(plotLongRange))/13; #just goes for it if it's a super tiny range
#END IF
plotLatRange_autoTick = (np.max(plotLatRange) - np.min(plotLatRange))/13; #tries to split the latitude range into 13 parts (based off of 180/15+1)
if( plotLatRange_autoTick > 10 ):
    plotLatRange_autoTick = 15; #sets the tick setting to 15 arcdegrees per tick
elif( plotLatRange_autoTick > 5 ):
    plotLatRange_autoTick = 10; #sets the tick setting to 10 arcdegrees per tick
elif( plotLatRange_autoTick > 2 ):
    plotLatRange_autoTick = 5; #sets the tick setting to 5 arcdegrees per tick
elif( plotLatRange_autoTick > 1 ):
    plotLatRange_autoTick = 2; #sets the tick setting to 2 arcdegrees per tick
elif( plotLatRange_autoTick > 0.75 ): #0.75 because 10/13 = 0.76something and it sounded good for enough 1 arcdeg ticks
    plotLatRange_autoTick = 1; #sets the tick setting to 1 arcdegree per tick
else:
    plotLatRange_autoTick = (np.max(plotLatRange) - np.min(plotLatRange))/13; #just goes for it if it's a super tiny range
#END IF
plotLatRange_autoTick_Crunched = (np.max(plotLatRange) - np.min(plotLatRange))/7; #tries to split the latitude range into 7 parts (based off of seems only 7 fits on a 2 subplot plot)
if( plotLatRange_autoTick_Crunched > 10 ):
    plotLatRange_autoTick_Crunched = 15; #sets the tick setting to 15 arcdegrees per tick
elif( plotLatRange_autoTick_Crunched > 5 ):
    plotLatRange_autoTick_Crunched = 10; #sets the tick setting to 10 arcdegrees per tick
elif( plotLatRange_autoTick_Crunched > 2 ):
    plotLatRange_autoTick_Crunched = 5; #sets the tick setting to 5 arcdegrees per tick
elif( plotLatRange_autoTick_Crunched > 1 ):
    plotLatRange_autoTick_Crunched = 2; #sets the tick setting to 2 arcdegrees per tick
elif( plotLatRange_autoTick_Crunched > 0.75 ): #0.75 because 10/13 = 0.76something and it sounded good for enough 1 arcdeg ticks
    plotLatRange_autoTick_Crunched = 1; #sets the tick setting to 1 arcdegree per tick
else:
    plotLatRange_autoTick_Crunched = (np.max(plotLatRange) - np.min(plotLatRange))/7; #just goes for it if it's a super tiny range
#END 
#--- For fancy plot, calculate new vars because the ratio is different ---
plotLatRange_autoTick_fancy = (np.max(plotLatRange) - np.min(plotLatRange))/17; #tries to split the latitude range into 13 parts (based off of 180/15+1)
if( plotLatRange_autoTick_fancy > 10 ):
    plotLatRange_autoTick_fancy = 15; #sets the tick setting to 15 arcdegrees per tick
elif( plotLatRange_autoTick_fancy > 5 ):
    plotLatRange_autoTick_fancy = 10; #sets the tick setting to 10 arcdegrees per tick
elif( plotLatRange_autoTick_fancy > 2 ):
    plotLatRange_autoTick_fancy = 5; #sets the tick setting to 5 arcdegrees per tick
elif( plotLatRange_autoTick_fancy > 1 ):
    plotLatRange_autoTick_fancy = 2; #sets the tick setting to 2 arcdegrees per tick
elif( plotLatRange_autoTick_fancy > 0.75 ): #0.75 because 10/13 = 0.76something and it sounded good for enough 1 arcdeg ticks
    plotLatRange_autoTick_fancy = 1; #sets the tick setting to 1 arcdegree per tick
else:
    plotLatRange_autoTick_fancy = (np.max(plotLatRange) - np.min(plotLatRange))/17; #just goes for it if it's a super tiny range
#END IF
plotLongRange_autoTick_fancy = (np.max(plotLongRange) - np.min(plotLongRange))/13; #tries to split the longitude range into 25 parts (based off of 360/15+1)
if( plotLongRange_autoTick_fancy > 25 ):
    plotLongRange_autoTick_fancy = 30; #sets the tick setting to 15 arcdegrees per tick
elif( plotLongRange_autoTick_fancy > 10 ):
    plotLongRange_autoTick_fancy = 15; #sets the tick setting to 15 arcdegrees per tick
elif( plotLongRange_autoTick_fancy > 5 ):
    plotLongRange_autoTick_fancy = 10; #sets the tick setting to 10 arcdegrees per tick
elif( plotLongRange_autoTick_fancy > 2 ):
    plotLongRange_autoTick_fancy = 5; #sets the tick setting to 5 arcdegrees per tick
elif( plotLongRange_autoTick_fancy > 1 ):
    plotLongRange_autoTick_fancy = 2; #sets the tick setting to 5 arcdegrees per tick
elif( plotLongRange_autoTick_fancy >= 0.6 ): #0.6 because 15/25 = 0.6, so there will be enough 1 arcdeg ticks
    plotLongRange_autoTick_fancy = 1; #sets the tick setting to 1 arcdegree per tick
else:
    plotLongRange_autoTick_fancy = (np.max(plotLongRange) - np.min(plotLongRange))/13; #just goes for it if it's a super tiny range
#END IF

settings_map['lat autotick'] = plotLatRange_autoTick; #set them in the settings
settings_map['long autotick'] = plotLongRange_autoTick;
settings_map['lat autotick crunched'] = plotLatRange_autoTick_Crunched;
settings_map['long autotick crunched'] = plotLongRange_autoTick_Crunched;
settings_map['lat autotick fancy'] = plotLatRange_autoTick_fancy;
settings_map['long autotick fancy'] = plotLongRange_autoTick_fancy;

if( geoMap_projectionStyle == 'mill' ):
    settings_map['projection'] = cartopy.crs.PlateCarree(); #set the projection type to use, platecarree is like mill but distorts pole areas a bit less so
elif( geoMap_projectionStyle == 'robin' ):
    settings_map['projection'] = cartopy.crs.Robinson(); #set the projection type to use
elif( geoMap_projectionStyle == 'stere' ):
    settings_map['projection'] = cartopy.crs.Stereographic(); #set the projection type to use
elif( geoMap_projectionStyle == 'npstere' ):
    settings_map['projection'] = cartopy.crs.NorthPolarStereo(); #set the projection type to use
else:
    print('ERROR: geoMap_projectionStyle '+geoMap_projectionStyle+' not supported. Crashing, add the support. It needs to be cartopy.');
    sys.crash();
#END IF

#==============Set up the mega dicts that hold all the stuff==============
settings_plot = {
    'font axis tick':FONT_axisTick,
    'font axis tick FM':FONT_axisTickFM,
    'font axis label':FONT_axisLabel,
    'font axis label FM':FONT_axisLabelFM,
    'font title':FONT_title,
    'font title FM':FONT_titleFM,
    'font grandiose':FONT_grandiose,
    'font grandiose FM':FONT_grandioseFM,
    'line width':PLOT_lineWidth,
    'color':PLOT_color,
    'line style':PLOT_lineStyle,
    'fancy plot':FLG_fancyPlot,
    'journal width 1C':journal_width_1C,
    'journal width 2C':journal_width_2C,
    'journal height max':journal_height_max,
    'journal dpi':journal_dpi
    }; #plot settings

settings['paths'] = settings_paths; #path settings
settings['spectra'] = settings_spectra; #spectra settings
settings['map'] = settings_map; #map settings
settings['plot'] = settings_plot; #plot settings
settings['TEC'] = settings_TEC; #incorporate the TEC settings
settings['TEC import'] = settings_TEC_import; #incorporate the TEC import settings

dates = {
    'date range':dateRange, #this is the start and end dates in YR/M/D
    'date range dayNum':dateRange_dayNum, #start and end dates in YR/DNum
    'date range full':dateRange_full, #full date range between the start and end dates in YR/M/D
    'date range full dayNum':dateRange_dayNum_full, #full date range between the start and end dates in YR/DNum
    'date range zero hr':dateRange_zeroHr, #the date that is set to be the 0 hr for plotting in YR/M/D
    'date range zero hr dayNum':dateRange_dayNum_zeroHr, #the date that is set to be the 0 hr for plotting in YR/DNum
    'date range zero hr month name':dateRange_zeroHr_monthName, #gets you the month name in real words
    'date range zero hr day post fix':dateRange_zeroHr_dayPostfix, #gets that good -st or -nd or -rd or -th to make words look nice
    'date range zero hr hour offset':dateRange_zeroHr_hrOffset, #the hour offset applied to get the 0 hour shited from the start of the data
    'date range zero hr hour bounds':dateRange_zeroHr_hrBounds, #the start and end dates in hours centered around the 0 hour
    'date range zero hr hours':dateRange_zeroHr_hrs #the hour of each day change over
    };

#==============Import needed data sets==============
print('Data Import Beginning:');
tic = time.time();
#-----Import delta-vTEC-----
    #~~~IMPORT PRE-PROCESSED DATA~~~
if( np.any(np.asarray(FLG_TEC_use) == 0) | np.any(np.asarray(FLG_TEC_use) == 1) ):
    if( FLG_dataTypes[FLG_TECloc] == 1):
        print("Importing TEC");
        # (TEC_int, TEC_float, TEC_str, FLG_dataTypes[FLG_TECloc]) = \
        (data['TEC'], FLG_dataTypes[FLG_TECloc]) = \
            GRITI_import_TEC_otherSources(dateRange_dayNum_full,dateRange_dayNum_zeroHr,folder,plotLatRange,plotLongRange, \
                TEC_dataRate=settings_TEC_import['TEC_dataRate'],TEC_minimumTimeGap=settings_TEC_import['TEC_minimumTimeGap'],
                TEC_timeTolerance=settings_TEC_import['TEC_timeTolerance']); #import pre-processed TEC data from other sources
    #END IF
#END IF
    #~~~IMPORT MADRIGAL DATA~~~
if( np.any(np.asarray(FLG_TEC_use) == 0) | np.any(np.asarray(FLG_TEC_use) == 2) ):    
    if( ((FLG_dataTypes[FLG_TECloc] == 2) | np.any(np.asarray(FLG_TEC_use) == 2)) & (FLG_dataTypes[FLG_TECloc] != 0) ):
        
        data['TEC'] = GRITI_import_TEC_Madrigal( dates, settings ); #import TEC data for the date range
        TEC_dataRate = data['TEC']['data rate']; #record the data rate for functions and stuff
        
        # (TEC_int, TEC_float, TEC_str) = GRITI_import_TEC_Madrigal(dateRange_dayNum_full, folder,plotLatRange,plotLongRange, \
        #     web_base_name=settings_TEC_import['web_base_name'],web_base_email=settings_TEC_import['web_base_email'],web_base_affil=settings_TEC_import['web_base_affil'], \
        #     minElevation = settings_TEC_import['TEC_minElevation'], minimumTimeGap = settings_TEC_import['TEC_minimumTimeGap'], \
        #     deltaTEC_compareValue = settings_TEC_import['TEC_deltaTEC_compareValue'], TEC_dataRate = settings_TEC_import['TEC_dataRate'], \
        #     filter_savGolPeriod = settings_TEC_import['filter_savGolPeriod'], order_savGol = settings_TEC_import['order_savGol'], \
        #     FLG_reqPaddedDays = 0, FLG_deleteOrig = 0, FLG_deleteUnfilt = 0, FLG_overwrite = 0, FLG_verboseReturn = 0 , \
        #     FLG_dataAggregation = settings_TEC_import['FLG_dataAggregation'] , TEC_dataAgg_timeAdditionLimit = settings_TEC_import['TEC_dataAgg_timeAdditionLimit'], \
        #     TEC_dataAgg_distToPts = settings_TEC_import['TEC_dataAgg_distToPts'], TEC_dataLimPercent = settings_TEC_import['TEC_dataLimPercent'], TEC_deltaLim = settings_TEC_import['TEC_deltaLim'], \
        #     TEC_timeTolerance=settings_TEC_import['TEC_timeTolerance'], TEC_maxAmpAllowed=settings_TEC_import['TEC_maxAmpAllowed'] ); #import TEC data for the date range
        # TEC_dataRate = settings_TEC_import['TEC_dataRate']; #set it
    #END IF    
#END IF
    #~~~IMPORT LISN DATA~~~
if( np.any(np.asarray(FLG_TEC_use) == 0) | np.any(np.asarray(FLG_TEC_use) == 3) ):    
    if( FLG_dataTypes[FLG_TECloc] >= 1 ):
        # (TEC_int_temp, TEC_float_temp, TEC_str_temp) = 
        (TEC_dataTemp) = GRITI_import_TEC_LISN(dateRange_dayNum_full,dateRange_dayNum_zeroHr, folder,plotLatRange,plotLongRange, \
            settings['TEC import']['web_LISN_creden_user'],settings['TEC import']['web_LISN_creden_pass'], \
            minElevation = settings['TEC import']['TEC_minElevation'], minimumTimeGap = settings['TEC import']['TEC_minimumTimeGap'], \
            deltaTEC_compareValue = settings['TEC import']['TEC_deltaTEC_compareValue'], TEC_dataRate = settings['TEC import']['TEC_dataRate'], \
            filter_savGolPeriod = settings['TEC import']['filter_savGolPeriod'], order_savGol = settings['TEC import']['order_savGol'], filter_cutoffPeriod = filter_cutoffPeriod, \
            FLG_reqPaddedDays = 0, FLG_deleteOrig = 0, FLG_deleteUnfilt = 0, FLG_overwrite = 0, FLG_verboseReturn = 0 , \
            FLG_dataAggregation = settings['TEC import']['FLG_dataAggregation'] , TEC_dataAgg_timeAdditionLimit = settings['TEC import']['TEC_dataAgg_timeAdditionLimit'], \
            TEC_dataAgg_distToPts = settings['TEC import']['TEC_dataAgg_distToPts'], TEC_dataLimPercent = settings['TEC import']['TEC_dataLimPercent'], TEC_deltaLim = settings['TEC import']['TEC_deltaLim'] , \
            TEC_timeTolerance=settings['TEC import']['TEC_timeTolerance'], TEC_maxAmpAllowed=settings['TEC import']['TEC_maxAmpAllowed']); #import TEC data for the date range
                
        # try: #try to act on TEC_int and the others directly, will error if they don't exist yet
        #     TEC_int = np.concatenate( (TEC_int,TEC_int_temp), axis=0); #concatenate on the ints
        #     del TEC_int_temp #delete the extra data
        #     TEC_float = np.concatenate( (TEC_float,TEC_float_temp), axis=0); #concatenate on the floats
        #     del TEC_float_temp #delete the extra data
        #     TEC_str = np.concatenate( (TEC_str,TEC_str_temp), axis=0); #concatenate on the strings
        #     del TEC_str_temp #delete the extra data 
        # except NameError:
        #     TEC_int = np.copy(TEC_int_temp); #just copy it over to make it exist
        #     del TEC_int_temp #delete the extra data
        #     TEC_float = np.copy(TEC_float_temp); #just copy it over to make it exist
        #     del TEC_float_temp #delete the extra data
        #     TEC_str = np.copy(TEC_str_temp); #just copy it over to make it exist
        #     del TEC_str_temp #delete the extra data 
        # #END TRYING
        
        keyz = list(TEC_dataTemp.keys()); #get the keys
        try:
            keyz2 = list(data['TEC'].keys()); #get the keys
            for j in range(0,len(keyz)):
                if( keyz[j] in keyz2 ):
                    if( isinstance(data['TEC'][keyz[j]],(np.ndarray)) ):
                        data['TEC'][keyz[j]] = np.hstack( (data['TEC'][keyz[j]], TEC_dataTemp[keyz[j]]) ); #smack them together
                    elif( isinstance(data['TEC'][keyz[j]],(list)) ):
                        data['TEC'][keyz[j]].append(TEC_dataTemp[keyz[j]]); #append if list
                    elif( np.isscalar(data['TEC'][keyz[j]]) ):
                        if( data['TEC'][keyz[j]] != TEC_dataTemp[keyz[j]]):
                            print('WARNING: TEC scalar numbers don\'t match but not a big deal, deal with this later\n'+\
                                  'Orig: '+str(data['TEC'][keyz[j]])+'\t New: '+str(TEC_dataTemp[keyz[j]])); #tell it's not quite right
                        #END IF
                    #END IF
                else:
                    data['TEC'][keyz[j]] = TEC_dataTemp[keyz[j]]; #new addition
                    keyz2 = list(data['TEC'].keys()); #get the keys again
                #END IF
            #END FOR j
        except:
            data['TEC'] = {}; #prep it as a dict sicne it doesn't exist
            for j in range(0,len(keyz)):
                data['TEC'][keyz[j]] = TEC_dataTemp[keyz[j]]; #create the dict
            #END FOR j
        #END TRY
        del TEC_dataTemp
        gc.collect(); #clean the garbage
        #this has bad results
        # data['TEC']['dTEC'] = data['TEC']['dTEC'] - np.mean(data['TEC']['dTEC']); #force a 0 mean here
    #END IF
#END IF

if( FLG_dataTypes[FLG_TECloc] >= 1 ):
    # TEC_timeUnique = np.unique(data['TEC']['time']); #days, get unique times (v useful)
    data['TEC']['time unique'] = np.unique(data['TEC']['time']); #sec, get unique times (v useful)
    TEC_timeUnique = data['TEC']['time unique']; #sec set it for reuse in main
    data['TEC']['time unique aligned'] = np.unique(data['TEC']['time aligned']); #sec, get unique times (v useful) [aligned has year support and is set around the defined 0 hour]
    TEC_timeUniqueAligned = data['TEC']['time unique aligned']; #sec set it for reuse in main
#END IF

if( (FLG_TEC_noise >= 1) & (FLG_dataTypes[FLG_TECloc] >= 1) ): #replace the delta-vTEC data with random data OR random data with synth waves embedded
    data['TEC']['dTEC'] = GRITI_TEC_randomSynth(data['TEC']['dTEC'].size,data['TEC']['lat'],data['TEC']['long'],data['TEC']['time'], \
        noise_background_mean,noise_background_stdev,Re,dateRange_zeroHr, \
        plotLatRange,plotLongRange,plotLatRange_autoTick,plotLongRange_autoTick, \
        wave_latRange,wave_longRange,wave_N,wave_angle,wave_phase,wave_waveLength,wave_period,wave_amp, \
        FONT_titleFM,FONT_axisTick,FONT_axisLabelFM,TEC_plotLimValu,FLG_TEC_noise,FLG_plotStuff=1); #replace the delta-vTEC data with random data OR random data with synth waves embedded
#END IF

#-----TEC delta-vTEC File Layout-----
    #Integer Layout
    #0 = Satellite ID [# that corresponds to GPS sat]
    #1 = Year timestamp [years]
    
    #Float Layout
    #0 = delta-vTEC [TECU]
    #1 = current time in day format [days] - does not support years
    #2 = geodedic latitude [arcdeg]
    #3 = longitude [arcdeg]
    #4 = elevation [deg]
    
    #String Layout
    #[] = Receiver Site Name (there's no dim on this one) - use .decode('UTF-8') to make it a string again

#-----Import ISR Data-----
if( FLG_dataTypes[FLG_ISRloc] == 1):
    print("Importing ISR");
    (ISR_Mill_lat, ISR_Mill_long, Zenith_SNR, Zenith_SNR_hp, Zenith_POPL, Zenith_POPL_hp, Zenith_height, Zenith_time, \
     Zenith_vel, Zenith_vel_hp, Zenith_el, Zenith_az, Zenith_dopplar, Zenith_filtHeight, MISA_SNR, MISA_SNR_hp, MISA_POPL, MISA_POPL_hp, MISA_height, \
     MISA_time, MISA_vel,  MISA_vel_hp, MISA_el, MISA_az, MISA_dopplar, MISA_filtHeight) = \
         GRITI_import_ISR_Haystack(dateRange_dayNum_full,folder,dateRange_dayNum_zeroHr,pointAltitude,filter_cutoffPeriod=filter_cutoffPeriod); #import ISR data, process if need-be
    if( ISR_zenithMISA == 0):
        ISR_timeUnique = np.unique(Zenith_time); #days, get unique times (v useful)
    else:
        ISR_timeUnique = np.unique(MISA_time); #days, get unique times (v useful)
    #END IF
    
    (ISR_PFISR_lat, ISR_PFISR_long, PFISR_SNR, PFISR_SNR_hp, PFISR_POPL, PFISR_POPL_hp, PFISR_height, PFISR_time, PFISR_vel, PFISR_el, PFISR_az, PFISR_dopplar, PFISR_filtHeight) = \
        GRITI_import_ISR_Pokerflat(dateRange_dayNum_full,folder,dateRange_dayNum_zeroHr,pointAltitude,filter_cutoffPeriod = filter_cutoffPeriod)
#END IF

#-----Import AMPERE Data-----  
if( FLG_dataTypes[FLG_AMPEREloc] == 1):
    print("Importing AMPERE");
    if( time_cutout_range_delay_AMPERE > 0 ):
        dateRange_extraDaysForDelay = np.int64(np.ceil(time_cutout_range_delay_AMPERE/24)); #get how many extra days are needed
        dateRange_dayNum_adj = np.copy(dateRange_dayNum); #copy it over
        dateRange_dayNum_adj[0,1] -= dateRange_extraDaysForDelay; #put this in
        #!! NO YEAR ROLL UNDER SUPPORT !!
        (_, dateRange_dayNum_full_adj) = subfun_dateORdayNum_to_fullRange(dateRange_dayNum_adj); #call fun to get fully enumerated days between range
    else:
        dateRange_dayNum_full_adj = dateRange_dayNum_full; #keep it the same so code work
    #END IF
    
    # data['AMPERE'], AMPERE_data = GRITI_import_AMPERE_preprepared(dateRange_dayNum_full,folder,dateRange_dayNum_zeroHr,locAMPERE_jouleHeating,AMPERE_plotLimValu); #import pre-processed AMPERE data
    # AMPERE_timeUnique = np.unique(AMPERE_data[:,5]); #days, get unique times (v useful)
    # data['AMPERE']['time unique'] =  np.unique(data['AMPERE']['time']); #days, get unique times (v useful)
    # data['AMPERE']['data rate'] = np.int64(np.round(np.median(np.diff(AMPERE_timeUnique)*24*60)))*60; #sec, gets the data rate
   
    data['AMPERE'] = GRITI_import_AMPERE(dates,folder,dateRange_dayNum_full_adj,FLG_dataMix=0,FLG_dataPreference=0,FLG_float64=0); #import pre-processed AMPERE data
    data['AMPERE']['time unique'] =  np.unique(data['AMPERE']['time']); #sec, get unique times (v useful)
    AMPERE_timeUnique = data['AMPERE']['time unique']; #sec, set to be the same thing

#    AMPERE_data[:,AMPERE_plot_index] = np.log(AMPERE_data[:,AMPERE_plot_index]); #take the log to reduce the dynamic range
#END IF
#-----AMPERE File Layout-----
    #Float 32 layout
    #0 = Pedersen Conductance [?]
    #1 = Hall Conductance [?]
    #2 = Joule Heat [ergs/(cm^2*sec)]
    #3 = Electric Potential [?]
    #4 = Field-Algined Current [?]
    #5 = time [days] - does not support years 
    #6 = latitude [arcdeg]
    #7 = longitude [arcdeg]
    
#-----Import Kp Data-----  
if( FLG_dataTypes[FLG_Kploc] == 1):
    print("Importing Kp");
    if( time_cutout_range_delay_OMNI > 0 ):
        dateRange_extraDaysForDelay = np.int64(np.ceil(time_cutout_range_delay_OMNI/24)); #get how many extra days are needed
        dateRange_dayNum_adj = np.copy(dateRange_dayNum); #copy it over
        dateRange_dayNum_adj[0,1] -= dateRange_extraDaysForDelay; #put this in
        #!! NO YEAR ROLL UNDER SUPPORT !!
        (_, dateRange_dayNum_full_adj) = subfun_dateORdayNum_to_fullRange(dateRange_dayNum_adj); #call fun to get fully enumerated days between range
    else:
        dateRange_dayNum_full_adj = dateRange_dayNum_full; #keep it the same so code work
    #END IF
    Kp_dataDict = GRITI_import_Kp(dateRange_dayNum_full_adj); #import Kp data from internet
    Kp_time = Kp_dataDict['time']
    Kp_data = Kp_dataDict['Kp']
    Kp_timeUnique = Kp_time; #days, same thing
#END IF
    #NOTE: Kp is every 3 hours, 0-3, 3-6, 6-9, 9-12, 12-15, 15-18, 18-21, 21-24 UT (8 of em) - assumed that data occurs on hour end (e.g. 0-3 means 3 is the data pt)
    
#-----Import OMNI Data-----  
if( FLG_dataTypes[FLG_OMNIloc] == 1):
    print("Importing OMNI");
    if( time_cutout_range_delay_OMNI > 0 ):
        dateRange_extraDaysForDelay = np.int64(np.ceil(time_cutout_range_delay_OMNI/24)); #get how many extra days are needed
        dateRange_dayNum_adj = np.copy(dateRange_dayNum); #copy it over
        dateRange_dayNum_adj[0,1] -= dateRange_extraDaysForDelay; #put this in
        #!! NO YEAR ROLL UNDER SUPPORT !!
        (_, dateRange_dayNum_full_adj) = subfun_dateORdayNum_to_fullRange(dateRange_dayNum_adj); #call fun to get fully enumerated days between range
    else:
        dateRange_dayNum_full_adj = dateRange_dayNum_full; #keep it the same so code work
    #END IF
    OMNI_data, OMNI_dict, OMNI_dictPlot = GRITI_import_OMNI(dateRange_dayNum_full_adj, folder); #import OMNI data from internet
    # OMNI_timeUnique = OMNI_data[:,OMNI_dict['Day Num']] + OMNI_data[:,OMNI_dict['Hour']]/24 + OMNI_data[:,OMNI_dict['Min']]/(1440); #days, get unique times (v useful) - unique times are implicit
    OMNI_timeUnique = OMNI_data[:,OMNI_dict['Day Num']]*86400 + OMNI_data[:,OMNI_dict['Hour']]*3600 + OMNI_data[:,OMNI_dict['Min']]*60; #days, get unique times (v useful) - unique times are implicit
    data['OMNI'] = {}
    data['OMNI']['data rate'] = np.median(np.diff(OMNI_timeUnique)) #sec, record OMNI data rate
#END IF
#-----OMNI File Layout-----
#Float 64 layout
#0 = year
#1 - day#
#2 = hr
#3 = min
#4 = Bz GSE (nT)
#5 = Flow speed (km/s)
#6 = Flow pressure (nPa)
#7 = AE Index (nT)
#8 = SYM/H Index (nT)

#-----Import Mag Data-----  
if( FLG_dataTypes[FLG_Magloc] == 1):
    print("Importing Magnetometer Data");
    data['Mag'] = GRITI_import_Mag_NRCan(dates, settings, FLG_deleteRaw = 0, FLG_overwrite = 0); #import OMNI data from internet
    siteNames = data['Mag']['site names']; #get this var
    cntr = 0; #prep cntr
    cntrF = 0; #prep cntrF
    for j in range(0,len(siteNames)):
        cntr += data['Mag'][siteNames[j]]['mag'].shape[0]; #get the total size
        cntrF += data['Mag'][siteNames[j]]['magF'].size; #get the total size
    #END FOR j
    Mag_time = np.zeros( cntr, dtype=np.float64); #preallocate
    Mag_timeF = np.zeros( cntrF, dtype=np.float64); #preallocate
    cntr = 0; #Prep cntr
    cntrF = 0; #prep cntrF
    for j in range(0,len(siteNames)):
        tempSize = data['Mag'][siteNames[j]]['mag'].shape[0]; #prep
        tempSizeF = data['Mag'][siteNames[j]]['magF'].size; #prep
        Mag_time[cntr:cntr+tempSize] = np.float64(data['Mag'][siteNames[j]]['dayNum']) + np.float64(data['Mag'][siteNames[j]]['sec'])/86400; #days, get unique times (v useful)
        Mag_timeF[cntrF:cntrF+tempSizeF] = np.float64(data['Mag'][siteNames[j]]['dayNumF']) + np.float64(data['Mag'][siteNames[j]]['secF'])/86400; #days, get unique times (v useful)
        cntr += tempSize; #increment
        cntrF += tempSizeF; #increment
    #END FOR j  
    data['Mag']['timeUnique'] = np.unique(Mag_time); #days, get unique times (v useful)
    data['Mag']['timeUniqueF'] = np.unique(Mag_timeF); #days, get unique times (v useful)
    Mag_timeUnique = data['Mag']['timeUniqueF']; #get this variable out
    data['Mag']['timeUniqueF_hr'] = (data['Mag']['timeUniqueF']-dates['date range zero hr dayNum'][1])*24; #get this variable out
    data['Mag']['timeUnique_hr'] = (data['Mag']['timeUnique']-dates['date range zero hr dayNum'][1])*24; #get this variable out
    
    #-----Get the plot lat/long ranges based on the site locations involved-----
    if( Mag_keo_setPlotRange == 0 ):
        siteLocs = np.zeros( (2, len(data['Mag']['site names'])) ); #preallocate
        for j in range(0,len(data['Mag']['site names'])):
            siteLocs[0,j] = data['Mag'][data['Mag']['site names'][j]]['lat'];
            siteLocs[1,j] = data['Mag'][data['Mag']['site names'][j]]['long'];
        #END FOR j
        
        Mag_plotLatRange = [np.min(siteLocs[0,:]), np.max(siteLocs[0,:])]; # get lat extent
        Mag_plotLongRange = [np.min(siteLocs[1,:]), np.max(siteLocs[1,:])]; # get long extent
        #Adjust these ranges as needed
        if( np.remainder(np.ceil(Mag_plotLatRange[1]),5) == 0 ):
            Mag_plotLatRange[1] = np.ceil(Mag_plotLatRange[1]) + 5; #keep up to a 5 degc lat boundary
        else:
            Mag_plotLatRange[1] = np.ceil(Mag_plotLatRange[1]) + (5-np.remainder(np.ceil(Mag_plotLatRange[1]),5)); #keep up to a 5 degc lat boundary
        #END IF
        if( np.remainder(np.floor(Mag_plotLatRange[0]),5) == 0 ):
            Mag_plotLatRange[0] = np.floor(Mag_plotLatRange[0]) - 5; #keep up to a 5 degc lat boundary
        else:
            Mag_plotLatRange[0] = np.floor(Mag_plotLatRange[0]) - np.remainder(np.floor(Mag_plotLatRange[0]),5); #keep up to a 5 degc lat boundary
        #END IF
        if( np.remainder(np.ceil(Mag_plotLongRange[1]),5) == 0 ):
            Mag_plotLongRange[1] = np.ceil(Mag_plotLongRange[1]) + 5; #keep up to a 5 degc lat boundary
        else:
            Mag_plotLongRange[1] = np.ceil(Mag_plotLongRange[1]) + (5-np.remainder(np.ceil(Mag_plotLongRange[1]),5)); #keep up to a 5 degc long boundary
        #END IF
        if( np.remainder(np.floor(Mag_plotLongRange[0]),5) == 0 ):
            Mag_plotLongRange[0] = np.floor(Mag_plotLongRange[0]) - 5; #keep up to a 5 degc lat boundary
        else:
            Mag_plotLongRange[0] = np.floor(Mag_plotLongRange[0]) - np.remainder(np.floor(Mag_plotLongRange[0]),5); #keep up to a 5 degc long boundary
        #END IF
        settings['Mag']['lat range'] = Mag_plotLatRange; #record Mag's custom lat range for when only Mag is in play
        settings['Mag']['long range'] = Mag_plotLongRange; #record Mag's custom long range for when only Mag is in play
    else:
        #otherwise, let user set the lat/long range at will
        settings['Mag']['lat range'] = Mag_keo_setPlotRange_range[0]; #arcdeg, set it by user
        settings['Mag']['long range'] = Mag_keo_setPlotRange_range[1]; #arcdeg, set it by user
    #END IF
#END IF

#-----Set time reference to a variable - had to get that data first!----
if( (time_Reference == 'TEC') ):
    time_Ref = TEC_timeUnique; #set the time refernece by copying
elif( (time_Reference == 'ISR') ):
    time_Ref = ISR_timeUnique; #set the time refernece by copying
elif( (time_Reference == 'AMPERE') ):
    time_Ref = AMPERE_timeUnique; #set the time refernece by copying
elif( (time_Reference == 'OMNI') ):
    time_Ref = OMNI_timeUnique; #set the time refernece by copying
elif( (time_Reference == 'Kp') ): #Kp is a pretty awful time reference
    time_Ref = Kp_timeUnique; #set the time refernece by copying
elif( (time_Reference == 'Mag') ): #Kp is a pretty awful time reference
    time_Ref = Mag_timeUnique; #set the time refernece by copying
else:
    print("WARNING: Time reference chosen was >"+time_Reference+"< but that type data isn't supported. Correct this."); #print warning if time refernece won't exist
    print("Exiting.");
    import sys #yolo
    sys.crash(); #crash instead
#END IF
data['time ref'] = time_Ref;

toc = time.time() - tic;
print("Data Import took: "+str(np.round(toc,2))+" sec / "+str(np.round(toc/60,2))+" min\n");


#==============Plot prep standardization variables==============
#-----Prep plot to show area being averaged-----
if( (np.round(np.min(plotLatRange)) < 0) & (geoMap_projectionStyle == 'npstere') ):
    print("WARNING: Plot projection style set to North Polar Stereographic ('npstere') but latitude range goes past the equator. Switching to Miller ('mill').");
    geoMap_projectionStyle = 'mill'; #switch to this because robin is only world plots
    settings_map['projection'] = cartopy.crs.PlateCarree(); #set the projection type to use
#END IF
if( (np.round(np.max(plotLatRange)) > 0) & (geoMap_projectionStyle == 'spstere') ):
    print("WARNING: Plot projection style set to South Polar Stereographic ('spstere') but latitude range goes past the equator. Switching to Miller ('mill').");
    geoMap_projectionStyle = 'mill'; #switch to this because robin is only world plots
    settings_map['projection'] = cartopy.crs.PlateCarree(); #set the projection type to use
#END IF

if( ((np.round(np.max(plotLongRange)) != 180) | (np.round(np.min(plotLongRange)) != -180) | \
   (np.round(np.max(plotLatRange)) != 90) | (np.round(np.min(plotLatRange)) != -90)) & (geoMap_projectionStyle == 'robin') ):
    print("WARNING: Plot projection style set to Robinson ('robin') but a non-global area is chosen. Switching to Miller ('mill').");
    geoMap_projectionStyle = 'mill'; #switch to this because robin is only world plots
    settings_map['projection'] = cartopy.crs.PlateCarree(); #set the projection type to use
#END IF

#fix for 'robin' plot having reduced room for longitude data points
if( geoMap_projectionStyle == 'robin' ):
    plotLongRange_autoTick = plotLongRange_autoTick*2; #double the tick spacing to account for smaller amount of space
#END IF
if( (geoMap_projectionStyle == 'npstere') | (geoMap_projectionStyle == 'spstere') ):
    avg_anyAngle_polarMode = 1; #force to 1 if polar plot styles were chosen
    if(geoMap_projectionStyle == 'npstere'):
        geoMap_projectionStyle_polar = 1; #simple flag to show north pole
    else:
        geoMap_projectionStyle_polar = 2; #simple flag to show south pole
    #END IF
else:
    geoMap_projectionStyle_polar = 0; #simple flag to show no polar is activated
#END IF

#****************************************************************TEC ANALYSIS****************************************************************
#!!!==============Analysis: Any Angle AVG (Keogram)==============!!!
if( (FLG_avg_anyAngle == 1) ):           
    data['TEC']['keo'], settings['TEC']['keo'] = GRITI_keo_keogrammer( \
        data['TEC']['dTEC'] ,data['TEC']['time'], data['TEC']['lat'], data['TEC']['long'], \
        data['TEC']['time unique'], data['time ref'], dates, \
        settings['TEC']['keo'], settings_paths, settings_map, settings_plot, \
        FLG_fancyPlot=FLG_fancyPlot,FLG_disablePlot=0,FLG_dataDensity=FLG_TEC_keo_dataDensity,FLG_disableText=0,FLG_disableCache=0,FLG_useRightExact=0);
    #call the mecha function that runs the keo alg and makes a plot showing the averaging are
#END IF
  
    
#==============Analysis: Plot Keograms of Any Angle AVG==============
if( (FLG_avg_anyAngle_plot == 1) & (FLG_avg_anyAngle == 1) ):
    #-----Plot TEC results as a Keogram-----
    GRITI_keo_plot(data['TEC']['keo'], data['TEC']['time unique'], data['time ref'], dates, \
        settings['TEC']['keo'] ,settings_plot, settings_paths, settings_map, \
        FLG_fancyPlot = 0);
    #call the mecha function that plots the avg'd delta-vTEC
#END IF

#==============Analysis: Plot Keograms of Any Angle AVG ~fancy~==============
if( (FLG_avg_anyAngle_plot == 1) & (FLG_avg_anyAngle == 1) & (FLG_fancyPlot == 1) ):
    #-----Plot TEC results as a Keogram-----
    GRITI_keo_plot(data['TEC']['keo'], data['TEC']['time unique'], data['time ref'], dates, \
        settings['TEC']['keo'] ,settings_plot, settings_paths, settings_map, \
        FLG_fancyPlot = 1);
    #call the mecha function that plots the avg'd delta-vTEC
#END IF

#==============Analysis: Plot Keograms of Any Angle AVG with day/nite plot ~fancy~==============
if( (FLG_avg_anyAngle_plot == 1) & (FLG_avg_anyAngle == 1) & (FLG_fancyPlot == 1) ):
    #-----Plot TEC results as a Keogram-----
    GRITI_TEC_keo_fancyPlot_TEC_wDayNite(data['TEC']['keo'],TEC_timeUnique,TEC_plotLimValu, \
        'jet',plotLatRange,plotLongRange,latMillstone,longMillstone,dateRange_dayNum_zeroHr,time_Ref,latLong_ref, \
        settings['TEC']['keo']['keo angle'],settings['TEC']['keo']['keo width'], \
        settings['TEC']['keo']['keo plot latlong chunks'] ,settings['TEC']['keo']['keo plot latlong name'], \
        'delta-vTEC','delta-vTEC [TECU]',dateRange_zeroHr,dateRange_zeroHr_monthName, \
        dateRange_zeroHr_dayPostfix, dateRange_dayNum_full, dateRange_full,\
        FONT_grandioseFM, FONT_titleFM,FONT_axisTick,FONT_axisLabelFM, PLOT_lineWidth, folder, journal_width_2C,journal_height_max,journal_dpi);
    #call the mecha function that plots the avg'd delta-vTEC
#END IF

#==============Analysis: Plot Keograms of Any Angle AVG and ISR ~fancy~==============
if( (FLG_avg_anyAngle_plot == 1) & (FLG_avg_anyAngle == 1) & (FLG_dataTypes[FLG_ISRloc] == 1) & (FLG_fancyPlot == 1) ):
    #-----Plot TEC results as a Keogram-----
    GRITI_TEC_keo_fancyPlot_TECnISR(data['TEC']['keo'],TEC_timeUnique,TEC_plotLimValu, \
        'jet',plotLatRange,plotLongRange,latMillstone,longMillstone,dateRange_dayNum_zeroHr, \
        settings['TEC']['keo']['keo angle'],settings['TEC']['keo']['keo width'], \
        settings['TEC']['keo']['keo plot latlong chunks'] ,settings['TEC']['keo']['keo plot latlong name'], \
        'delta-vTEC','delta-vTEC [TECU]',dateRange_zeroHr,dateRange_zeroHr_monthName,dateRange_zeroHr_dayPostfix,\
        Zenith_time, Zenith_height, Zenith_POPL_hp, ISR_POPL_plotLimValu, ISR_RTI_heightLimValues, \
        FONT_grandioseFM,FONT_titleFM,FONT_axisTick,FONT_axisLabelFM, PLOT_lineWidth, folder, journal_width_2C,journal_height_max,journal_dpi);
    #call the mecha function that plots the avg'd delta-vTEC
#END IF  
    
#==============Analysis: Plot Keograms of Any Angle AVG and TEC noise ~fancy~==============
if( (FLG_avg_anyAngle_plot_wNoise == 1) & (FLG_avg_anyAngle == 1) & (FLG_fancyPlot == 1) ):
    #-----Plot TEC results as a Keogram-----
    GRITI_TEC_keo_fancyPlot_TECnNoise(data['TEC']['keo'],TEC_timeUnique,TEC_plotLimValu, \
        data['TEC']['lat'], data['TEC']['long'], data['TEC']['time'], data['time ref'], \
        noise_background_mean, noise_background_stdev, Re, avg_anyAngle_N, avg_anyAngle_45vsLatLong, \
        wave_latRange, wave_longRange, wave_N, wave_angle, wave_phase, wave_waveLength, wave_period, wave_amp, \
        'jet',plotLatRange,plotLongRange,latMillstone,longMillstone,dateRange_dayNum_zeroHr, \
        settings['TEC']['keo']['keo angle'],settings['TEC']['keo']['keo width'], \
        settings['TEC']['keo']['keo plot latlong chunks'] ,settings['TEC']['keo']['keo plot latlong name'], \
        'delta-vTEC','delta-vTEC [TECU]',dateRange_zeroHr,dateRange_zeroHr_monthName,dateRange_zeroHr_dayPostfix,\
        Zenith_time, \
        FONT_grandioseFM, FONT_titleFM,FONT_axisTick,FONT_axisLabelFM, PLOT_lineWidth, folder, journal_width_2C,journal_height_max,journal_dpi);
    #call the mecha function that plots the avg'd delta-vTEC
#END IF  

#==============Analysis: Plot Time Cut-out Keograms of Any Angle AVG==============
if( (FLG_avg_anyAngle_plot_timeCutout == 1) & (FLG_avg_anyAngle == 1) ):
    #-----Plot TEC results as a Keogram-----
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (TEC_timeUnique-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (TEC_timeUnique-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , \
        np.where(np.min(np.abs( (TEC_timeUnique-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (TEC_timeUnique-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range
    
    vTECChunked_keo_cutOut = data['TEC']['keo'][time_cutout_indexes[0]:time_cutout_indexes[1]+1,:];
    TEC_timeUnique_cutOut = TEC_timeUnique[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    
    GRITI_TEC_keo_plot_TEC_cutOut(vTECChunked_keo_cutOut,TEC_timeUnique_cutOut,TEC_plotLimValu,'jet', \
      plotLatRange,plotLongRange,latMillstone,longMillstone, dateRange_dayNum_zeroHr, \
      settings['TEC']['keo']['keo angle'],settings['TEC']['keo']['keo width'], \
      settings['TEC']['keo']['keo plot latlong chunks'] ,settings['TEC']['keo']['keo plot latlong name'], \
      'delta-vTEC','delta-vTEC [TECU]',time_cutout_range, \
      FONT_titleFM,FONT_axisTick,FONT_axisLabelFM);
    #call the mecha function that plots the avg'd delta-vTEC
#END IF

#==============Analysis: Plot Time Time series / keograms of TEC data replaced with noise==============
if( (FLG_avg_anyAngle_plot_noiseAllViews == 1) & (FLG_fancyPlot == 1) & (plotLatRange == [-90,90]) & (plotLongRange == [-180,180]) ):
    #-----Plot TEC results as a Keogram and as a time series all in one big plot-----
    # import sys, importlib
    # importlib.reload(sys.modules['GRITI_TEC_keo_fancyPlot_TEC_noiseAllViews'])
    # from GRITI_TEC_keo_fancyPlot_TEC_noiseAllViews import GRITI_TEC_keo_fancyPlot_TEC_noiseAllViews
    GRITI_TEC_keo_fancyPlot_TEC_noiseAllViews(time_Ref, Re,
        geoMap_projectionStyle, BasemapFixDir, 'jet',
        plotLatRange, plotLongRange,  [30,50], [-125,-60],
        plotLatRange_autoTick,plotLongRange_autoTick,plotLongRange_autoTick_Crunched, 
        TEC_timeUnique, data['TEC']['time'], data['TEC']['lat'], data['TEC']['long'], data['TEC']['dTEC'],
        TEC_plotLimValu, noise_background_mean, noise_background_stdev, avgPt_TECnoise_iterations,
        avgPt_pointRadius, avg_anyAngle_45vsLatLong, 'delta-vTEC [TECU]',
        gif_Millstone_Marker, gif_Millstone_Marker_Color, gif_Millstone_Marker_Size,
        dataReject, dataRejectOrig, dataRejectLimit, dataRejectLimitOrig, dataRejectMax,
        Zenith_time, Zenith_height, Zenith_POPL_hp, MISA_time, MISA_height, MISA_POPL_hp,
        pointAltitude, avgPt_ISRavgAlt, filter_cutoffPeriod,
        avgPt_coords,time_cutout_range,dateRange,dateRange_dayNum,dateRange_dayNum_zeroHr,
        dateRange_zeroHr, dateRange_zeroHr_monthName, dateRange_zeroHr_dayPostfix, \
        FONT_grandioseFM, FONT_titleFM,FONT_axisTickFM,FONT_axisTick,FONT_axisLabelFM,
        PLOT_lineWidth, folder, journal_width_2C,journal_height_max,journal_dpi);
    #call the mecha function that plots the avg'd delta-vTEC
#END IF

#==============Analysis: Plot Time Cut-out Keograms of Any Angle AVG==============
if( (FLG_combinedPlot_keo_TEC_n_AMPERE_1Dintegration == 1) & (FLG_avg_anyAngle == 1) ):
    #-----Plot TEC results as a Keogram with AMPERE data as a 2nd-----
    GRITI_combinedPlot_keo_TEC_n_AMPERE_1Dintegration(data['TEC']['keo'],TEC_timeUnique,TEC_plotLimValu, \
         'jet',data['AMPERE'],AMPERE_timeUnique,locAMPERE_time,locAMPERE_lat,locAMPERE_long,AMPERE_plot_index,AMPERE_plot_indexes, \
         AMPERE_plot_labels,FLG_AMPERE_upTo90,plotLatRange,plotLongRange,latMillstone,longMillstone,dateRange_dayNum_zeroHr,avg_anyAngle, \
         settings['TEC']['keo']['width'],settings['TEC']['keo']['keo plot latlong chunks'],settings['TEC']['keo']['keo plot latlong name'],'delta-vTEC', \
         'delta-vTEC [TECU]',time_Ref,time_Reference,dateRange,dateRange_zeroHr,dateRange_zeroHr_monthName, \
         dateRange_zeroHr_dayPostfix,time_cutout_range_delay_AMPERE,PLOT_lineWidth,FONT_titleFM,FONT_axisTick,FONT_axisLabelFM);
    #call the mecha function
#END IF

if( (FLG_combinedPlot_keo_TEC_n_AMPERE_1Dintegration_auroralZone == 1) & (FLG_avg_anyAngle == 1) ):
    #-----Plot TEC results as a Keogram with AMPERE data as a 2nd-----
    GRITI_combinedPlot_keo_TEC_n_AMPERE_1Dintegration_auroralZone(data['TEC']['keo'],TEC_timeUnique,TEC_plotLimValu, \
         'jet',data['AMPERE'],AMPERE_timeUnique,locAMPERE_time,locAMPERE_lat,locAMPERE_long,AMPERE_plot_index,AMPERE_plot_indexes, \
         AMPERE_plot_labels,plotLatRange,plotLongRange,latMillstone,longMillstone,dateRange_dayNum_zeroHr,avg_anyAngle, \
         settings['TEC']['keo']['keo width'],settings['TEC']['keo']['keo plot latlong chunks'],settings['TEC']['keo']['keo plot latlong name'],'delta-vTEC', \
         'delta-vTEC [TECU]',time_Ref,time_Reference,dateRange,dateRange_zeroHr,dateRange_zeroHr_monthName, \
         dateRange_zeroHr_dayPostfix,time_cutout_range_delay_AMPERE,PLOT_lineWidth,FONT_titleFM,FONT_axisTick,FONT_axisLabelFM);
    #call the mecha function
#END IF

if( (FLG_combinedPlot_keo_TEC_n_AMPERE_1Dintegration_auroralZone_spectra == 1) & (FLG_avg_anyAngle == 1) ):
    #-----Plot TEC results as a Keogram with AMPERE data as a 2nd-----
    GRITI_combinedPlot_keo_TEC_n_AMPERE_1Dintegration_auroralZone_spectra(data['TEC']['keo'],TEC_timeUnique,TEC_plotLimValu, \
         'jet',data['AMPERE'],AMPERE_timeUnique,locAMPERE_time,locAMPERE_lat,locAMPERE_long,AMPERE_plot_index,AMPERE_plot_indexes, \
         AMPERE_plot_labels,plotLatRange,plotLongRange,latMillstone,longMillstone,dateRange_dayNum_zeroHr,avg_anyAngle, \
         settings['TEC']['keo']['keo width'],settings['TEC']['keo']['keo plot latlong chunks'],settings['TEC']['keo']['keo plot latlong name'],'delta-vTEC', \
         'delta-vTEC [TECU]',time_Ref,time_Reference,dateRange,dateRange_zeroHr,dateRange_zeroHr_monthName, \
         dateRange_zeroHr_dayPostfix,time_cutout_range_delay_AMPERE,PLOT_lineWidth,FONT_titleFM,FONT_axisTick,FONT_axisLabelFM,settings,FLG_avg_anyAngle_Scargle_FFT);
    #call the mecha function
#END IF

if( (FLG_combinedPlot_keo_TEC_n_AMPERE_1Dintegration_auroralZone_spectra_timeMatch == 1) & (FLG_avg_anyAngle == 1) ):
    AMPERE_data = data['AMPERE'][settings['AMPERE']['data type']]; #get that data out
    
    #Cut AMPERE only b/c TEC is matched in-alg to AMPERE time steps (so having TEC data before/after AMPERE is good so can fill out the edge time slots - and no need to cut now)
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (AMPERE_timeUnique-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range+time_cutout_range_delay_AMPERE) )) == np.abs( (AMPERE_timeUnique-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range+time_cutout_range_delay_AMPERE) ) )[0][0] , \
        np.where(np.min(np.abs( (AMPERE_timeUnique-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range+time_cutout_range_delay_AMPERE) )) == np.abs( (AMPERE_timeUnique-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range+time_cutout_range_delay_AMPERE) ) )[0][0] ) ); #get the indexes for that time cutout range
    
    AMPERE_timeUnique_cutout = AMPERE_timeUnique[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    k = np.in1d(data['AMPERE']['time'],AMPERE_timeUnique_cutout); #get the data points to keep that have the matching times
    AMPERE_data_cutout = AMPERE_data[k,:];
    
    #-----Plot TEC results as a Keogram with AMPERE data as a 2nd-----
    GRITI_combinedPlot_keo_TEC_n_AMPERE_1Dintegration_auroralZone_spectra(data['TEC']['keo'],TEC_timeUnique,TEC_plotLimValu, \
         'jet',AMPERE_data_cutout,AMPERE_timeUnique_cutout,locAMPERE_time,locAMPERE_lat,locAMPERE_long,AMPERE_plot_index,AMPERE_plot_indexes, \
         AMPERE_plot_labels,plotLatRange,plotLongRange,latMillstone,longMillstone,dateRange_dayNum_zeroHr,avg_anyAngle, \
         settings['TEC']['keo']['keo width'],settings['TEC']['keo']['keo plot latlong chunks'],settings['TEC']['keo']['keo plot latlong name'],'delta-vTEC', \
         'delta-vTEC [TECU]',time_Ref,time_Reference,dateRange,dateRange_zeroHr,dateRange_zeroHr_monthName, \
         dateRange_zeroHr_dayPostfix,time_cutout_range_delay_AMPERE,PLOT_lineWidth,FONT_titleFM,FONT_axisTick,FONT_axisLabelFM,settings,FLG_avg_anyAngle_Scargle_FFT);
    #call the mecha function
#END IF

#==============Analysis: stacker time==============
if( FLG_keo_stacker == 1 ):
    TEC_timeUnique_uniqueDays, TEC_timeUnique_uniqueDaysIndex, TEC_timeUNique_uniqueDayCounts = np.unique(np.int64(TEC_timeUnique),return_inverse=True,return_counts=True); #get the unique days and the indexes that get us to them
    
    keo_stackerDaysStacked = TEC_timeUnique_uniqueDays.size; #get the number of days to stack
    keo_stackerTime = np.arange(0,86400,TEC_dataRate); #sec, make a time vector to go with the stacker var
    keo_stackerHolder = np.zeros( (keo_stackerTime.size , data['TEC']['keo'].shape[1], TEC_timeUnique_uniqueDays.size) ); #preallocate
    #STACK EM
    for i in range(0,TEC_timeUnique_uniqueDays.size):
        k = np.where( TEC_timeUnique_uniqueDaysIndex == i )[0]; #get indexes with the first day
        
        keo_stackerHolder[:,:,i] = data['TEC']['keo'][k,:]; #yoink
    #END FOR i
    
    keo_stacker = np.nanmean(keo_stackerHolder,axis=2); #average along the 3rd axis
#END IF

if( FLG_keo_stackerPlot == 1 ):
    #prep to plot, if the colorbar limit is 1 value, make it 2 because it's meant to be a +/-# situation.
    if( np.isscalar(TEC_plotLimValu) == 1 ):
        TEC_plotLimValu = np.array( (-TEC_plotLimValu,TEC_plotLimValu) ); #make it a vector
    #END IF

    #-----Plot TEC results as a Keogram-----
    #Plot just the TEC
    fig, ax = plt.subplots(); #use instead of fig because it inits an axis too (I think I dunno)
    figManager = plt.get_current_fig_manager(); #req to maximize
    figManager.window.showMaximized(); #force maximized
    divider = make_axes_locatable(ax); #prep to add an axis
    cax = divider.append_axes('right', size='2.0%', pad=0.35); #make a color bar axis
    
    #Remove the aspect ratio from the basemap so it fills the screen better
    ax.set_aspect('auto');
    
    pltHelprX, pltHelprY = np.meshgrid( keo_stackerTime/3600, \
                settings['TEC']['keo']['keo plot latlong chunks']);
    im = ax.pcolormesh(pltHelprX, pltHelprY,  keo_stacker.T ,vmin=np.min(TEC_plotLimValu), vmax=np.max(TEC_plotLimValu),cmap=keo_TEC_colorMap); # pseudocolor plot "stretched" to the grid
    cbar = fig.colorbar(im, cax=cax, orientation='vertical'); #create a colorbar using the prev. defined cax
    cax.yaxis.set_ticks(np.linspace(np.min(TEC_plotLimValu),np.max(TEC_plotLimValu),5)); #create useful tick marks
    cax.yaxis.set_major_formatter(FormatStrFormatter('%.2f')); #force a rounded format
    cbar.set_label(keo_TEC_dataName_wUnits); #tabel the colorbar
    cbar.ax.tick_params(labelsize=FONT_axisTick);
    #cbar.set_clim(vmin=np.min(TEC_plotLimValu), vmax=np.max(TEC_plotLimValu)); #they changed how the code works, this doesn't work anymore
    cbar.mappable.set_clim(vmin=np.min(TEC_plotLimValu), vmax=np.max(TEC_plotLimValu)); #now it's this
    cax.yaxis.label.set_font_properties(FONT_axisLabelFM);
    
    #    string_title = 'TEC Averaged on Angle of '+str(np.round(avg_anyAngle,2))+' deg and Width of '+ \
    #        str(np.round(settings['TEC']['keo']['keo width'],2))+' arcdeg, Avg Step # = '+str(avg_anyAngle_N)+ \
    #        ' arcdeg, Line Shows '+settings['TEC']['keo']['keo plot latlong name']+' of Millstone Hill Zenith Beam'; #create mecha title
    string_title = str(keo_stackerDaysStacked)+' Days Stacked | '+keo_TEC_dataName+' Averaged on Angle of '+str(np.round(avg_anyAngle,2))+' deg and Width of '+ \
        str(np.round(settings['TEC']['keo']['keo width'],2))+' arcdeg'; #create mecha title
    ax.set_title(string_title,fontproperties=FONT_titleFM); #set the title
    ax.set_xlabel('Relative time through a day, aligned to 0 UT [hr]',fontproperties=FONT_axisLabelFM); #set the x axis label
    ax.set_ylabel(settings['TEC']['keo']['keo plot latlong name']+' [arcdeg]',fontproperties=FONT_axisLabelFM); #set the y axis label
    
    xAxisTicks = np.arange( np.floor(np.min(keo_stackerTime/3600)), np.ceil(np.max(keo_stackerTime/3600)) + 2 , 2 ); #sets the start hr, stop hr, and the step size between (in this case, 2 hr)
    ax.set_xticks(xAxisTicks); #set x axis ticks
    
    avg_anyAngle_Range_Chunks_Long_Plot_autoTick = (np.ceil(np.max(settings['TEC']['keo']['keo plot latlong chunks'])) - np.floor(np.min(settings['TEC']['keo']['keo plot latlong chunks'])))/13; #tries to split the latitude range into 13 parts (based off of 180/15+1)
    if( avg_anyAngle_Range_Chunks_Long_Plot_autoTick > 25 ):
        avg_anyAngle_Range_Chunks_Long_Plot_autoTick = 30; #sets the tick setting to 15 arcdegrees per tick
    elif( avg_anyAngle_Range_Chunks_Long_Plot_autoTick > 10 ):
        avg_anyAngle_Range_Chunks_Long_Plot_autoTick = 15; #sets the tick setting to 15 arcdegrees per tick
    elif( avg_anyAngle_Range_Chunks_Long_Plot_autoTick > 5 ):
        avg_anyAngle_Range_Chunks_Long_Plot_autoTick = 10; #sets the tick setting to 10 arcdegrees per tick
    elif( avg_anyAngle_Range_Chunks_Long_Plot_autoTick > 2 ):
        avg_anyAngle_Range_Chunks_Long_Plot_autoTick = 5; #sets the tick setting to 5 arcdegrees per tick
    elif( avg_anyAngle_Range_Chunks_Long_Plot_autoTick > 1 ):
        avg_anyAngle_Range_Chunks_Long_Plot_autoTick = 2; #sets the tick setting to 5 arcdegrees per tick
    elif( avg_anyAngle_Range_Chunks_Long_Plot_autoTick >= 0.6 ): #0.6 because 15/25 = 0.6, so there will be enough 1 arcdeg ticks
        avg_anyAngle_Range_Chunks_Long_Plot_autoTick = 1; #                                                        sets the tick setting to 1 arcdegree per tick
    else:
        if(settings['TEC']['keo']['keo plot latlong name'] == 'Latitude'): #if Y axis is latitude, use latitude
            avg_anyAngle_Range_Chunks_Long_Plot_autoTick = (np.max(plotLatRange) - np.min(plotLatRange))/13; #just goes for it if it's a super tiny range
        elif(settings['TEC']['keo']['keo plot latlong name'] == 'Longitude'): #if Y axis is longitude, use longitude
            avg_anyAngle_Range_Chunks_Long_Plot_autoTick = (np.max(plotLongRange) - np.min(plotLongRange))/13; #just goes for it if it's a super tiny range
        #END IF
    #END IF
    yAxisTicks = np.round(np.arange( np.floor(np.min(settings['TEC']['keo']['keo plot latlong chunks'])),np.ceil(np.max(settings['TEC']['keo']['keo plot latlong chunks'])),avg_anyAngle_Range_Chunks_Long_Plot_autoTick ),2); #creates y ticks automagically
    ax.set_yticks(yAxisTicks); #set x axis ticks
    
    #Now drawing line of interest
    if( settings['TEC']['keo']['keo plot latlong name'] == 'Longitude' ): #if true, longitude
        if( (np.min(plotLongRange) <= longMillstone) & (np.max(plotLongRange) >= longMillstone) ): #only plot if it's in the long range specified
            ax.plot( np.linspace(np.floor(np.min(keo_stackerTime/3600)), np.ceil(np.max(keo_stackerTime/3600)), 10, endpoint=True) , #X time hr
                    np.ones(10)*longMillstone , #Y latitude OR longitude arcdeg
                    c='xkcd:black',linewidth=1); #plots a point with a black line
        #END IF
    else: #else latitude
        if( (np.min(plotLatRange) <= latMillstone) & (np.max(plotLatRange) >= latMillstone) ): #only plot if it's in the lat range specified
            ax.plot( np.linspace(np.floor(np.min(keo_stackerTime/3600)), np.ceil(np.max(keo_stackerTime/3600)), 10, endpoint=True) , #X time hr
                    np.ones(10)*latMillstone , #Y latitude OR longitude arcdeg
                    c='xkcd:black',linewidth=1); #plots a point with a black line
        #END IF
    #END IF
    
    ax.set_xlim( (np.floor(np.min(keo_stackerTime/3600)),np.ceil(np.max(keo_stackerTime/3600))) ); #force xlims
    
    fig.subplots_adjust(left = 0.050, right = 0.9375, top = 0.96, bottom = 0.0725); #sets padding to small numbers for minimal white space
    #fig.tight_layout(); #function for a tight layout, doesn't seem to do much here
    plt.show(); #req to make plot show up

#END IF

#==============Analysis: delta-vTEC Double Keo w/ AMPERE==============
if( FLG_doubleKeo == 1 ):
    from subfun_timeMatch import subfun_timeMatch
    from subfun_filter import subfun_filter
    import copy
    
    #----- Unpack -----
    AMPERE_timeUnique = data['AMPERE']['time unique']; #unpack
    AMPERE_data = data['AMPERE']; #unpack
    
    #----- Repack -----
    settings['double keo'] = {}; #prep a dict
    for i in range(0,len(doubleKeo_latLong)):
        settings['double keo'][i] = copy.deepcopy(settings['TEC']['keo']); #copy a dict as a template
        settings['double keo'][i]['keo N'] = doubleKeo_N[i]; #set
        settings['double keo'][i]['keo width orig'] = doubleKeo_width_orig[i]; #set
        settings['double keo'][i]['keo angle'] = doubleKeo_angle_orig[i]; #set
        settings['double keo'][i]['keo 45 lat or long'] = doubleKeo_45vsLatLong[i]; #set
    #END FOR i
    settings_doubleKeo_map = {}; #prep a dict
    for i in range(0,len(doubleKeo_latLong)):
        settings_doubleKeo_map[i] = {}; #prep another dict
        settings_doubleKeo_map[i]['lat range'] = doubleKeo_latLong[i][0]; #set
        settings_doubleKeo_map[i]['long range'] = doubleKeo_latLong[i][1]; #set
        settings_doubleKeo_map[i]['site coords'] = settings_map['site coords']; #set
        settings_doubleKeo_map[i]['lat autotick fancy'] = settings_map['lat autotick fancy']; #set
        settings_doubleKeo_map[i]['projection'] = settings_map['projection']; #set
        settings_doubleKeo_map[i]['site marker type'] = settings_map['site marker type']
        settings_doubleKeo_map[i]['site marker color'] = settings_map['site marker color']
        settings_doubleKeo_map[i]['site marker size'] = settings_map['site marker size']
    #END FOR i
    
    #prep TEC data
    doubleKeo_keo = [[] for jj in range(0,len(doubleKeo_latLong))]; #prep
    doubleKeo_angle = [[] for jj in range(0,len(doubleKeo_latLong))]; #prep
    doubleKeo_width = [[] for jj in range(0,len(doubleKeo_latLong))]; #prep
    doubleKeo_plotSpacing = [[] for jj in range(0,len(doubleKeo_latLong))]; #prep
    doubleKeo_plotSpacingName = [[] for jj in range(0,len(doubleKeo_latLong))]; #prep
    for i in range(0,len(doubleKeo_latLong)):
        (doubleKeo_keo[i], settings['double keo'][i]) = \
        GRITI_keo_keogrammer(data['TEC']['dTEC'] ,data['TEC']['time'], data['TEC']['lat'], data['TEC']['long'],
            TEC_timeUnique, TEC_timeUnique, dates, \
            settings['double keo'][i], settings_paths, settings_doubleKeo_map[i], settings_plot,
            FLG_fancyPlot=FLG_fancyPlot,FLG_disablePlot=2,FLG_disableText=1,FLG_disableCache=0,FLG_useRightExact=0);
        doubleKeo_angle[i] = settings['double keo'][i]['keo angle']; #unpack
        doubleKeo_width[i] = settings['double keo'][i]['keo width']; #unpack
        doubleKeo_plotSpacing[i] = settings['double keo'][i]['keo plot latlong chunks']; #unpack
        doubleKeo_plotSpacingName[i] = settings['double keo'][i]['keo plot latlong name']; #unpack
        # (doubleKeo_keo[i], doubleKeo_angle[i], doubleKeo_width[i], \
        # doubleKeo_plotSpacing[i], doubleKeo_plotSpacingName[i]) = \
        #     GRITI_TEC_keo(doubleKeo_latLong[i][0],doubleKeo_latLong[i][1],TEC_timeUnique,\
        #         TEC_plotLimValu,'jet',data['TEC']['dTEC'],data['TEC']['time'],data['TEC']['lat'],data['TEC']['long'],data['time ref'],doubleKeo_angle_orig[i], \
        #         doubleKeo_N[i],doubleKeo_width_orig[i],doubleKeo_45vsLatLong[i],avgPt_coords,geoMap_projectionStyle,\
        #         dateRange_dayNum_zeroHr,plotLatRange_autoTick,plotLongRange_autoTick,plotLongRange_autoTick_Crunched, gif_Millstone_Marker, gif_Millstone_Marker_Color, \
        #         gif_Millstone_Marker_Size,FONT_titleFM,FONT_axisTick,FONT_axisTickFM,FONT_axisLabelFM,BasemapFixDir,\
        #         'delta-vTEC','delta-vTEC [TECU]',FLG_fancyPlot,PLOT_lineWidth, folder, journal_width_2C,journal_height_max,journal_dpi,\
        #         avg_anyAngle_polarMode=0,FLG_disablePlot=2);
        #         #call the mecha function that runs the keo alg and makes a plot showing the averaging are
    #END FOR i
    
    #prep AMPERE data
    doubleKeo_AMPERE_integrated = [[] for jj in range(0,len(doubleKeo_latLong))]; #prep
    doubleKeo_AMPERE_time = [[] for jj in range(0,len(doubleKeo_latLong))]; #prep
    doubleKeo_AMPERE_timeHr = [[] for jj in range(0,len(doubleKeo_latLong))]; #prep
    
    AMPERE_plot_label = AMPERE_plot_labels[np.where(AMPERE_plot_indexes == AMPERE_plot_index)[0][0]]; #get the label
    AMPERE_plot_label_noUnits = AMPERE_plot_label[0:AMPERE_plot_label.find('[')-1]; #remove the (units)
    
    for i in range(0,len(doubleKeo_latLong)):
        #--- Integrate AMPERE Data ---
        doubleKeo_AMPERE_integrated[i] = GRITI_AMPERE_integrator(data['AMPERE'], dates, settings_AMPERE, doubleKeo_latLong[i][0], doubleKeo_latLong[i][1], FLG_doubleKeo_AMPERE_integrateMethod[i], doubleKeo_AMPERE_integrateMethod_val); #integrate with the integrator function
    
        #--- Filter if req'd ---
        doubleKeo_AMPERE_integrated[i] = subfun_filter( doubleKeo_AMPERE_integrated[i], AMPERE_timeUnique, FLG_doubleKeo_AMPERE_filtMethod, settings_spectra, dataRate = AMPERE_data['data rate']); #filter (or not)
        
        #--- Adjust by the time offset ---
        #Do this before the time matching so everything is well aligned
        if( np.isclose(np.mod(doubleKeo_AMPERE_timeDelay[i]*3600,1),0.0) ):
            doubleKeo_AMPERE_time[i] = AMPERE_timeUnique + np.int32(doubleKeo_AMPERE_timeDelay[i]*3600); #it all stays integers
        else:
            doubleKeo_AMPERE_time[i] = np.float64(AMPERE_timeUnique) + doubleKeo_AMPERE_timeDelay[i]*3600; #it all becomes floats
        #END IF
        
        #--- Time match to 6 minutes if needed ---
        sixMin_timeUnique = np.arange(dates['date range zero hr hour bounds'][0]*3600,dates['date range zero hr hour bounds'][1]*3600,360)+doubleKeo_AMPERE_timeDelay[i]*3600; #sec, arange time stamps in 6 minute steps
        if( np.isclose(AMPERE_data['data rate'],360.) == False ):
            doubleKeo_AMPERE_integrated[i], doubleKeo_AMPERE_time[i] = subfun_timeMatch(doubleKeo_AMPERE_integrated[i], (doubleKeo_AMPERE_time[i] - dateRange_dayNum_zeroHr[1]*86400), sixMin_timeUnique, timeMatch_delta=360., FLG_removeNaNs=0, FLG_useSum=1); #time match alg to align to 6 minute cadence, add because it's a count (?)
            doubleKeo_AMPERE_timeHr[i] = doubleKeo_AMPERE_time[i]/3600; #hr, convert to hr with 0 hr at specified day
        else:
            if( doubleKeo_AMPERE_time[i].size == sixMin_timeUnique.size ):
                if( np.all(np.isclose((doubleKeo_AMPERE_time[i] - dateRange_dayNum_zeroHr[1]*86400),sixMin_timeUnique)) ):
                    doubleKeo_AMPERE_timeHr[i] = (doubleKeo_AMPERE_time[i] - dateRange_dayNum_zeroHr[1]*86400)/3600; #hr, convert to hr with 0 hr at specified day
                else:
                    doubleKeo_AMPERE_integrated[i], doubleKeo_AMPERE_time[i] = subfun_timeMatch(doubleKeo_AMPERE_integrated[i], (doubleKeo_AMPERE_time[i] - dateRange_dayNum_zeroHr[1]*86400), sixMin_timeUnique, timeMatch_delta=360., FLG_removeNaNs=0, FLG_useSum=1); #time match alg to align to 6 minute cadence, add because it's a count (?)
                    doubleKeo_AMPERE_timeHr[i] = (doubleKeo_AMPERE_time[i] - dateRange_dayNum_zeroHr[1]*86400)/3600; #hr, convert to hr with 0 hr at specified day                #END IF
                #END IF
            else:
                doubleKeo_AMPERE_integrated[i], doubleKeo_AMPERE_time[i] = subfun_timeMatch(doubleKeo_AMPERE_integrated[i], (doubleKeo_AMPERE_time[i] - dateRange_dayNum_zeroHr[1]*86400), sixMin_timeUnique, timeMatch_delta=360., FLG_removeNaNs=0, FLG_useSum=1); #time match alg to align to 6 minute cadence, add because it's a count (?)
                doubleKeo_AMPERE_timeHr[i] = (doubleKeo_AMPERE_time[i] - dateRange_dayNum_zeroHr[1]*86400)/3600; #hr, convert to hr with 0 hr at specified day            #END IF
            #END IF
        #END IF
    #END FOR i
    
    data['double keo'] = {
        'keo':doubleKeo_keo,
        'lat long':doubleKeo_latLong,
        'angle':doubleKeo_angle,
        'width':doubleKeo_width,
        'plot spacing':doubleKeo_plotSpacing,
        'plot spacing name':doubleKeo_plotSpacingName,
        'AMPERE integrated':doubleKeo_AMPERE_integrated,
        'AMPERE time':doubleKeo_AMPERE_time,
        'AMPERE time hr':doubleKeo_AMPERE_timeHr,
        };
#END IF

if( FLG_doubleKeo_plot == 1 ):
    from matplotlib.patches import ConnectionPatch, Rectangle
    from subfun_timeMatch import subfun_timeMatch
    from subfun_figFitter import figFitter
    from subfun_filter import subfun_filter
    from subfun_sunAlsoRises import sunAlsoRises
    from subfun_date_to_dayNum import subfun_date_to_dayNum
    import copy
    
    #-----Plot TEC results as a Keogram w/ AMPERE integrated line as well-----
    #Prep the plot
    fig, ax = plt.subplots(nrows=len(doubleKeo_latLong), ncols=1); #use instead of fig because it inits an axis too (I think I dunno)
    figManager = plt.get_current_fig_manager(); #req to maximize
    figManager.window.showMaximized(); #force maximized
    axTwinx = []; #prep this list, holds the twinx axes, will grow as we plot
    cax = []; #prep
    caxTwinx = []; #prep
    for i in range(0,len(doubleKeo_latLong)):
        divider = make_axes_locatable(ax[i]); #prep to add an axis
        cax.append(divider.append_axes('right', size='2.0%', pad=1.75)); #make a color bar axis, append
        
        #Remove the aspect ratio from the basemap so it fills the screen better
        ax[i].set_aspect('auto');
        
        #-----Plot TEC results as a keogram-----
        pltHelprX, pltHelprY = np.meshgrid( (TEC_timeUnique - dateRange_dayNum_zeroHr[1]*86400)/3600, \
                    doubleKeo_plotSpacing[i]);
        im = ax[i].pcolormesh(pltHelprX, pltHelprY,  doubleKeo_keo[i].T ,vmin=np.min(settings['TEC']['plot lim']), vmax=np.max(settings['TEC']['plot lim']),cmap=settings['TEC']['colormap']); # pseudocolor plot "stretched" to the grid
        cbar = fig.colorbar(im, cax=cax[i], orientation='vertical'); #create a colorbar using the prev. defined cax
        cbar.set_label(settings['TEC']['name']+settings['TEC']['units']); #tabel the colorbar
        cbar.ax.tick_params(labelsize=FONT_axisTick);
        #cbar.set_clim(vmin=np.min(settings['TEC']['plot lim']), vmax=np.max(settings['TEC']['plot lim'])); #they changed how the code works, this doesn't work anymore
        cbar.mappable.set_clim(vmin=np.min(settings['TEC']['plot lim']), vmax=np.max(settings['TEC']['plot lim'])); #now it's this
        cax[i].yaxis.set_ticks(np.linspace(np.min(settings['TEC']['plot lim']),np.max(settings['TEC']['plot lim']),5)); #create useful tick marks
        cax[i].yaxis.set_major_formatter(FormatStrFormatter('%.2f')); #force a rounded format
        cax[i].yaxis.label.set_font_properties(FONT_axisLabelFM);
        
        #-----Plot AMPERE results as a 1D line-----
        axTwinx.append(ax[i].twinx()); #add on the new twinx axis
        doubleKeo_AMPERE_integrated_plot = np.copy(doubleKeo_AMPERE_integrated[i]); #copy
        if( doubleKeo_AMPERE_plotLim != False ):
            doubleKeo_AMPERE_integrated_plot[ doubleKeo_AMPERE_integrated_plot > doubleKeo_AMPERE_plotLim ] = doubleKeo_AMPERE_plotLim; #cap the max val
        #END IF
        axTwinx[i].plot( doubleKeo_AMPERE_timeHr[i], doubleKeo_AMPERE_integrated_plot , linewidth=settings['plot']['line width']['regular'] , color='xkcd:violet'); #plot
        axTwinx[i].set_ylabel(AMPERE_plot_label,fontproperties=FONT_axisLabelFM); #set the y axis label
        #now adjust the ylim so the lines are about where we want them to be
        lineOfInterestLoc = (doubleKeo_AMPERE_latAlign[i]-np.min(doubleKeo_latLong[i][0]))/(np.max(doubleKeo_latLong[i][0])-np.min(doubleKeo_latLong[i][0])); #get line of interest location on TEC keogram in a form of 1 to 0
        twinx_valAtLineOfInterest = np.mean(doubleKeo_AMPERE_integrated_plot) + 1.5*np.std(doubleKeo_AMPERE_integrated_plot); #this is the value we want to align with the line of interest
        twinx_minToAlign = (lineOfInterestLoc*np.max(doubleKeo_AMPERE_integrated_plot) - twinx_valAtLineOfInterest)/(lineOfInterestLoc - 1); #calc the min to get that value at the LOI
        axTwinx[i].set_ylim( twinx_minToAlign , np.max(doubleKeo_AMPERE_integrated_plot) ); #set y axis limits
        
        #this is to keep plotting similar
        dividerTwinx = make_axes_locatable(axTwinx[i]); #prep to add an axis
        caxTwinx.append(dividerTwinx.append_axes('right', size='2.0%', pad=1.75)); #make a color bar axis, append
        caxTwinx[i].set_visible(False); #mkae it invisible so it matches the other plots in width
        
        xAxisTicksStep = 4; #hr, hour steps between each x axis tick
        xAxisTicks = np.arange( (np.round((np.min(TEC_timeUnique)-dateRange_dayNum_zeroHr[1]*86400)/3600) - np.mod(np.round((np.min(TEC_timeUnique)-dateRange_dayNum_zeroHr[1]*86400)/3600), xAxisTicksStep)) , \
            (np.round((np.max(TEC_timeUnique)-dateRange_dayNum_zeroHr[1]*86400)/3600) - np.mod(np.round((np.max(TEC_timeUnique)-dateRange_dayNum_zeroHr[1]*86400)/3600),xAxisTicksStep)) + xAxisTicksStep , \
            xAxisTicksStep); #sets the start hr, stop hr, and the step size between (in this case, 4 hr)
        ax[i].set_xticks(xAxisTicks); #set x axis ticks
        ax[i].set_xlim( np.min(xAxisTicks) , np.max(xAxisTicks) ); #set x axis limits
        axTwinx[i].set_xlim( np.min(xAxisTicks) , np.max(xAxisTicks) ); #set x axis limits
        
        #adjust the tick marks
        # tickzLim = 40*np.median(doubleKeo_AMPERE_integrated[i]); #get the median*40 of the integrated JH
        tickz = axTwinx[i].get_yticks(); #get the ticks
        # tickz = tickz[ (tickz < tickzLim) & (tickz >= 0) ]; #get only the tickz we want
        tickz = tickz[ (tickz >= 0) ]; #get only the tickz we want
        axTwinx[i].set_yticks(tickz); #set the ticks
        
        #----- Plot Shading to represent 'night' -----
        if( doubleKeo_niteTimes[0] == False ):
            if( doubleKeo_plotSpacingName[i] == 'Latitude' ): #if true, latitude
                if( doubleKeo_AMPERE_latAlign[i] > 50 ):
                    latToUse = 50; #cap at 50 deg lat to keep it from getting too zesty at the poles
                else:
                    latToUse = doubleKeo_AMPERE_latAlign[i];
                #END IF
                (doubleKeo_niteTimes_sunRise, doubleKeo_niteTimes_sunSet, doubleKeo_dateRange_fullPad) = sunAlsoRises(dateRange_full,latToUse,np.mean(doubleKeo_latLong[i][1])); #call sunrise/set function
            else:
                (doubleKeo_niteTimes_sunRise, doubleKeo_niteTimes_sunSet, doubleKeo_dateRange_fullPad) = sunAlsoRises(dateRange_full,np.mean(doubleKeo_latLong[i][0]),doubleKeo_AMPERE_latAlign[i]); #call sunrise/set function
            #END IF
            doubleKeo_dateRange_dayNum_fullPad = subfun_date_to_dayNum(doubleKeo_dateRange_fullPad); #convert to dayNum
            doubleKeo_niteTimes_sunRise = (doubleKeo_niteTimes_sunRise + doubleKeo_dateRange_dayNum_fullPad[:,1] - dateRange_dayNum_zeroHr[1])*24; #hrs, center around zero hr and convert ot hrs
            doubleKeo_niteTimes_sunSet = (doubleKeo_niteTimes_sunSet + doubleKeo_dateRange_dayNum_fullPad[:,1] - dateRange_dayNum_zeroHr[1])*24; #hrs, center around zero hr and convert ot hrs
            doubleKeo_niteTimes_sunRise = doubleKeo_niteTimes_sunRise[1:]; #remove 1st
            doubleKeo_niteTimes_sunSet = doubleKeo_niteTimes_sunSet[:-1]; #remove last
            #FIFTH STEP: PLOT THIS STUFF
            for j in range(0,doubleKeo_niteTimes_sunSet.size):
                # ax[i].axvspan(doubleKeo_AMPERE_niteTimes_array[j,0], doubleKeo_AMPERE_niteTimes_array[j,1], alpha=0.25, color='xkcd:black');
                if(doubleKeo_plotSpacingName[i] == 'Latitude'): #if Y axis is latitude, use latitude
                    recta = Rectangle((doubleKeo_niteTimes_sunSet[j], np.min(doubleKeo_latLong[i][0])), doubleKeo_niteTimes_sunRise[j]-doubleKeo_niteTimes_sunSet[j], np.diff(doubleKeo_latLong[i][0]).item(), edgecolor='xkcd:black', facecolor='xkcd:black', alpha=0.25); #make that patch
                    ax[i].add_patch(recta); #add on that patch
                else: #otherwise longitude
                    recta = Rectangle((doubleKeo_niteTimes_sunSet[j], np.min(doubleKeo_latLong[i][1])), doubleKeo_niteTimes_sunRise[j]-doubleKeo_niteTimes_sunSet[j], np.diff(doubleKeo_latLong[i][1]).item(), edgecolor='xkcd:black', facecolor='xkcd:black', alpha=0.25); #make that patch
                    ax[i].add_patch(recta); #add on that patch
                #END IF
            #END FOR j
        else:
            for j in range(0,dates['date range zero hr hours'].size):
                doubleKeo_niteTimes_per = dates['date range zero hr hours'][j] + np.asarray(doubleKeo_niteTimes[i]); #get the nite time ranges
                if(doubleKeo_plotSpacingName[i] == 'Latitude'): #if Y axis is latitude, use latitude
                    recta = Rectangle((doubleKeo_niteTimes_per[0], np.min(doubleKeo_latLong[i][0])), np.diff(doubleKeo_niteTimes_per).item(), np.diff(doubleKeo_latLong[i][0]).item(), edgecolor='xkcd:black', facecolor='xkcd:black', alpha=0.25); #make that patch
                    ax[i].add_patch(recta); #add on that patch
                else: #otherwise longitude
                    recta = Rectangle((doubleKeo_niteTimes_per[0], np.min(doubleKeo_latLong[i][1])), np.diff(doubleKeo_niteTimes_per).item(), np.diff(doubleKeo_latLong[i][1]).item(), edgecolor='xkcd:black', facecolor='xkcd:black', alpha=0.25); #make that patch
                    ax[i].add_patch(recta); #add on that patch
                #END IF
            #END FOR j
        #END IF
        
        string_title = settings['TEC']['name']+' Keo Angle of '+str(np.round(doubleKeo_angle_orig[i],2))+' deg & Width of '+ \
            str(np.round(doubleKeo_width[i],2))+' arcdeg | Integrated '+AMPERE_plot_label_noUnits; #create mecha title
        if( FLG_doubleKeo_AMPERE_integrateMethod[i] == 0 ):
            string_title = string_title + ' within keo area'; #add to mecha title
        elif( FLG_doubleKeo_AMPERE_integrateMethod[i] == 1 ):
            string_title = string_title + ' within keo long & up to pole'; #add to mecha title
        elif( FLG_doubleKeo_AMPERE_integrateMethod[i] == 2 ):
            string_title = string_title + ' within keo long & up to '+str(doubleKeo_AMPERE_integrateMethod_val)+' degc lat'; #add to mecha title
        elif( FLG_doubleKeo_AMPERE_integrateMethod[i] == 3 ):
            if( (np.min(plotLatRange) <= 0) & (np.max(plotLatRange) >= 0) ):
                string_title = string_title + ' both Hemispheres'; #add to mecha title
            else:
                if( (np.min(plotLatRange) >= 0) & (np.max(plotLatRange) >= 0) ):
                    #northern hemisphere
                    string_title = string_title + ' Northern Hemisphere'; #add to mecha title
                else:
                    #southern hemisphere
                    string_title = string_title + ' Southern Hemisphere'; #add to mecha title
                #END IF
            #END IF
        #END IF
        string_title = string_title + ' w/ time delay of '+str(doubleKeo_AMPERE_timeDelay[i])+' hrs';
        ax[i].set_title(string_title,fontproperties=FONT_titleFM); #set the title
        if( i == len(doubleKeo_latLong)-1 ):
            ax[i].set_xlabel('Time in UT - 0 Hr on Day '+str(dateRange_dayNum_zeroHr[1])+', '+str(dateRange_dayNum_zeroHr[0])+' [hr]',fontproperties=FONT_axisLabelFM); #set the x axis label
        #END IF
        ax[i].set_ylabel(doubleKeo_plotSpacingName[i]+' [arcdeg]',fontproperties=FONT_axisLabelFM); #set the y axis label
        
        autoTick = (np.ceil(np.max(doubleKeo_plotSpacing[i])) - np.floor(np.min(doubleKeo_plotSpacing[i])))/13; #tries to split the latitude range into 13 parts (based off of 180/15+1)
        if( autoTick > 25 ):
            autoTick = 30; #sets the tick setting to 15 arcdegrees per tick
        elif( autoTick > 10 ):
            autoTick = 15; #sets the tick setting to 15 arcdegrees per tick
        elif( autoTick > 5 ):
            autoTick = 10; #sets the tick setting to 10 arcdegrees per tick
        elif( autoTick > 2 ):
            autoTick = 5; #sets the tick setting to 5 arcdegrees per tick
        elif( autoTick > 1 ):
            autoTick = 2; #sets the tick setting to 5 arcdegrees per tick
        elif( autoTick >= 0.6 ): #0.6 because 15/25 = 0.6, so there will be enough 1 arcdeg ticks
            autoTick = 1; #                                                        sets the tick setting to 1 arcdegree per tick
        else:
            if(doubleKeo_plotSpacingName[i] == 'Latitude'): #if Y axis is latitude, use latitude
                autoTick = (np.max(doubleKeo_latLong[i][0]) - np.min(doubleKeo_latLong[i][0]))/13; #just goes for it if it's a super tiny range
            elif(doubleKeo_plotSpacingName[i] == 'Longitude'): #if Y axis is longitude, use longitude
                autoTick = (np.max(doubleKeo_latLong[i][1]) - np.min(doubleKeo_latLong[i][1]))/13; #just goes for it if it's a super tiny range
            #END IF
        #END IF
        yAxisTicks = np.round(np.arange( np.floor(np.min(doubleKeo_plotSpacing[i])),np.ceil(np.max(doubleKeo_plotSpacing[i])),autoTick ),2); #creates y ticks automagically
        ax[i].set_yticks(yAxisTicks); #set x axis ticks
        
        #Now drawing line of interest
        if( doubleKeo_plotSpacingName[i] == 'Latitude' ): #if true, latitude
            if( (np.min(doubleKeo_latLong[i][0]) <= doubleKeo_AMPERE_latAlign[i]) & (np.max(doubleKeo_latLong[i][0]) >= doubleKeo_AMPERE_latAlign[i]) ): #only plot if it's in the lat range specified
                ax[i].plot( np.linspace(np.min((TEC_timeUnique - dateRange_dayNum_zeroHr[1]*86400)/3600),np.max((TEC_timeUnique - dateRange_dayNum_zeroHr[1]*86400)/3600),10,endpoint=True) , #X time hr
                    np.tile(doubleKeo_AMPERE_latAlign[i],10) , #Y latitude OR longitude arcdeg
                    c='xkcd:black',linewidth=settings['plot']['line width']['smol']); #plots a point with a black line
            #END IF
        else:
            if( (np.min(doubleKeo_latLong[i][1]) <= doubleKeo_AMPERE_latAlign[i]) & (np.max(doubleKeo_latLong[i][1]) >= doubleKeo_AMPERE_latAlign[i]) ): #only plot if it's in the lat range specified
                ax[i].plot( np.linspace(np.min((TEC_timeUnique - dateRange_dayNum_zeroHr[1]*86400)/3600),np.max((TEC_timeUnique - dateRange_dayNum_zeroHr[1]*86400)/3600),10,endpoint=True) , #X time hr
                    np.tile(doubleKeo_AMPERE_latAlign[i],10) , #Y latitude OR longitude arcdeg
                    c='xkcd:black',linewidth=settings['plot']['line width']['smol']); #plots a point with a black line
            #END IF
        #END IF
    #END FOR i
    
    #-----Draw line from 1st TEC event to 2nd-----
    if( (doubleKeo_arrowTimes[0] >= np.min((TEC_timeUnique - dateRange_dayNum_zeroHr[1]*86400)/3600)) & \
        (doubleKeo_arrowTimes[1] <= np.max((TEC_timeUnique - dateRange_dayNum_zeroHr[1]*86400)/3600)) ):
        con = ConnectionPatch(xyA=(doubleKeo_arrowTimes[0],doubleKeo_AMPERE_latAlign[0]), coordsA=ax[0].transData,
                              xyB=(doubleKeo_arrowTimes[1],doubleKeo_AMPERE_latAlign[1]), coordsB=ax[1].transData,
                              arrowstyle="-|>", shrinkA=5, shrinkB=5,mutation_scale=20, fc="xkcd:pink",
                              color='xkcd:pink', linewidth=settings['plot']['line width']['double plus']); #prep a line between plots
        fig.add_artist(con); #draw the line
    #END IF
    
    # figFitter(fig); #fit the fig fast [title's too long for this]
    fig.subplots_adjust(left = 0.055, right = 0.935, top = 0.96, bottom = 0.075, hspace = 0.18); #sets padding to small numbers for minimal white space
    #fig.tight_layout(); #function for a tight layout, doesn't seem to do much here
    plt.show(); #req to make plot show up
#END IF

#==============Analysis: delta-vTEC Double Keo w/ AMPERE==============
if( FLG_doubleKeo_plot == 2 ): #mode 2 makes the two keograms meet at a shared latitude/longitude
    from matplotlib.patches import ConnectionPatch, Rectangle
    from subfun_timeMatch import subfun_timeMatch
    from subfun_figFitter import figFitter
    from subfun_filter import subfun_filter
    from subfun_sunAlsoRises import sunAlsoRises
    from subfun_date_to_dayNum import subfun_date_to_dayNum
    import copy
        
    #-----Plot TEC results as a Keogram w/ AMPERE integrated line as well-----
    #Prep the plot
    fig, ax = plt.subplots(nrows=1, ncols=1); #use instead of fig because it inits an axis too (I think I dunno)
    figManager = plt.get_current_fig_manager(); #req to maximize
    figManager.window.showMaximized(); #force maximized
    axTwinx = []; #prep this list, holds the twinx axes, will grow as we plot
    # cax = []; #prep
    caxTwinx = []; #prep
    divider = make_axes_locatable(ax); #prep to add an axis
    cax = divider.append_axes('right', size='2.0%', pad=1.75); #make a color bar axis, append [0.35]
    # dividerTwinx = make_axes_locatable(axTwinx); #prep to add an axis
    # caxTwinx = dividerTwinx.append_axes('right', size='2.0%', pad=1.75); #make a color bar axis, append
    # caxTwinx.set_visible(False); #mkae it invisible so it matches the other plots in width
    
    #Remove the aspect ratio from the basemap so it fills the screen better
    ax.set_aspect('auto');
    for i in range(0,len(doubleKeo_latLong)):
        #-----Plot TEC results as a keogram-----
        pltHelprX, pltHelprY = np.meshgrid( (TEC_timeUnique - dateRange_dayNum_zeroHr[1]*86400)/3600, \
                    doubleKeo_plotSpacing[i]);
        im = ax.pcolormesh(pltHelprX, pltHelprY,  doubleKeo_keo[i].T ,vmin=np.min(settings['TEC']['plot lim']), vmax=np.max(settings['TEC']['plot lim']),cmap=settings['TEC']['colormap'],zorder=i); # pseudocolor plot "stretched" to the grid
    #END FOR i
        
    cbar = fig.colorbar(im, cax=cax, orientation='vertical'); #create a colorbar using the prev. defined cax
    cbar.set_label(settings['TEC']['name']+settings['TEC']['units']); #tabel the colorbar
    cbar.ax.tick_params(labelsize=FONT_axisTick);
    #cbar.set_clim(vmin=np.min(settings['TEC']['plot lim']), vmax=np.max(settings['TEC']['plot lim'])); #they changed how the code works, this doesn't work anymore
    cbar.mappable.set_clim(vmin=np.min(settings['TEC']['plot lim']), vmax=np.max(settings['TEC']['plot lim'])); #now it's this
    cax.yaxis.set_ticks(np.linspace(np.min(settings['TEC']['plot lim']),np.max(settings['TEC']['plot lim']),5)); #create useful tick marks
    cax.yaxis.set_major_formatter(FormatStrFormatter('%.2f')); #force a rounded format
    cax.yaxis.label.set_font_properties(FONT_axisLabelFM);
    
    #----- Draw lines of separation between the keograms -----
    doubleKeo_alignments_limits = np.empty(doubleKeo_alignments.size+2); #preallocate
    for i in range(0,doubleKeo_alignments.size):
        ax.plot( np.array( (np.min((TEC_timeUnique - dateRange_dayNum_zeroHr[1]*86400)/3600),np.max((TEC_timeUnique - dateRange_dayNum_zeroHr[1]*86400)/3600)) ), \
                np.ones(2)*doubleKeo_alignments[i],
                c='xkcd:pastel purple',linewidth=settings['plot']['line width']['thicc'],linestyle='-.'); #plots a point with a black line
        plt.pause(0.0001); #another pause needed to make matplotlib work
        doubleKeo_alignments_limits[i+1] = ax.transLimits.transform((1,doubleKeo_alignments[i]))[1]; #get the position of the split in axis units
    #END FOR i
    doubleKeo_alignments_limits[0] = 1; #these are known
    doubleKeo_alignments_limits[-1] = 0; #these are known
    
    #!! hindsight: solve this with 2 separate plots that have no spacing between them !!
    
    for i in range(0,len(doubleKeo_latLong)):
        # -----Plot AMPERE results as a 1D line -----
        axTwinx.append(ax.twinx()); #add on the new twinx axis
        doubleKeo_AMPERE_integrated_plot = np.copy(doubleKeo_AMPERE_integrated[i]); #copy
        if( doubleKeo_AMPERE_plotLim != False ):
            doubleKeo_AMPERE_integrated_plot[ doubleKeo_AMPERE_integrated_plot > doubleKeo_AMPERE_plotLim ] = doubleKeo_AMPERE_plotLim; #cap the max val
        #END IF
        axTwinx[i].plot( doubleKeo_AMPERE_timeHr[i], doubleKeo_AMPERE_integrated_plot , linewidth=settings['plot']['line width']['regular'] , color='xkcd:violet',zorder=i); #plot
        if( i == len(doubleKeo_latLong)-1 ):
            axTwinx[i].set_ylabel(AMPERE_plot_label,fontproperties=FONT_axisLabelFM); #set the y axis label
        #END IF
        
        #now adjust the ylim so the lines are about where we want them to be
        # #--- Adjust yLim max to be at the right place --- (turns out can't do both at once since they're linked - so gotta... solve)
        # twinx_yFactor = 1 - (doubleKeo_alignments_limits[i] - axTwinx[i].transLimits.transform((1,np.max(doubleKeo_AMPERE_integrated[i])))[1]); #get a factor
        # twinx_yLims = np.array( axTwinx[i].get_ylim() ); #get the ylims
        # twinx_yLims[1] = np.max(doubleKeo_AMPERE_integrated[i])/doubleKeo_alignments_limits[i]-(twinx_yLims[0]*(1-doubleKeo_alignments_limits[i]))*2; #solving this is nasty I'm not big brain here
        # axTwinx[i].set_ylim(twinx_yLims); #apply the new ylim because it adjusts the next thing
        
        # #--- Adjust yLim min to align the data on the line of interest ---
        # lineOfInterestLoc = (doubleKeo_alignments_limits[i]-doubleKeo_alignments_limits[i+1])*(doubleKeo_AMPERE_latAlign[i]-np.min(doubleKeo_latLongComb[i]))/(np.max(doubleKeo_latLongComb[i])-np.min(doubleKeo_latLongComb[i]))+doubleKeo_alignments_limits[i+1]; #get line of interest location on TEC keogram in a form of 1 to 0 (scaled by the keogram plot-within-plots)
        # twinx_valAtLineOfInterest = np.mean(doubleKeo_AMPERE_integrated[i]) + 1.5*np.std(doubleKeo_AMPERE_integrated[i]); #this is the value we want to align with the line of interest
        # twinx_minToAlign = (lineOfInterestLoc*twinx_yLims[1] - twinx_valAtLineOfInterest)/(lineOfInterestLoc - 1); #calc the min to get that value at the LOI
        # axTwinx[i].set_ylim( twinx_minToAlign , twinx_yLims[1] ); #set y axis limits
        
        #--- I had to do actual algebra for this (combined two equations above) ---
        twinx_yLims = np.array( axTwinx[i].get_ylim() ); #get the ylims
        lim1 = doubleKeo_alignments_limits[i]; #get the upper limit in axis units
        yMax = np.nanmax(doubleKeo_AMPERE_integrated_plot); #get the desired yMax
        yMin = twinx_yLims[0]; #get the current yMin
        lim2 = (doubleKeo_alignments_limits[i]-doubleKeo_alignments_limits[i+1])*(doubleKeo_AMPERE_latAlign[i]-np.min(doubleKeo_latLongComb[i]))/(np.max(doubleKeo_latLongComb[i])-np.min(doubleKeo_latLongComb[i]))+doubleKeo_alignments_limits[i+1]; #get line of interest location on TEC keogram in a form of 1 to 0 (scaled by the keogram plot-within-plots)
        yGoal = np.nanmean(doubleKeo_AMPERE_integrated_plot) + 1.5*np.nanstd(doubleKeo_AMPERE_integrated_plot); #this is the value we want to align with the line of interest
        
        #--- Calc the yLim Max and Min ---
        twinx_yLims = np.array( axTwinx[i].get_ylim() ); #get the ylims
        twinx_yLims[1] = (yMax/lim1 + 2*yGoal/(lim2-1)*(1-lim1))/(1+2*lim2/(lim2-1)*(1-lim1)); #calc max limit
        twinx_yLims[0] = (lim2*twinx_yLims[1] - yGoal)/(lim2-1); #calc min limit
        axTwinx[i].set_ylim( twinx_yLims ); #set y axis limits
        # #alignment check
        # ax.transLimits.transform((1,doubleKeo_AMPERE_latAlign[i]))[1]
        # axTwinx[i].transLimits.transform((1,twinx_valAtLineOfInterest))[1]
        
        #this is to keep plotting similar
        dividerTwinx = make_axes_locatable(axTwinx[i]); #prep to add an axis
        caxTwinx.append(dividerTwinx.append_axes('right', size='2.0%', pad=1.75)); #make a color bar axis, append
        caxTwinx[i].set_visible(False); #mkae it invisible so it matches the other plots in width
        
        xAxisTicksStep = 4; #hr, hour steps between each x axis tick
        xAxisTicks = np.arange( (np.round((np.min(TEC_timeUnique)-dateRange_dayNum_zeroHr[1]*86400)/3600) - np.mod(np.round((np.min(TEC_timeUnique)-dateRange_dayNum_zeroHr[1]*86400)/3600), xAxisTicksStep)) , \
            (np.round((np.max(TEC_timeUnique)-dateRange_dayNum_zeroHr[1]*86400)/3600) - np.mod(np.round((np.max(TEC_timeUnique)-dateRange_dayNum_zeroHr[1]*86400)/3600),xAxisTicksStep)) + xAxisTicksStep , \
            xAxisTicksStep); #sets the start hr, stop hr, and the step size between (in this case, 4 hr)
        ax.set_xticks(xAxisTicks); #set x axis ticks
        ax.set_xlim( np.min(xAxisTicks) , np.max(xAxisTicks) ); #set x axis limits
        axTwinx[i].set_xlim( np.min(xAxisTicks) , np.max(xAxisTicks) ); #set x axis limits
        
        #adjust the tick marks
        # tickzLim = 40*np.median(doubleKeo_AMPERE_integrated[i]); #get the median*40 of the integrated JH
        tickz = axTwinx[i].get_yticks(); #get the ticks
        # tickz = tickz[ (tickz < tickzLim) & (tickz >= 0) ]; #get only the tickz we want
        tickzPos = axTwinx[i].transLimits.transform(np.vstack( (np.ones(tickz.size), tickz) ).T)[:,1]; #get the tickz positions on the plot
        tickz = tickz[ (tickz >= 0) & (doubleKeo_alignments_limits[i] >= tickzPos) & (doubleKeo_alignments_limits[i+1] <= tickzPos) ]; #make sure the ticks fall within the keogram area and they're positive
        axTwinx[i].set_yticks(tickz); #set the ticks
        
        #----- Plot Shading to represent 'night' -----
        if( doubleKeo_niteTimes[0] == False ):
            if( doubleKeo_plotSpacingName[i] == 'Latitude' ): #if true, latitude
                if( doubleKeo_AMPERE_latAlign[i] > 50 ):
                    latToUse = 50; #cap at 50 deg lat to keep it from getting too zesty at the poles
                else:
                    latToUse = doubleKeo_AMPERE_latAlign[i];
                #END IF
                (doubleKeo_niteTimes_sunRise, doubleKeo_niteTimes_sunSet, doubleKeo_dateRange_fullPad) = sunAlsoRises(dateRange_full,latToUse,np.mean(doubleKeo_latLong[i][1])); #call sunrise/set function
            else:
                (doubleKeo_niteTimes_sunRise, doubleKeo_niteTimes_sunSet, doubleKeo_dateRange_fullPad) = sunAlsoRises(dateRange_full,np.mean(doubleKeo_latLong[i][0]),doubleKeo_AMPERE_latAlign[i]); #call sunrise/set function
            #END IF
            doubleKeo_dateRange_dayNum_fullPad = subfun_date_to_dayNum(doubleKeo_dateRange_fullPad); #convert to dayNum
            doubleKeo_niteTimes_sunRise = (doubleKeo_niteTimes_sunRise + doubleKeo_dateRange_dayNum_fullPad[:,1] - dateRange_dayNum_zeroHr[1])*24; #hrs, center around zero hr and convert ot hrs
            doubleKeo_niteTimes_sunSet = (doubleKeo_niteTimes_sunSet + doubleKeo_dateRange_dayNum_fullPad[:,1] - dateRange_dayNum_zeroHr[1])*24; #hrs, center around zero hr and convert ot hrs
            doubleKeo_niteTimes_sunRise = doubleKeo_niteTimes_sunRise[1:]; #remove 1st
            doubleKeo_niteTimes_sunSet = doubleKeo_niteTimes_sunSet[:-1]; #remove last
            #FIFTH STEP: PLOT THIS STUFF
            for j in range(0,doubleKeo_niteTimes_sunSet.size):
                # ax.axvspan(doubleKeo_AMPERE_niteTimes_array[j,0], doubleKeo_AMPERE_niteTimes_array[j,1], alpha=0.25, color='xkcd:black');
                if(doubleKeo_plotSpacingName[i] == 'Latitude'): #if Y axis is latitude, use latitude
                    recta = Rectangle((doubleKeo_niteTimes_sunSet[j], np.min(doubleKeo_latLong[i][0])), doubleKeo_niteTimes_sunRise[j]-doubleKeo_niteTimes_sunSet[j], np.diff(doubleKeo_latLong[i][0]).item(), edgecolor='xkcd:black', facecolor='xkcd:black', alpha=0.25); #make that patch
                    ax.add_patch(recta); #add on that patch
                else: #otherwise longitude
                    recta = Rectangle((doubleKeo_niteTimes_sunSet[j], np.min(doubleKeo_latLong[i][1])), doubleKeo_niteTimes_sunRise[j]-doubleKeo_niteTimes_sunSet[j], np.diff(doubleKeo_latLong[i][1]).item(), edgecolor='xkcd:black', facecolor='xkcd:black', alpha=0.25); #make that patch
                    ax.add_patch(recta); #add on that patch
                #END IF
            #END FOR j
        else:
            for j in range(0,dates['date range zero hr hours'].size):
                doubleKeo_niteTimes_per = dates['date range zero hr hours'][j] + np.asarray(doubleKeo_niteTimes[i]); #get the nite time ranges
                if(doubleKeo_plotSpacingName[i] == 'Latitude'): #if Y axis is latitude, use latitude
                    recta = Rectangle((doubleKeo_niteTimes_per[0], np.min(doubleKeo_latLong[i][0])), np.diff(doubleKeo_niteTimes_per).item(), np.diff(doubleKeo_latLong[i][0]).item(), edgecolor='xkcd:black', facecolor='xkcd:black', alpha=0.25); #make that patch
                    ax.add_patch(recta); #add on that patch
                else: #otherwise longitude
                    recta = Rectangle((doubleKeo_niteTimes_per[0], np.min(doubleKeo_latLong[i][1])), np.diff(doubleKeo_niteTimes_per).item(), np.diff(doubleKeo_latLong[i][1]).item(), edgecolor='xkcd:black', facecolor='xkcd:black', alpha=0.25); #make that patch
                    ax.add_patch(recta); #add on that patch
                #END IF
            #END FOR j
        #END IF
        
        #----- Now drawing line of interest -----
        if( doubleKeo_plotSpacingName[i] == 'Latitude' ): #if true, latitude
            if( (np.min(doubleKeo_latLong[i][0]) <= doubleKeo_AMPERE_latAlign[i]) & (np.max(doubleKeo_latLong[i][0]) >= doubleKeo_AMPERE_latAlign[i]) ): #only plot if it's in the lat range specified
                ax.plot( np.linspace(np.min((TEC_timeUnique - dateRange_dayNum_zeroHr[1]*86400)/3600),np.max((TEC_timeUnique - dateRange_dayNum_zeroHr[1]*86400)/3600),10,endpoint=True) , #X time hr
                    np.tile(doubleKeo_AMPERE_latAlign[i],10) , #Y latitude OR longitude arcdeg
                    c='xkcd:black',linewidth=settings['plot']['line width']['smol']); #plots a point with a black line
            #END IF
        else:
            if( (np.min(doubleKeo_latLong[i][1]) <= doubleKeo_AMPERE_latAlign[i]) & (np.max(doubleKeo_latLong[i][1]) >= doubleKeo_AMPERE_latAlign[i]) ): #only plot if it's in the lat range specified
                ax.plot( np.linspace(np.min((TEC_timeUnique - dateRange_dayNum_zeroHr[1]*86400)/3600),np.max((TEC_timeUnique - dateRange_dayNum_zeroHr[1]*86400)/3600),10,endpoint=True) , #X time hr
                    np.tile(doubleKeo_AMPERE_latAlign[i],10) , #Y latitude OR longitude arcdeg
                    c='xkcd:black',linewidth=settings['plot']['line width']['smol']); #plots a point with a black line
            #END IF
        #END IF
    #END FOR i
    
    #----- Label and make it look nice -----
    string_title = str(len(doubleKeo_latLong))+' '+settings['TEC']['name']+' Keograms on '+str(np.round(doubleKeo_angle_orig[i],2))+' deg Angle & Widths of '+ \
        str(np.round(doubleKeo_width,2))+' arcdeg \n Integrated '+AMPERE_plot_label_noUnits; #create mecha title
    if( FLG_doubleKeo_AMPERE_integrateMethod[i] == 0 ):
        string_title = string_title + ' within keo area'; #add to mecha title
    elif( FLG_doubleKeo_AMPERE_integrateMethod[i] == 1 ):
        string_title = string_title + ' within keo long & up to pole'; #add to mecha title
    elif( FLG_doubleKeo_AMPERE_integrateMethod[i] == 2 ):
        string_title = string_title + ' within keo long & up to '+str(doubleKeo_AMPERE_integrateMethod_val)+' degc lat'; #add to mecha title
    elif( FLG_doubleKeo_AMPERE_integrateMethod[i] == 3 ):
        if( (np.min(plotLatRange) <= 0) & (np.max(plotLatRange) >= 0) ):
            string_title = string_title + ' both Hemispheres'; #add to mecha title
        else:
            if( (np.min(plotLatRange) >= 0) & (np.max(plotLatRange) >= 0) ):
                #northern hemisphere
                string_title = string_title + ' Northern Hemisphere'; #add to mecha title
            else:
                #southern hemisphere
                string_title = string_title + ' Southern Hemisphere'; #add to mecha title
            #END IF
        #END IF
    #END IF
    string_title = string_title + ' w/ time delays of '+str(doubleKeo_AMPERE_timeDelay)+' hrs';
    ax.set_title(string_title,fontproperties=FONT_titleFM); #set the title
    if( i == len(doubleKeo_latLong)-1 ):
        ax.set_xlabel('Time in UT - 0 Hr on Day '+str(dateRange_dayNum_zeroHr[1])+', '+str(dateRange_dayNum_zeroHr[0])+' [hr]',fontproperties=FONT_axisLabelFM); #set the x axis label
    #END IF
    ax.set_ylabel(doubleKeo_plotSpacingName[i]+' [arcdeg]',fontproperties=FONT_axisLabelFM); #set the y axis label
    
    autoTick = (np.ceil(np.max(doubleKeo_plotSpacing)) - np.floor(np.min(doubleKeo_plotSpacing)))/13; #tries to split the latitude range into 13 parts (based off of 180/15+1)
    if( autoTick > 25 ):
        autoTick = 30; #sets the tick setting to 15 arcdegrees per tick
    elif( autoTick > 10 ):
        autoTick = 15; #sets the tick setting to 15 arcdegrees per tick
    elif( autoTick > 5 ):
        autoTick = 10; #sets the tick setting to 10 arcdegrees per tick
    elif( autoTick > 2 ):
        autoTick = 5; #sets the tick setting to 5 arcdegrees per tick
    elif( autoTick > 1 ):
        autoTick = 2; #sets the tick setting to 5 arcdegrees per tick
    elif( autoTick >= 0.6 ): #0.6 because 15/25 = 0.6, so there will be enough 1 arcdeg ticks
        autoTick = 1; #                                                        sets the tick setting to 1 arcdegree per tick
    else:
        autoTick = (np.max(doubleKeo_latLongComb) - np.min(doubleKeo_latLongComb))/13; #just goes for it if it's a super tiny range
    #END IF
    yAxisTicks = np.round(np.arange( np.floor(np.min(doubleKeo_plotSpacing)),np.ceil(np.max(doubleKeo_plotSpacing))+autoTick,autoTick ),2); #creates y ticks automagically
    ax.set_yticks(yAxisTicks); #set x axis ticks
    
    #-----Draw line from 1st TEC event to 2nd-----
    if( (doubleKeo_arrowTimes[0] >= np.min((TEC_timeUnique - dateRange_dayNum_zeroHr[1]*86400)/3600)) & \
        (doubleKeo_arrowTimes[1] <= np.max((TEC_timeUnique - dateRange_dayNum_zeroHr[1]*86400)/3600)) ):
        con = ConnectionPatch(xyA=(doubleKeo_arrowTimes[0],doubleKeo_AMPERE_latAlign[0]), coordsA=ax.transData, #-11.81 #-10.54
                              xyB=(doubleKeo_arrowTimes[1],doubleKeo_AMPERE_latAlign[1]), coordsB=ax.transData, #-11.13 #-9.96
                              arrowstyle="-|>", shrinkA=5, shrinkB=5,mutation_scale=20, fc="xkcd:pink",
                              color='xkcd:pink', linewidth=settings['plot']['line width']['plus']); #prep a line between plots
        fig.add_artist(con); #draw the line
    #END IF
    
    figFitter(fig); #fit the fig fast
    # fig.subplots_adjust(left = 0.055, right = 0.935, top = 0.96, bottom = 0.075, hspace = 0.18); #sets padding to small numbers for minimal white space
    #fig.tight_layout(); #function for a tight layout, doesn't seem to do much here
    plt.show(); #req to make plot show up
#END IF

if( FLG_doubleKeo_plot_timeCutout == 1 ):
    from matplotlib.patches import ConnectionPatch, Rectangle
    from subfun_timeMatch import subfun_timeMatch
    from subfun_figFitter import figFitter
    from subfun_filter import subfun_filter
    from subfun_sunAlsoRises import sunAlsoRises
    from subfun_date_to_dayNum import subfun_date_to_dayNum
    import copy
    
    #-----Plot TEC results as a Keogram w/ AMPERE integrated line as well-----
    #Prep the plot
    fig, ax = plt.subplots(nrows=len(doubleKeo_latLong), ncols=1); #use instead of fig because it inits an axis too (I think I dunno)
    figManager = plt.get_current_fig_manager(); #req to maximize
    figManager.window.showMaximized(); #force maximized
    axTwinx = []; #prep this list, holds the twinx axes, will grow as we plot
    cax = []; #prep
    caxTwinx = []; #prep
    
    timeCutout_TEC_indexes = np.array( ( np.where(np.min(np.abs( (TEC_timeUnique-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (TEC_timeUnique-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , \
        np.where(np.min(np.abs( (TEC_timeUnique-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (TEC_timeUnique-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range
    for i in range(0,len(doubleKeo_latLong)):
        timeCutout_AMPERE_indexes = np.array( ( np.where(np.min(np.abs( (doubleKeo_AMPERE_time[i]-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (doubleKeo_AMPERE_time[i]-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , \
            np.where(np.min(np.abs( (doubleKeo_AMPERE_time[i]-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (doubleKeo_AMPERE_time[i]-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range
        
        divider = make_axes_locatable(ax[i]); #prep to add an axis
        cax.append(divider.append_axes('right', size='2.0%', pad=1.75)); #make a color bar axis, append
        
        #Remove the aspect ratio from the basemap so it fills the screen better
        ax[i].set_aspect('auto');
        
        #-----Plot TEC results as a keogram-----
        pltHelprX, pltHelprY = np.meshgrid( (TEC_timeUnique[timeCutout_TEC_indexes[0]:timeCutout_TEC_indexes[1]+1] - dateRange_dayNum_zeroHr[1]*86400), \
                    doubleKeo_plotSpacing[i]);
        im = ax[i].pcolormesh(pltHelprX, pltHelprY,  doubleKeo_keo[i][timeCutout_TEC_indexes[0]:timeCutout_TEC_indexes[1]+1,:].T ,vmin=np.min(settings['TEC']['plot lim']), vmax=np.max(settings['TEC']['plot lim']),cmap=settings['TEC']['colormap']); # pseudocolor plot "stretched" to the grid
        cbar = fig.colorbar(im, cax=cax[i], orientation='vertical'); #create a colorbar using the prev. defined cax
        cbar.set_label(settings['TEC']['plot label']); #tabel the colorbar
        cbar.ax.tick_params(labelsize=FONT_axisTick);
        #cbar.set_clim(vmin=np.min(settings['TEC']['plot lim']), vmax=np.max(settings['TEC']['plot lim'])); #they changed how the code works, this doesn't work anymore
        cbar.mappable.set_clim(vmin=np.min(settings['TEC']['plot lim']), vmax=np.max(settings['TEC']['plot lim'])); #now it's this
        cax[i].yaxis.set_ticks(np.linspace(np.min(settings['TEC']['plot lim']),np.max(settings['TEC']['plot lim']),5)); #create useful tick marks
        cax[i].yaxis.set_major_formatter(FormatStrFormatter('%.2f')); #force a rounded format
        cax[i].yaxis.label.set_font_properties(FONT_axisLabelFM);
        
        #-----Plot AMPERE results as a 1D line-----
        axTwinx.append(ax[i].twinx()); #add on the new twinx axis
        doubleKeo_AMPERE_integrated_plot = np.copy(doubleKeo_AMPERE_integrated[i]); #copy
        if( doubleKeo_AMPERE_plotLim != False ):
            doubleKeo_AMPERE_integrated_plot[ doubleKeo_AMPERE_integrated_plot > doubleKeo_AMPERE_plotLim ] = doubleKeo_AMPERE_plotLim; #cap the max val
        #END IF
        axTwinx[i].plot( doubleKeo_AMPERE_timeHr[i][timeCutout_AMPERE_indexes[0]:timeCutout_AMPERE_indexes[1]+1], doubleKeo_AMPERE_integrated_plot[timeCutout_AMPERE_indexes[0]:timeCutout_AMPERE_indexes[1]+1] , linewidth=settings['plot']['line width']['regular'] , color='xkcd:violet'); #plot
        axTwinx[i].set_ylabel(AMPERE_plot_label,fontproperties=FONT_axisLabelFM); #set the y axis label
        #now adjust the ylim so the lines are about where we want them to be
        lineOfInterestLoc = (doubleKeo_AMPERE_latAlign[i]-np.min(doubleKeo_latLong[i][0]))/(np.max(doubleKeo_latLong[i][0])-np.min(doubleKeo_latLong[i][0])); #get line of interest location on TEC keogram in a form of 1 to 0
        twinx_valAtLineOfInterest = np.mean(doubleKeo_AMPERE_integrated_plot) + 1.5*np.std(doubleKeo_AMPERE_integrated_plot); #this is the value we want to align with the line of interest
        twinx_minToAlign = (lineOfInterestLoc*np.max(doubleKeo_AMPERE_integrated_plot) - twinx_valAtLineOfInterest)/(lineOfInterestLoc - 1); #calc the min to get that value at the LOI
        axTwinx[i].set_ylim( twinx_minToAlign , np.max(doubleKeo_AMPERE_integrated_plot) ); #set y axis limits
        
        #this is to keep plotting similar
        dividerTwinx = make_axes_locatable(axTwinx[i]); #prep to add an axis
        caxTwinx.append(dividerTwinx.append_axes('right', size='2.0%', pad=1.75)); #make a color bar axis, append
        caxTwinx[i].set_visible(False); #mkae it invisible so it matches the other plots in width
        
        xAxisTicksStep = 1; #hr, hour steps between each x axis tick
        xAxisTicks = np.arange( (np.round((np.min(TEC_timeUnique[timeCutout_TEC_indexes[0]:timeCutout_TEC_indexes[1]+1])-dateRange_dayNum_zeroHr[1]*86400)/3600) - np.mod(np.round((np.min(TEC_timeUnique[timeCutout_TEC_indexes[0]:timeCutout_TEC_indexes[1]+1])-dateRange_dayNum_zeroHr[1]*86400)/3600), xAxisTicksStep)) , \
            (np.round((np.max(TEC_timeUnique[timeCutout_TEC_indexes[0]:timeCutout_TEC_indexes[1]+1])-dateRange_dayNum_zeroHr[1]*86400)/3600) - np.mod(np.round((np.max(TEC_timeUnique[timeCutout_TEC_indexes[0]:timeCutout_TEC_indexes[1]+1])-dateRange_dayNum_zeroHr[1]*86400)/3600),xAxisTicksStep)) + xAxisTicksStep , \
            xAxisTicksStep); #sets the start hr, stop hr, and the step size between (in this case, 4 hr)
        ax[i].set_xticks(xAxisTicks); #set x axis ticks
        ax[i].set_xlim( np.min(xAxisTicks) , np.max(xAxisTicks) ); #set x axis limits
        axTwinx[i].set_xlim( np.min(xAxisTicks) , np.max(xAxisTicks) ); #set x axis limits
        
        #adjust the tick marks
        # tickzLim = 40*np.median(doubleKeo_AMPERE_integrated[i]); #get the median*40 of the integrated JH
        tickz = axTwinx[i].get_yticks(); #get the ticks
        # tickz = tickz[ (tickz < tickzLim) & (tickz >= 0) ]; #get only the tickz we want
        tickz = tickz[ (tickz >= 0) ]; #get only the tickz we want
        axTwinx[i].set_yticks(tickz); #set the ticks
        
        #----- Plot Shading to represent 'night' -----
        if( doubleKeo_niteTimes[0] == False ):
            if( doubleKeo_plotSpacingName[i] == 'Latitude' ): #if true, latitude
                if( doubleKeo_AMPERE_latAlign[i] > 50 ):
                    latToUse = 50; #cap at 50 deg lat to keep it from getting too zesty at the poles
                else:
                    latToUse = doubleKeo_AMPERE_latAlign[i];
                #END IF
                (doubleKeo_niteTimes_sunRise, doubleKeo_niteTimes_sunSet, doubleKeo_dateRange_fullPad) = sunAlsoRises(dateRange_full,latToUse,np.mean(doubleKeo_latLong[i][1])); #call sunrise/set function
            else:
                (doubleKeo_niteTimes_sunRise, doubleKeo_niteTimes_sunSet, doubleKeo_dateRange_fullPad) = sunAlsoRises(dateRange_full,np.mean(doubleKeo_latLong[i][0]),doubleKeo_AMPERE_latAlign[i]); #call sunrise/set function
            #END IF
            doubleKeo_dateRange_dayNum_fullPad = subfun_date_to_dayNum(doubleKeo_dateRange_fullPad); #convert to dayNum
            doubleKeo_niteTimes_sunRise = (doubleKeo_niteTimes_sunRise + doubleKeo_dateRange_dayNum_fullPad[:,1] - dateRange_dayNum_zeroHr[1])*24; #hrs, center around zero hr and convert ot hrs
            doubleKeo_niteTimes_sunSet = (doubleKeo_niteTimes_sunSet + doubleKeo_dateRange_dayNum_fullPad[:,1] - dateRange_dayNum_zeroHr[1])*24; #hrs, center around zero hr and convert ot hrs
            doubleKeo_niteTimes_sunRise = doubleKeo_niteTimes_sunRise[1:]; #remove 1st
            doubleKeo_niteTimes_sunSet = doubleKeo_niteTimes_sunSet[:-1]; #remove last
            #FIFTH STEP: PLOT THIS STUFF
            for j in range(0,doubleKeo_niteTimes_sunSet.size):
                # ax.axvspan(doubleKeo_AMPERE_niteTimes_array[j,0], doubleKeo_AMPERE_niteTimes_array[j,1], alpha=0.25, color='xkcd:black');
                if(doubleKeo_plotSpacingName[i] == 'Latitude'): #if Y axis is latitude, use latitude
                    recta = Rectangle((doubleKeo_niteTimes_sunSet[j], np.min(doubleKeo_latLong[i][0])), doubleKeo_niteTimes_sunRise[j]-doubleKeo_niteTimes_sunSet[j], np.diff(doubleKeo_latLong[i][0]).item(), edgecolor='xkcd:black', facecolor='xkcd:black', alpha=0.25); #make that patch
                    ax.add_patch(recta); #add on that patch
                else: #otherwise longitude
                    recta = Rectangle((doubleKeo_niteTimes_sunSet[j], np.min(doubleKeo_latLong[i][1])), doubleKeo_niteTimes_sunRise[j]-doubleKeo_niteTimes_sunSet[j], np.diff(doubleKeo_latLong[i][1]).item(), edgecolor='xkcd:black', facecolor='xkcd:black', alpha=0.25); #make that patch
                    ax.add_patch(recta); #add on that patch
                #END IF
            #END FOR j
        else:
            for j in range(0,dates['date range zero hr hours'].size):
                doubleKeo_niteTimes_per = dates['date range zero hr hours'][j] + np.asarray(doubleKeo_niteTimes[i]); #get the nite time ranges
                if(doubleKeo_plotSpacingName[i] == 'Latitude'): #if Y axis is latitude, use latitude
                    recta = Rectangle((doubleKeo_niteTimes_per[0], np.min(doubleKeo_latLong[i][0])), np.diff(doubleKeo_niteTimes_per).item(), np.diff(doubleKeo_latLong[i][0]).item(), edgecolor='xkcd:black', facecolor='xkcd:black', alpha=0.25); #make that patch
                    ax.add_patch(recta); #add on that patch
                else: #otherwise longitude
                    recta = Rectangle((doubleKeo_niteTimes_per[0], np.min(doubleKeo_latLong[i][1])), np.diff(doubleKeo_niteTimes_per).item(), np.diff(doubleKeo_latLong[i][1]).item(), edgecolor='xkcd:black', facecolor='xkcd:black', alpha=0.25); #make that patch
                    ax.add_patch(recta); #add on that patch
                #END IF
            #END FOR j
        #END IF
        
        string_title = settings['TEC']['plot label no units']+' Keo Angle of '+str(np.round(doubleKeo_angle_orig[i],2))+' deg & Width of '+ \
            str(np.round(doubleKeo_width[i],2))+' arcdeg | Integrated '+AMPERE_plot_label_noUnits; #create mecha title
        if( FLG_doubleKeo_AMPERE_integrateMethod[i] == 0 ):
            string_title = string_title + ' within keo area'; #add to mecha title
        elif( FLG_doubleKeo_AMPERE_integrateMethod[i] == 1 ):
            string_title = string_title + ' within keo long & up to pole'; #add to mecha title
        elif( FLG_doubleKeo_AMPERE_integrateMethod[i] == 2 ):
            string_title = string_title + ' within keo long & up to '+str(doubleKeo_AMPERE_integrateMethod_val)+' degc lat'; #add to mecha title
        elif( FLG_doubleKeo_AMPERE_integrateMethod[i] == 3 ):
            if( (np.min(plotLatRange) <= 0) & (np.max(plotLatRange) >= 0) ):
                string_title = string_title + ' both Hemispheres'; #add to mecha title
            else:
                if( (np.min(plotLatRange) >= 0) & (np.max(plotLatRange) >= 0) ):
                    #northern hemisphere
                    string_title = string_title + ' Northern Hemisphere'; #add to mecha title
                else:
                    #southern hemisphere
                    string_title = string_title + ' Southern Hemisphere'; #add to mecha title
                #END IF
            #END IF
        #END IF
        string_title = string_title + ' w/ time delay of '+str(doubleKeo_AMPERE_timeDelay[i])+' hrs';
        ax[i].set_title(string_title,fontproperties=FONT_titleFM); #set the title
        if( i == len(doubleKeo_latLong)-1 ):
            ax[i].set_xlabel('Time in UT - 0 Hr on Day '+str(dateRange_dayNum_zeroHr[1])+', '+str(dateRange_dayNum_zeroHr[0])+' [hr]',fontproperties=FONT_axisLabelFM); #set the x axis label
        #END IF
        ax[i].set_ylabel(doubleKeo_plotSpacingName[i]+' [arcdeg]',fontproperties=FONT_axisLabelFM); #set the y axis label
        
        autoTick = (np.ceil(np.max(doubleKeo_plotSpacing[i])) - np.floor(np.min(doubleKeo_plotSpacing[i])))/13; #tries to split the latitude range into 13 parts (based off of 180/15+1)
        if( autoTick > 25 ):
            autoTick = 30; #sets the tick setting to 15 arcdegrees per tick
        elif( autoTick > 10 ):
            autoTick = 15; #sets the tick setting to 15 arcdegrees per tick
        elif( autoTick > 5 ):
            autoTick = 10; #sets the tick setting to 10 arcdegrees per tick
        elif( autoTick > 2 ):
            autoTick = 5; #sets the tick setting to 5 arcdegrees per tick
        elif( autoTick > 1 ):
            autoTick = 2; #sets the tick setting to 5 arcdegrees per tick
        elif( autoTick >= 0.6 ): #0.6 because 15/25 = 0.6, so there will be enough 1 arcdeg ticks
            autoTick = 1; #                                                        sets the tick setting to 1 arcdegree per tick
        else:
            if(doubleKeo_plotSpacingName[i] == 'Latitude'): #if Y axis is latitude, use latitude
                autoTick = (np.max(doubleKeo_latLong[i][0]) - np.min(doubleKeo_latLong[i][0]))/13; #just goes for it if it's a super tiny range
            elif(doubleKeo_plotSpacingName[i] == 'Longitude'): #if Y axis is longitude, use longitude
                autoTick = (np.max(doubleKeo_latLong[i][1]) - np.min(doubleKeo_latLong[i][1]))/13; #just goes for it if it's a super tiny range
            #END IF
        #END IF
        yAxisTicks = np.round(np.arange( np.floor(np.min(doubleKeo_plotSpacing[i])),np.ceil(np.max(doubleKeo_plotSpacing[i])),autoTick ),2); #creates y ticks automagically
        ax[i].set_yticks(yAxisTicks); #set x axis ticks
        
        #Now drawing line of interest
        if( doubleKeo_plotSpacingName[i] == 'Latitude' ): #if true, latitude
            if( (np.min(doubleKeo_latLong[i][0]) <= doubleKeo_AMPERE_latAlign[i]) & (np.max(doubleKeo_latLong[i][0]) >= doubleKeo_AMPERE_latAlign[i]) ): #only plot if it's in the lat range specified
                ax[i].plot( np.linspace(np.min((TEC_timeUnique[timeCutout_TEC_indexes[0]:timeCutout_TEC_indexes[1]+1] - dateRange_dayNum_zeroHr[1]*86400)/3600),np.max((TEC_timeUnique[timeCutout_TEC_indexes[0]:timeCutout_TEC_indexes[1]+1] - dateRange_dayNum_zeroHr[1]*86400)/3600),10,endpoint=True) , #X time hr
                    np.tile(doubleKeo_AMPERE_latAlign[i],10) , #Y latitude OR longitude arcdeg
                    c='xkcd:black',linewidth=settings['plot']['line width']['smol']); #plots a point with a black line
            #END IF
        else:
            if( (np.min(doubleKeo_latLong[i][1]) <= doubleKeo_AMPERE_latAlign[i]) & (np.max(doubleKeo_latLong[i][1]) >= doubleKeo_AMPERE_latAlign[i]) ): #only plot if it's in the lat range specified
                ax[i].plot( np.linspace(np.min((TEC_timeUnique[timeCutout_TEC_indexes[0]:timeCutout_TEC_indexes[1]+1] - dateRange_dayNum_zeroHr[1]*86400)/3600),np.max((TEC_timeUnique[timeCutout_TEC_indexes[0]:timeCutout_TEC_indexes[1]+1] - dateRange_dayNum_zeroHr[1]*86400)/3600),10,endpoint=True) , #X time hr
                    np.tile(doubleKeo_AMPERE_latAlign[i],10) , #Y latitude OR longitude arcdeg
                    c='xkcd:black',linewidth=settings['plot']['line width']['smol']); #plots a point with a black line
            #END IF
        #END IF
    #END FOR i
    
    #-----Draw line from 1st TEC event to 2nd-----
    if( (doubleKeo_arrowTimes[0] >= np.min(time_cutout_range/3600)) & \
        (doubleKeo_arrowTimes[1] <= np.max(time_cutout_range/3600)) ):
        con = ConnectionPatch(xyA=(doubleKeo_arrowTimes[0],doubleKeo_AMPERE_latAlign[0]), coordsA=ax[0].transData,
                              xyB=(doubleKeo_arrowTimes[1],doubleKeo_AMPERE_latAlign[1]), coordsB=ax[1].transData,
                              arrowstyle="-|>", shrinkA=5, shrinkB=5,mutation_scale=20, fc="xkcd:pink",
                              color='xkcd:pink', linewidth=settings['plot']['line width']['double plus']); #prep a line between plots
        fig.add_artist(con); #draw the line
    #END IF
    
    figFitter(fig); #fit the fig fast
    # fig.subplots_adjust(left = 0.055, right = 0.935, top = 0.96, bottom = 0.075, hspace = 0.18); #sets padding to small numbers for minimal white space
    #fig.tight_layout(); #function for a tight layout, doesn't seem to do much here
    plt.show(); #req to make plot show up
#END IF

#==============Analysis: delta-vTEC Double Keo w/ AMPERE==============
if( FLG_doubleKeo_plot_timeCutout == 2 ): #mode 2 makes the two keograms meet at a shared latitude/longitude
    from matplotlib.patches import ConnectionPatch, Rectangle
    from subfun_timeMatch import subfun_timeMatch
    from subfun_figFitter import figFitter
    from subfun_filter import subfun_filter
    from subfun_sunAlsoRises import sunAlsoRises
    from subfun_date_to_dayNum import subfun_date_to_dayNum
    import copy
    
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (doubleKeo_AMPERE_time[i]-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (doubleKeo_AMPERE_time[i]-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , \
        np.where(np.min(np.abs( (doubleKeo_AMPERE_time[i]-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (doubleKeo_AMPERE_time[i]-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range
        
    #-----Plot TEC results as a Keogram w/ AMPERE integrated line as well-----
    #Prep the plot
    fig, ax = plt.subplots(nrows=1, ncols=1); #use instead of fig because it inits an axis too (I think I dunno)
    figManager = plt.get_current_fig_manager(); #req to maximize
    figManager.window.showMaximized(); #force maximized
    axTwinx = []; #prep this list, holds the twinx axes, will grow as we plot
    # cax = []; #prep
    caxTwinx = []; #prep
    divider = make_axes_locatable(ax); #prep to add an axis
    cax = divider.append_axes('right', size='2.0%', pad=1.75); #make a color bar axis, append [0.35]
    # dividerTwinx = make_axes_locatable(axTwinx); #prep to add an axis
    # caxTwinx = dividerTwinx.append_axes('right', size='2.0%', pad=1.75); #make a color bar axis, append
    # caxTwinx.set_visible(False); #mkae it invisible so it matches the other plots in width
    
    timeCutout_TEC_indexes = np.array( ( np.where(np.min(np.abs( (TEC_timeUnique-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (TEC_timeUnique-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , \
        np.where(np.min(np.abs( (TEC_timeUnique-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (TEC_timeUnique-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range
    
    #Remove the aspect ratio from the basemap so it fills the screen better
    ax.set_aspect('auto');
    for i in range(0,len(doubleKeo_latLong)):
        #-----Plot TEC results as a keogram-----
        pltHelprX, pltHelprY = np.meshgrid( (TEC_timeUnique[timeCutout_TEC_indexes[0]:timeCutout_TEC_indexes[1]+1] - dateRange_dayNum_zeroHr[1]*86400)/3600, \
                    doubleKeo_plotSpacing[i]);
        im = ax.pcolormesh(pltHelprX, pltHelprY,  doubleKeo_keo[i][timeCutout_TEC_indexes[0]:timeCutout_TEC_indexes[1]+1,:].T ,vmin=np.min(settings['TEC']['plot lim']), vmax=np.max(settings['TEC']['plot lim']),cmap=settings['TEC']['colormap'],zorder=i); # pseudocolor plot "stretched" to the grid
    #END FOR i
        
    cbar = fig.colorbar(im, cax=cax, orientation='vertical'); #create a colorbar using the prev. defined cax
    cbar.set_label(settings['TEC']['name']+settings['TEC']['units']); #tabel the colorbar
    cbar.ax.tick_params(labelsize=FONT_axisTick);
    #cbar.set_clim(vmin=np.min(settings['TEC']['plot lim']), vmax=np.max(settings['TEC']['plot lim'])); #they changed how the code works, this doesn't work anymore
    cbar.mappable.set_clim(vmin=np.min(settings['TEC']['plot lim']), vmax=np.max(settings['TEC']['plot lim'])); #now it's this
    cax.yaxis.set_ticks(np.linspace(np.min(settings['TEC']['plot lim']),np.max(settings['TEC']['plot lim']),5)); #create useful tick marks
    cax.yaxis.set_major_formatter(FormatStrFormatter('%.2f')); #force a rounded format
    cax.yaxis.label.set_font_properties(FONT_axisLabelFM);
    
    #----- Draw lines of separation between the keograms -----
    doubleKeo_alignments_limits = np.empty(doubleKeo_alignments.size+2); #preallocate
    for i in range(0,doubleKeo_alignments.size):
        ax.plot( np.array( (np.min((TEC_timeUnique[timeCutout_TEC_indexes[0]:timeCutout_TEC_indexes[1]+1] - dateRange_dayNum_zeroHr[1]*86400)/3600),np.max((TEC_timeUnique[timeCutout_TEC_indexes[0]:timeCutout_TEC_indexes[1]+1] - dateRange_dayNum_zeroHr[1]*86400)/3600)) ), \
                np.ones(2)*doubleKeo_alignments[i],
                c='xkcd:pastel purple',linewidth=settings['plot']['line width']['thicc'],linestyle='-.'); #plots a point with a black line
        plt.pause(0.0001); #another pause needed to make matplotlib work
        doubleKeo_alignments_limits[i+1] = ax.transLimits.transform((1,doubleKeo_alignments[i]))[1]; #get the position of the split in axis units
    #END FOR i
    doubleKeo_alignments_limits[0] = 1; #these are known
    doubleKeo_alignments_limits[-1] = 0; #these are known
    
    #!! hindsight: solve this with 2 separate plots that have no spacing between them !!
    
    for i in range(0,len(doubleKeo_latLong)):
        timeCutout_AMPERE_indexes = np.array( ( np.where(np.min(np.abs( (doubleKeo_AMPERE_time[i]-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (doubleKeo_AMPERE_time[i]-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , \
            np.where(np.min(np.abs( (doubleKeo_AMPERE_time[i]-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (doubleKeo_AMPERE_time[i]-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range
        
        # -----Plot AMPERE results as a 1D line -----
        axTwinx.append(ax.twinx()); #add on the new twinx axis
        doubleKeo_AMPERE_integrated_plot = np.copy(doubleKeo_AMPERE_integrated[i]); #copy
        if( doubleKeo_AMPERE_plotLim != False ):
            doubleKeo_AMPERE_integrated_plot[ doubleKeo_AMPERE_integrated_plot > doubleKeo_AMPERE_plotLim ] = doubleKeo_AMPERE_plotLim; #cap the max val
        #END IF
        axTwinx[i].plot( doubleKeo_AMPERE_timeHr[i][timeCutout_AMPERE_indexes[0]:timeCutout_AMPERE_indexes[1]+1], doubleKeo_AMPERE_integrated_plot[timeCutout_AMPERE_indexes[0]:timeCutout_AMPERE_indexes[1]+1] , linewidth=settings['plot']['line width']['regular'] , color='xkcd:violet',zorder=i); #plot
        if( i == len(doubleKeo_latLong)-1 ):
            axTwinx[i].set_ylabel(AMPERE_plot_label,fontproperties=FONT_axisLabelFM); #set the y axis label
        #END IF
        
        #now adjust the ylim so the lines are about where we want them to be
        # #--- Adjust yLim max to be at the right place --- (turns out can't do both at once since they're linked - so gotta... solve)
        # twinx_yFactor = 1 - (doubleKeo_alignments_limits[i] - axTwinx[i].transLimits.transform((1,np.max(doubleKeo_AMPERE_integrated[i])))[1]); #get a factor
        # twinx_yLims = np.array( axTwinx[i].get_ylim() ); #get the ylims
        # twinx_yLims[1] = np.max(doubleKeo_AMPERE_integrated[i])/doubleKeo_alignments_limits[i]-(twinx_yLims[0]*(1-doubleKeo_alignments_limits[i]))*2; #solving this is nasty I'm not big brain here
        # axTwinx[i].set_ylim(twinx_yLims); #apply the new ylim because it adjusts the next thing
        
        # #--- Adjust yLim min to align the data on the line of interest ---
        # lineOfInterestLoc = (doubleKeo_alignments_limits[i]-doubleKeo_alignments_limits[i+1])*(doubleKeo_AMPERE_latAlign[i]-np.min(doubleKeo_latLongComb[i]))/(np.max(doubleKeo_latLongComb[i])-np.min(doubleKeo_latLongComb[i]))+doubleKeo_alignments_limits[i+1]; #get line of interest location on TEC keogram in a form of 1 to 0 (scaled by the keogram plot-within-plots)
        # twinx_valAtLineOfInterest = np.mean(doubleKeo_AMPERE_integrated[i]) + 1.5*np.std(doubleKeo_AMPERE_integrated[i]); #this is the value we want to align with the line of interest
        # twinx_minToAlign = (lineOfInterestLoc*twinx_yLims[1] - twinx_valAtLineOfInterest)/(lineOfInterestLoc - 1); #calc the min to get that value at the LOI
        # axTwinx[i].set_ylim( twinx_minToAlign , twinx_yLims[1] ); #set y axis limits
        
        #--- I had to do actual algebra for this (combined two equations above) ---
        twinx_yLims = np.array( axTwinx[i].get_ylim() ); #get the ylims
        lim1 = doubleKeo_alignments_limits[i]; #get the upper limit in axis units
        yMax = np.nanmax(doubleKeo_AMPERE_integrated_plot); #get the desired yMax
        yMin = twinx_yLims[0]; #get the current yMin
        lim2 = (doubleKeo_alignments_limits[i]-doubleKeo_alignments_limits[i+1])*(doubleKeo_AMPERE_latAlign[i]-np.min(doubleKeo_latLongComb[i]))/(np.max(doubleKeo_latLongComb[i])-np.min(doubleKeo_latLongComb[i]))+doubleKeo_alignments_limits[i+1]; #get line of interest location on TEC keogram in a form of 1 to 0 (scaled by the keogram plot-within-plots)
        yGoal = np.nanmean(doubleKeo_AMPERE_integrated_plot) + 1.5*np.nanstd(doubleKeo_AMPERE_integrated_plot); #this is the value we want to align with the line of interest
        
        #--- Calc the yLim Max and Min ---
        twinx_yLims = np.array( axTwinx[i].get_ylim() ); #get the ylims
        twinx_yLims[1] = (yMax/lim1 + 2*yGoal/(lim2-1)*(1-lim1))/(1+2*lim2/(lim2-1)*(1-lim1)); #calc max limit
        twinx_yLims[0] = (lim2*twinx_yLims[1] - yGoal)/(lim2-1); #calc min limit
        axTwinx[i].set_ylim( twinx_yLims ); #set y axis limits
        # #alignment check
        # ax.transLimits.transform((1,doubleKeo_AMPERE_latAlign[i]))[1]
        # axTwinx[i].transLimits.transform((1,twinx_valAtLineOfInterest))[1]
        
        #this is to keep plotting similar
        dividerTwinx = make_axes_locatable(axTwinx[i]); #prep to add an axis
        caxTwinx.append(dividerTwinx.append_axes('right', size='2.0%', pad=1.75)); #make a color bar axis, append
        caxTwinx[i].set_visible(False); #mkae it invisible so it matches the other plots in width
        
        xAxisTicksStep = 1; #hr, hour steps between each x axis tick
        xAxisTicks = np.arange( (np.round((np.min(TEC_timeUnique[timeCutout_TEC_indexes[0]:timeCutout_TEC_indexes[1]+1])-dateRange_dayNum_zeroHr[1]*86400)/3600) - np.mod(np.round((np.min(TEC_timeUnique[timeCutout_TEC_indexes[0]:timeCutout_TEC_indexes[1]+1])-dateRange_dayNum_zeroHr[1]*86400)/3600), xAxisTicksStep)) , \
            (np.round((np.max(TEC_timeUnique[timeCutout_TEC_indexes[0]:timeCutout_TEC_indexes[1]+1])-dateRange_dayNum_zeroHr[1]*86400)/3600) - np.mod(np.round((np.max(TEC_timeUnique[timeCutout_TEC_indexes[0]:timeCutout_TEC_indexes[1]+1])-dateRange_dayNum_zeroHr[1]*86400)/3600),xAxisTicksStep)) + xAxisTicksStep , \
            xAxisTicksStep); #sets the start hr, stop hr, and the step size between (in this case, 4 hr)
        ax.set_xticks(xAxisTicks); #set x axis ticks
        ax.set_xlim( np.min(xAxisTicks) , np.max(xAxisTicks) ); #set x axis limits
        axTwinx[i].set_xlim( np.min(xAxisTicks) , np.max(xAxisTicks) ); #set x axis limits
        
        #adjust the tick marks
        # tickzLim = 40*np.median(doubleKeo_AMPERE_integrated[i]); #get the median*40 of the integrated JH
        tickz = axTwinx[i].get_yticks(); #get the ticks
        # tickz = tickz[ (tickz < tickzLim) & (tickz >= 0) ]; #get only the tickz we want
        tickzPos = axTwinx[i].transLimits.transform(np.vstack( (np.ones(tickz.size), tickz) ).T)[:,1]; #get the tickz positions on the plot
        tickz = tickz[ (tickz >= 0) & (doubleKeo_alignments_limits[i] >= tickzPos) & (doubleKeo_alignments_limits[i+1] <= tickzPos) ]; #make sure the ticks fall within the keogram area and they're positive
        axTwinx[i].set_yticks(tickz); #set the ticks
        
        #----- Plot Shading to represent 'night' -----
        if( doubleKeo_niteTimes[0] == False ):
            if( doubleKeo_plotSpacingName[i] == 'Latitude' ): #if true, latitude
                if( doubleKeo_AMPERE_latAlign[i] > 50 ):
                    latToUse = 50; #cap at 50 deg lat to keep it from getting too zesty at the poles
                else:
                    latToUse = doubleKeo_AMPERE_latAlign[i];
                #END IF
                (doubleKeo_niteTimes_sunRise, doubleKeo_niteTimes_sunSet, doubleKeo_dateRange_fullPad) = sunAlsoRises(dateRange_full,latToUse,np.mean(doubleKeo_latLong[i][1])); #call sunrise/set function
            else:
                (doubleKeo_niteTimes_sunRise, doubleKeo_niteTimes_sunSet, doubleKeo_dateRange_fullPad) = sunAlsoRises(dateRange_full,np.mean(doubleKeo_latLong[i][0]),doubleKeo_AMPERE_latAlign[i]); #call sunrise/set function
            #END IF
            doubleKeo_dateRange_dayNum_fullPad = subfun_date_to_dayNum(doubleKeo_dateRange_fullPad); #convert to dayNum
            doubleKeo_niteTimes_sunRise = (doubleKeo_niteTimes_sunRise + doubleKeo_dateRange_dayNum_fullPad[:,1] - dateRange_dayNum_zeroHr[1])*24; #hrs, center around zero hr and convert ot hrs
            doubleKeo_niteTimes_sunSet = (doubleKeo_niteTimes_sunSet + doubleKeo_dateRange_dayNum_fullPad[:,1] - dateRange_dayNum_zeroHr[1])*24; #hrs, center around zero hr and convert ot hrs
            doubleKeo_niteTimes_sunRise = doubleKeo_niteTimes_sunRise[1:]; #remove 1st
            doubleKeo_niteTimes_sunSet = doubleKeo_niteTimes_sunSet[:-1]; #remove last
            #FIFTH STEP: PLOT THIS STUFF
            for j in range(0,doubleKeo_niteTimes_sunSet.size):
                # ax.axvspan(doubleKeo_AMPERE_niteTimes_array[j,0], doubleKeo_AMPERE_niteTimes_array[j,1], alpha=0.25, color='xkcd:black');
                if(doubleKeo_plotSpacingName[i] == 'Latitude'): #if Y axis is latitude, use latitude
                    recta = Rectangle((doubleKeo_niteTimes_sunSet[j], np.min(doubleKeo_latLong[i][0])), doubleKeo_niteTimes_sunRise[j]-doubleKeo_niteTimes_sunSet[j], np.diff(doubleKeo_latLong[i][0]).item(), edgecolor='xkcd:black', facecolor='xkcd:black', alpha=0.25); #make that patch
                    ax.add_patch(recta); #add on that patch
                else: #otherwise longitude
                    recta = Rectangle((doubleKeo_niteTimes_sunSet[j], np.min(doubleKeo_latLong[i][1])), doubleKeo_niteTimes_sunRise[j]-doubleKeo_niteTimes_sunSet[j], np.diff(doubleKeo_latLong[i][1]).item(), edgecolor='xkcd:black', facecolor='xkcd:black', alpha=0.25); #make that patch
                    ax.add_patch(recta); #add on that patch
                #END IF
            #END FOR j
        else:
            for j in range(0,dates['date range zero hr hours'].size):
                doubleKeo_niteTimes_per = dates['date range zero hr hours'][j] + np.asarray(doubleKeo_niteTimes[i]); #get the nite time ranges
                if(doubleKeo_plotSpacingName[i] == 'Latitude'): #if Y axis is latitude, use latitude
                    recta = Rectangle((doubleKeo_niteTimes_per[0], np.min(doubleKeo_latLong[i][0])), np.diff(doubleKeo_niteTimes_per).item(), np.diff(doubleKeo_latLong[i][0]).item(), edgecolor='xkcd:black', facecolor='xkcd:black', alpha=0.25); #make that patch
                    ax.add_patch(recta); #add on that patch
                else: #otherwise longitude
                    recta = Rectangle((doubleKeo_niteTimes_per[0], np.min(doubleKeo_latLong[i][1])), np.diff(doubleKeo_niteTimes_per).item(), np.diff(doubleKeo_latLong[i][1]).item(), edgecolor='xkcd:black', facecolor='xkcd:black', alpha=0.25); #make that patch
                    ax.add_patch(recta); #add on that patch
                #END IF
            #END FOR j
        #END IF
        
        #----- Now drawing line of interest -----
        if( doubleKeo_plotSpacingName[i] == 'Latitude' ): #if true, latitude
            if( (np.min(doubleKeo_latLong[i][0]) <= doubleKeo_AMPERE_latAlign[i]) & (np.max(doubleKeo_latLong[i][0]) >= doubleKeo_AMPERE_latAlign[i]) ): #only plot if it's in the lat range specified
                ax.plot( np.linspace(np.min((TEC_timeUnique[timeCutout_TEC_indexes[0]:timeCutout_TEC_indexes[1]+1] - dateRange_dayNum_zeroHr[1]*86400)/3600),np.max((TEC_timeUnique[timeCutout_TEC_indexes[0]:timeCutout_TEC_indexes[1]+1] - dateRange_dayNum_zeroHr[1]*86400)/3600),10,endpoint=True) , #X time hr
                    np.tile(doubleKeo_AMPERE_latAlign[i],10) , #Y latitude OR longitude arcdeg
                    c='xkcd:black',linewidth=settings['plot']['line width']['smol']); #plots a point with a black line
            #END IF
        else:
            if( (np.min(doubleKeo_latLong[i][1]) <= doubleKeo_AMPERE_latAlign[i]) & (np.max(doubleKeo_latLong[i][1]) >= doubleKeo_AMPERE_latAlign[i]) ): #only plot if it's in the lat range specified
                ax.plot( np.linspace(np.min((TEC_timeUnique[timeCutout_TEC_indexes[0]:timeCutout_TEC_indexes[1]+1] - dateRange_dayNum_zeroHr[1]*86400)/3600),np.max((TEC_timeUnique[timeCutout_TEC_indexes[0]:timeCutout_TEC_indexes[1]+1] - dateRange_dayNum_zeroHr[1]*86400)/3600),10,endpoint=True) , #X time hr
                    np.tile(doubleKeo_AMPERE_latAlign[i],10) , #Y latitude OR longitude arcdeg
                    c='xkcd:black',linewidth=settings['plot']['line width']['smol']); #plots a point with a black line
            #END IF
        #END IF
    #END FOR i
    
    #----- Label and make it look nice -----
    string_title = str(len(doubleKeo_latLong))+' '+settings['TEC']['name']+' Keograms on '+str(np.round(doubleKeo_angle_orig[i],2))+' deg Angle & Widths of '+ \
        str(np.round(doubleKeo_width,2))+' arcdeg \n Integrated '+AMPERE_plot_label_noUnits; #create mecha title
    if( FLG_doubleKeo_AMPERE_integrateMethod[i] == 0 ):
        string_title = string_title + ' within keo area'; #add to mecha title
    elif( FLG_doubleKeo_AMPERE_integrateMethod[i] == 1 ):
        string_title = string_title + ' within keo long & up to pole'; #add to mecha title
    elif( FLG_doubleKeo_AMPERE_integrateMethod[i] == 2 ):
        string_title = string_title + ' within keo long & up to '+str(doubleKeo_AMPERE_integrateMethod_val)+' degc lat'; #add to mecha title
    elif( FLG_doubleKeo_AMPERE_integrateMethod[i] == 3 ):
        if( (np.min(plotLatRange) <= 0) & (np.max(plotLatRange) >= 0) ):
            string_title = string_title + ' both Hemispheres'; #add to mecha title
        else:
            if( (np.min(plotLatRange) >= 0) & (np.max(plotLatRange) >= 0) ):
                #northern hemisphere
                string_title = string_title + ' Northern Hemisphere'; #add to mecha title
            else:
                #southern hemisphere
                string_title = string_title + ' Southern Hemisphere'; #add to mecha title
            #END IF
        #END IF
    #END IF
    string_title = string_title + ' w/ time delays of '+str(doubleKeo_AMPERE_timeDelay)+' hrs';
    ax.set_title(string_title,fontproperties=FONT_titleFM); #set the title
    if( i == len(doubleKeo_latLong)-1 ):
        ax.set_xlabel('Time in UT - 0 Hr on Day '+str(dateRange_dayNum_zeroHr[1])+', '+str(dateRange_dayNum_zeroHr[0])+' [hr]',fontproperties=FONT_axisLabelFM); #set the x axis label
    #END IF
    ax.set_ylabel(doubleKeo_plotSpacingName[i]+' [arcdeg]',fontproperties=FONT_axisLabelFM); #set the y axis label
    
    autoTick = (np.ceil(np.max(doubleKeo_plotSpacing)) - np.floor(np.min(doubleKeo_plotSpacing)))/13; #tries to split the latitude range into 13 parts (based off of 180/15+1)
    if( autoTick > 25 ):
        autoTick = 30; #sets the tick setting to 15 arcdegrees per tick
    elif( autoTick > 10 ):
        autoTick = 15; #sets the tick setting to 15 arcdegrees per tick
    elif( autoTick > 5 ):
        autoTick = 10; #sets the tick setting to 10 arcdegrees per tick
    elif( autoTick > 2 ):
        autoTick = 5; #sets the tick setting to 5 arcdegrees per tick
    elif( autoTick > 1 ):
        autoTick = 2; #sets the tick setting to 5 arcdegrees per tick
    elif( autoTick >= 0.6 ): #0.6 because 15/25 = 0.6, so there will be enough 1 arcdeg ticks
        autoTick = 1; #                                                        sets the tick setting to 1 arcdegree per tick
    else:
        autoTick = (np.max(doubleKeo_latLongComb) - np.min(doubleKeo_latLongComb))/13; #just goes for it if it's a super tiny range
    #END IF
    yAxisTicks = np.round(np.arange( np.floor(np.min(doubleKeo_plotSpacing)),np.ceil(np.max(doubleKeo_plotSpacing))+autoTick,autoTick ),2); #creates y ticks automagically
    ax.set_yticks(yAxisTicks); #set x axis ticks
    
    #-----Draw line from 1st TEC event to 2nd-----
    if( (doubleKeo_arrowTimes[0] >= np.min(time_cutout_range/3600)) & \
        (doubleKeo_arrowTimes[1] <= np.max(time_cutout_range/3600)) ):
        con = ConnectionPatch(xyA=(doubleKeo_arrowTimes[0],doubleKeo_AMPERE_latAlign[0]), coordsA=ax.transData, #-11.81 #-10.54
                              xyB=(doubleKeo_arrowTimes[1],doubleKeo_AMPERE_latAlign[1]), coordsB=ax.transData, #-11.13 #-9.96
                              arrowstyle="-|>", shrinkA=5, shrinkB=5,mutation_scale=20, fc="xkcd:pink",
                              color='xkcd:pink', linewidth=settings['plot']['line width']['plus']); #prep a line between plots
        fig.add_artist(con); #draw the line
    #END IF
    
    figFitter(fig); #fit the fig fast
    # fig.subplots_adjust(left = 0.055, right = 0.935, top = 0.96, bottom = 0.075, hspace = 0.18); #sets padding to small numbers for minimal white space
    #fig.tight_layout(); #function for a tight layout, doesn't seem to do much here
    plt.show(); #req to make plot show up
#END IF

if( FLG_doubleKeo_xcorr == 1 ):
    from scipy import signal
    from subfun_filter import subfun_filter
    from subfun_figFitter import figFitter
    from subfun_strstr import strstr
    from GRITI_spectral_analysisPlot import GRITI_spectral_analysisPlot
    from GRITI_spectral_6minAnalysisPlot import GRITI_spectral_6minAnalysisPlot
    from GRITI_keo_keogrammer import GRITI_keo_keogrammer
    import pickle
    
    #Unpack line widths
    PLOT_lineWidthThicc = PLOT_lineWidth['thicc']; #get the line widths
    PLOT_lineWidthDoublePlus = PLOT_lineWidth['double plus']; #get the line widths
    PLOT_lineWidthPlus = PLOT_lineWidth['plus']; #get the line widths
    PLOT_lineWidthRegularPlus = PLOT_lineWidth['regular plus']; #get the line widths
    PLOT_lineWidthRegular = PLOT_lineWidth['regular']; #get the line widths
    PLOT_lineWidthSmol = PLOT_lineWidth['smol']; #get the line widths
    
    #Unpack everything else
    doubleKeo_keo = data['double keo']['keo'];
    doubleKeo_latLong = data['double keo']['lat long'];
    doubleKeo_angle = data['double keo']['angle'];
    doubleKeo_width = data['double keo']['width'];
    doubleKeo_plotSpacing = data['double keo']['plot spacing'];
    doubleKeo_plotSpacingName = data['double keo']['plot spacing name'];
    doubleKeo_AMPERE_integrated = data['double keo']['AMPERE integrated'];
    doubleKeo_AMPERE_time = data['double keo']['AMPERE time'];
    doubleKeo_AMPERE_timeHr = data['double keo']['AMPERE time hr'];
    
    #--- Just FFTs for good measure --- ['high-pass & 0 mean','high-pass & log10 & 0 mean']
    doubleKeo_AMPERE_xcorr = [[] for jj in range(0,len(doubleKeo_latLong))]; #prep
    for i in range(0,len(doubleKeo_latLong)):
        #--- Remove NaNs, replace with 0's so filtering stuff works ---
        doubleKeo_AMPERE_xcorr[i] = np.copy(doubleKeo_AMPERE_integrated[i]); #copy over for edits
        doubleKeo_AMPERE_xcorr[i][np.isnan(doubleKeo_AMPERE_xcorr[i])] = 0; #replace NaNs with 0s
    #END FOR i
    GRITI_spectral_6minAnalysisPlot([[doubleKeo_keo[i][:, np.where( np.min(np.abs(doubleKeo_plotSpacing[i] - doubleKeo_AMPERE_latAlign[i])) == np.abs(doubleKeo_plotSpacing[i] - doubleKeo_AMPERE_latAlign[i]) )[0][0]],doubleKeo_AMPERE_xcorr[i]] for i in range(0,len(doubleKeo_latLong))],
        [[(TEC_timeUnique - dateRange_dayNum_zeroHr[1]*86400),AMPERE_timeUnique] for i in range(0,len(doubleKeo_latLong))], [['sec','sec'] for i in range(0,len(doubleKeo_latLong))],
        [[TEC_dataRate,AMPERE_data['data rate']] for i in range(0,len(doubleKeo_latLong))], [['sec','sec'] for i in range(0,len(doubleKeo_latLong))], 'min',
        [['none','none'] for i in range(0,len(doubleKeo_latLong))], [['fft','fft'] for i in range(0,len(doubleKeo_latLong))], dates, settings_spectra, settings_plot, settings_paths, 
        [['TEC Keo at '+str(np.round(doubleKeo_AMPERE_latAlign[i],2)).strip('0').strip('.')+' lat','AMPERE (Time Delay '+str(doubleKeo_AMPERE_timeDelay[i])+')'] for i in range(0,len(doubleKeo_latLong))],
        reduceWindow=0); #insane plot call
    
    #--- Filter and Align if Req'd ---
    doubleKeo_keo_xcorr = [[] for jj in range(0,len(doubleKeo_latLong))]; #prep
    doubleKeo_keo_xcorr_time = [[] for jj in range(0,len(doubleKeo_latLong))]; #prep
    doubleKeo_AMPERE_xcorr = [[] for jj in range(0,len(doubleKeo_latLong))]; #prep
    doubleKeo_AMPERE_xcorr_time = [[] for jj in range(0,len(doubleKeo_latLong))]; #prep
    doubleKeo_keo_dataRate = TEC_dataRate; #set data rates
    doubleKeo_AMPERE_dataRate = AMPERE_data['data rate']; #set data rates
    for i in range(0,len(doubleKeo_latLong)):
        #--- Remove NaNs, replace with 0's so filtering stuff works ---
        doubleKeo_AMPERE_xcorr[i] = np.copy(doubleKeo_AMPERE_integrated[i]); #copy over for edits
        doubleKeo_AMPERE_xcorr[i][np.isnan(doubleKeo_AMPERE_xcorr[i])] = 0; #replace NaNs with 0s
        
        #--- Filter if req'd ---
        doubleKeo_AMPERE_xcorr[i] = subfun_filter( doubleKeo_AMPERE_xcorr[i], doubleKeo_AMPERE_time[i], doubleKeo_xcorr_AMPERE_filtMethod, settings_spectra, dataRate = 360.); #AMPERE is forced to 6 min during integration
        doubleKeo_keo_xcorr[i] = subfun_filter( doubleKeo_keo[i][:, np.where( np.min(np.abs(doubleKeo_plotSpacing[i] - doubleKeo_AMPERE_latAlign[i])) == np.abs(doubleKeo_plotSpacing[i] - doubleKeo_AMPERE_latAlign[i]) )[0][0]], (TEC_timeUnique - dateRange_dayNum_zeroHr[1]*86400), doubleKeo_xcorr_TEC_filtMethod, settings_spectra, dataRate = TEC_dataRate);
        
        #--- Time match to 6 minutes on TEC time frame to deal with correlation stuff ---
        sixMin_timeUnique = np.arange(dates['date range zero hr hour bounds'][0]*3600,dates['date range zero hr hour bounds'][1]*3600,360); #sec, arange time stamps in 6 minute steps
        if( np.all(np.isclose((doubleKeo_AMPERE_time[i] - dateRange_dayNum_zeroHr[1]*86400),sixMin_timeUnique)) ):
            doubleKeo_AMPERE_xcorr_time[i] = doubleKeo_AMPERE_time[i]; #same
            # doubleKeo_AMPERE_timeHr[i] = (doubleKeo_AMPERE_time_adj - dateRange_dayNum_zeroHr[1]*86400)/3600; #hr, convert to hr with 0 hr at specified day
        else:
            doubleKeo_AMPERE_xcorr[i], doubleKeo_AMPERE_xcorr_time[i] = subfun_timeMatch(doubleKeo_AMPERE_xcorr[i], (doubleKeo_AMPERE_time[i] - dateRange_dayNum_zeroHr[1]*86400), sixMin_timeUnique, timeMatch_delta=360., FLG_removeNaNs=0, FLG_useSum=1); #time match alg to align to 6 minute cadence, add because it's a count (?)
            doubleKeo_AMPERE_xcorr_time[i] += dateRange_dayNum_zeroHr[1]*86400; #add back in the day offset b/c it's assumed it is there
            # doubleKeo_AMPERE_timeHr[i] = (doubleKeo_AMPERE_time_adj - dateRange_dayNum_zeroHr[1]*86400)/3600; #hr, convert to hr with 0 hr at specified day                #END IF
        #END IF
    
        #--- Time match to 6 minutes if needed ---
        sixMin_timeUnique = np.arange(dates['date range zero hr hour bounds'][0]*3600,dates['date range zero hr hour bounds'][1]*3600,360); #sec, arange time stamps in 6 minute steps
        if( (np.isclose(TEC_dataRate,360.) == False) ):
            doubleKeo_keo_xcorr[i], doubleKeo_keo_xcorr_time[i] = subfun_timeMatch(doubleKeo_keo_xcorr[i], (TEC_timeUnique - dateRange_dayNum_zeroHr[1]*86400), sixMin_timeUnique, timeMatch_delta=360., FLG_removeNaNs=0, FLG_useSum=0); #time match alg to align to 6 minute cadence, add because it's a count (?)
            # doubleKeo_keo_xcorr_time[i] = doubleKeo_keo_xcorr_time; #sec, convert to hr with 0 hr at specified day
            doubleKeo_keo_dataRate = 360; #set new data rate
        else:
            if( TEC_timeUnique.size == sixMin_timeUnique.size ):
                if( np.all(np.isclose((TEC_timeUnique - dateRange_dayNum_zeroHr[1]*86400),sixMin_timeUnique)) ):
                    #doubleKeo_keo_xcorr[i] = doubleKeo_keo[i][:,np.where( np.abs(np.min(doubleKeo_plotSpacing[i] - doubleKeo_AMPERE_latAlign[i])) == np.min(doubleKeo_plotSpacing[i] - doubleKeo_AMPERE_latAlign[i]) )[0][0]]
                    doubleKeo_keo_xcorr_time[i] = (TEC_timeUnique - dateRange_dayNum_zeroHr[1]*86400); #sec, convert to hr with 0 hr at specified day
                else:
                    doubleKeo_keo_xcorr[i], doubleKeo_keo_xcorr_time[i] = subfun_timeMatch(doubleKeo_keo_xcorr[i], (TEC_timeUnique - dateRange_dayNum_zeroHr[1]*86400), sixMin_timeUnique, timeMatch_delta=TEC_dataRate, FLG_useSum=0); #time match alg to align to 6 minute cadence, add because it's a count (?)
                #END IF
            else:
                doubleKeo_keo_xcorr[i], doubleKeo_keo_xcorr_time[i] = subfun_timeMatch(doubleKeo_keo_xcorr[i], (TEC_timeUnique - dateRange_dayNum_zeroHr[1]*86400), sixMin_timeUnique, timeMatch_delta=TEC_dataRate, FLG_useSum=0); #time match alg to align to 6 minute cadence, add because it's a count (?)
            #END IF
        #END IF
    #END FOR i
    
    #--- Whole Time Comparison ---
    Pxy_TECvAMPERE = [[] for jj in range(0,len(doubleKeo_latLong))]; #prep
    freqs_TECvAMPERE = [[] for jj in range(0,len(doubleKeo_latLong))]; #prep
    keo_xcorr_cutOut = [[] for jj in range(0,len(doubleKeo_latLong))]; #prep
    keo_xcorr_time_cutOut = [[] for jj in range(0,len(doubleKeo_latLong))]; #prep
    AMPERE_xcorr_cutOut = [[] for jj in range(0,len(doubleKeo_latLong))]; #prep
    AMPERE_xcorr_time_cutOut = [[] for jj in range(0,len(doubleKeo_latLong))]; #prep
    pwr_TEC = [[] for jj in range(0,len(doubleKeo_latLong))]; #prep
    pwr_AMPERE = [[] for jj in range(0,len(doubleKeo_latLong))]; #prep
    stringer = ''; #prep
    Fs = 1/(360); #sec, time delta in freq form
    for i in range(0,len(doubleKeo_latLong)):
        #TEC CUTOUT NOW
        keo_xcorr_cutOut[i] = doubleKeo_keo_xcorr[i];
        keo_xcorr_time_cutOut[i] = doubleKeo_keo_xcorr_time[i];
                
        #--- Time match to 6 minutes on TEC time frame to deal with correlation stuff ---
        sixMin_timeUnique = np.arange(dates['date range zero hr hour bounds'][0]*3600,dates['date range zero hr hour bounds'][1]*3600,360); #sec, arange time stamps in 6 minute steps
        if( np.all(np.isclose((doubleKeo_AMPERE_xcorr_time[i]  - dateRange_dayNum_zeroHr[1]*86400),sixMin_timeUnique)) ):
            doubleKeo_AMPERE_xcorr_adj = np.copy(doubleKeo_AMPERE_xcorr[i]); #copy it over, no changes needed
            doubleKeo_AMPERE_xcorr_time_adj = np.copy(doubleKeo_AMPERE_xcorr_time[i]); #copy it over, no changes needed
            # doubleKeo_AMPERE_timeHr[i] = (doubleKeo_AMPERE_time_adj - dateRange_dayNum_zeroHr[1]*86400)/3600; #hr, convert to hr with 0 hr at specified day
        else:
            doubleKeo_AMPERE_xcorr_adj, doubleKeo_AMPERE_xcorr_time_adj = subfun_timeMatch(doubleKeo_AMPERE_xcorr[i], (doubleKeo_AMPERE_xcorr_time[i] - dateRange_dayNum_zeroHr[1]*86400), sixMin_timeUnique, timeMatch_delta=360., FLG_removeNaNs=0, FLG_useSum=1); #time match alg to align to 6 minute cadence, add because it's a count (?)
            # doubleKeo_AMPERE_timeHr[i] = (doubleKeo_AMPERE_time_adj - dateRange_dayNum_zeroHr[1]*86400)/3600; #hr, convert to hr with 0 hr at specified day                #END IF
        #END IF
        
        #AMPERE CUTOUT NOW
        AMPERE_xcorr_cutOut[i] = doubleKeo_AMPERE_xcorr_adj;
        AMPERE_xcorr_cutOut[i][np.isnan(AMPERE_xcorr_cutOut[i])] = 0; #replace NaNs with 0s
        AMPERE_xcorr_time_cutOut[i] = doubleKeo_AMPERE_xcorr_time_adj;
        
        #CALC PWR
        pwr_TEC[i] = np.sqrt(1/keo_xcorr_cutOut[i].size*np.sum(keo_xcorr_cutOut[i]**2)); #estimate power of signal
        pwr_AMPERE[i] = np.sqrt(1/AMPERE_xcorr_cutOut[i].size*np.sum(AMPERE_xcorr_cutOut[i]**2)); #estimate power of signal
        
        [freqs_TECvAMPERE[i],Cxy_TECvAMPERE] = signal.csd(1/pwr_TEC[i]*keo_xcorr_cutOut[i],1/pwr_AMPERE[i]*AMPERE_xcorr_cutOut[i],window=settings['spectra']['window'],noverlap=settings['spectra']['noverlap'],nfft=settings['spectra']['nfft']['6min'],fs=Fs);
        Axy_TECvAMPERE = np.angle(Cxy_TECvAMPERE)*180/np.pi; 
        Pxy_TECvAMPERE[i] = np.abs(Cxy_TECvAMPERE);
        
        #Real quick side move to calc correlation coefficients
        R_keovsAMPERE = np.corrcoef(1/pwr_TEC[i]*keo_xcorr_cutOut[i],1/pwr_AMPERE[i]*AMPERE_xcorr_cutOut[i])[0,1];
        if( i == 0 ):
            stringer += 'Corr Coeff:\n';
        #END IF
        stringer += 'Whole Keo vs AMPERE #'+str(i+1)+': '+str(np.round(R_keovsAMPERE,3));
        if( i != len(doubleKeo_latLong)-1 ):
            stringer += ' | ';
        #END IF
    #END FOR i
    print(stringer); #report the coeff
    
    #--- ROLLING TIME DELAY TO FIND OPTIMAL CORR COEFF ---
    doubleKeo_AMPERE_timeDelay_shiftStep = 2; #minutes to step by
    doubleKeo_AMPERE_timeDelay_shift = [[] for jj in range(0,len(doubleKeo_latLong))]; #prep
    doubleKeo_AMPERE_timeDelay_shiftCorr = [[] for jj in range(0,len(doubleKeo_latLong))]; #prep
    for i in range(0,len(doubleKeo_latLong)):
        doubleKeo_AMPERE_timeDelay_shift[i] = np.arange(0,doubleKeo_AMPERE_timeDelay[i]*5+doubleKeo_AMPERE_timeDelay_shiftStep/60,doubleKeo_AMPERE_timeDelay_shiftStep/60); #get some time
        doubleKeo_AMPERE_timeDelay_shiftCorr[i] = np.empty(doubleKeo_AMPERE_timeDelay_shift[i].size); #preallocate it
        
        #--- Integrate AMPERE Data ---
        doubleKeo_AMPERE_integrated_static = GRITI_AMPERE_integrator(data['AMPERE'], dates, settings_AMPERE, doubleKeo_latLong[i][0], doubleKeo_latLong[i][1], FLG_doubleKeo_AMPERE_integrateMethod[i], doubleKeo_AMPERE_integrateMethod_val); #integrate with the integrator function
    
        #--- Filter if req'd ---
        doubleKeo_AMPERE_integrated_static = subfun_filter( doubleKeo_AMPERE_integrated_static, AMPERE_timeUnique, FLG_doubleKeo_AMPERE_filtMethod, settings_spectra, dataRate = AMPERE_data['data rate']); #filter (or not)
            
        for j in range(0,doubleKeo_AMPERE_timeDelay_shift[i].size):
            #--- Adjust by the time offset ---
            #Do this before the time matching so everything is well aligned
            if( np.isclose(np.mod(doubleKeo_AMPERE_timeDelay_shift[i][j]*3600,1),0.0) ):
                doubleKeo_AMPERE_time_adj = AMPERE_timeUnique + np.int32(doubleKeo_AMPERE_timeDelay_shift[i][j]*3600); #it all stays integers
            else:
                doubleKeo_AMPERE_time_adj = np.float64(AMPERE_timeUnique) + doubleKeo_AMPERE_timeDelay_shift[i][j]*3600; #it all becomes floats
            #END IF
            
            #--- Remove NaNs, replace with 0's so filtering stuff works ---
            doubleKeo_AMPERE_xcorr_adj =  np.copy(doubleKeo_AMPERE_integrated_static); #copy over for edits
            doubleKeo_AMPERE_xcorr_adj[np.isnan(doubleKeo_AMPERE_xcorr_adj)] = 0; #replace NaNs with 0s
            
            #--- Filter if req'd ---
            doubleKeo_AMPERE_xcorr_adj = subfun_filter( doubleKeo_AMPERE_xcorr_adj, AMPERE_timeUnique, doubleKeo_xcorr_AMPERE_filtMethod, settings_spectra, dataRate = 360.);
            
            #--- Time match to 6 minutes on TEC time frame to deal with correlation stuff ---
            sixMin_timeUnique = np.arange(dates['date range zero hr hour bounds'][0]*3600,dates['date range zero hr hour bounds'][1]*3600,360); #sec, arange time stamps in 6 minute steps
            if( np.all(np.isclose((doubleKeo_AMPERE_time_adj - dateRange_dayNum_zeroHr[1]*86400),sixMin_timeUnique)) ):
                pass
                # doubleKeo_AMPERE_xcorr_adj = np.copy(doubleKeo_AMPERE_xcorr_adj); #copy it over, no changes needed
                # doubleKeo_AMPERE_timeHr[i] = (doubleKeo_AMPERE_time_adj - dateRange_dayNum_zeroHr[1]*86400)/3600; #hr, convert to hr with 0 hr at specified day
            else:
                doubleKeo_AMPERE_xcorr_adj, _ = subfun_timeMatch(doubleKeo_AMPERE_xcorr_adj, (doubleKeo_AMPERE_time_adj - dateRange_dayNum_zeroHr[1]*86400), sixMin_timeUnique, timeMatch_delta=360., FLG_removeNaNs=0, FLG_useSum=1); #time match alg to align to 6 minute cadence, add because it's a count (?)
                # doubleKeo_AMPERE_timeHr[i] = (doubleKeo_AMPERE_time_adj - dateRange_dayNum_zeroHr[1]*86400)/3600; #hr, convert to hr with 0 hr at specified day                #END IF
            #END IF
            
            #--- Remove NaNs, replace with 0's so filtering stuff works ---
            # doubleKeo_AMPERE_xcorr_adj =  np.copy(doubleKeo_AMPERE_xcorr_adj); #copy over for edits
            doubleKeo_AMPERE_xcorr_adj[np.isnan(doubleKeo_AMPERE_xcorr_adj)] = 0; #replace NaNs with 0s
            
            #AMPERE CUTOUT NOW
            AMPERE_xcorr_cutOut_adj = doubleKeo_AMPERE_xcorr_adj;
            pwr_AMPERE_adj = np.sqrt(1/AMPERE_xcorr_cutOut_adj.size*np.sum(AMPERE_xcorr_cutOut_adj**2)); #estimate power of signal
            
            #Real quick side move to calc correlation coefficients
            doubleKeo_AMPERE_timeDelay_shiftCorr[i][j] = np.corrcoef(1/pwr_TEC[i]*keo_xcorr_cutOut[i],1/pwr_AMPERE_adj*AMPERE_xcorr_cutOut_adj)[0,1];
        #END FOR j
        k = np.where( doubleKeo_AMPERE_timeDelay_shiftCorr[i] == np.max(doubleKeo_AMPERE_timeDelay_shiftCorr[i]))[0]; #get maximum values
        k = k[np.min(np.mod(np.round(doubleKeo_AMPERE_timeDelay_shift[i][k]*60,10),6)) == np.mod(np.round(doubleKeo_AMPERE_timeDelay_shift[i][k]*60,10),6)].item(); #get one closest to 6 minutes
        print('Whole '+'#'+str(i+1)+' Maximum correlation possible: '+str(np.round(np.max(doubleKeo_AMPERE_timeDelay_shiftCorr[i]),3)).rstrip('0').rstrip('.')+' at time delay: '+str(doubleKeo_AMPERE_timeDelay_shift[i][k])+\
            ' Current time delay: '+str(doubleKeo_AMPERE_timeDelay[i]) );#print resupts
    #END FOR i
    
    #now, noise comparisons
    Pxy_TECNvAMPERE = [[] for jj in range(0,len(doubleKeo_latLong))]; #prep
    Pxy_TECvAMPEREN = [[] for jj in range(0,len(doubleKeo_latLong))]; #prep
    keo_noise_xcorr_cutOut = [[] for jj in range(0,len(doubleKeo_latLong))]; #prep
    AMPERE_noise_xcorr_cutOut = [[] for jj in range(0,len(doubleKeo_latLong))]; #prep
    pwr_TECN = [[] for jj in range(0,len(doubleKeo_latLong))]; #prep
    pwr_AMPEREN = [[] for jj in range(0,len(doubleKeo_latLong))]; #prep
    TECNvAMPERE_mat = np.empty((np.int64(512/2+1),avgPt_TECnoise_iterations));
    TECvAMPEREN_mat = np.empty((np.int64(512/2+1),avgPt_TECnoise_iterations));
    R_keoNvsAMPERE_mat = np.empty((avgPt_TECnoise_iterations));
    R_keovsAMPEREN_mat = np.empty((avgPt_TECnoise_iterations));
    R_keoNvsAMPERE = [[] for jj in range(0,len(doubleKeo_latLong))]; #prep
    R_keovsAMPEREN = [[] for jj in range(0,len(doubleKeo_latLong))]; #prep
    doubleKeo_keo_noise_xcorr = [[[] for kk in range(0,doubleKeo_xcorr_noiseIterations)] for jj in range(0,len(doubleKeo_latLong))]; #prep
    doubleKeo_AMPERE_noise_xcorr = [[[] for kk in range(0,doubleKeo_xcorr_noiseIterations)] for jj in range(0,len(doubleKeo_latLong))]; #prep
    stringer = ''; #prep
    for i in range(0,len(doubleKeo_latLong)):
        noiseHash = str(doubleKeo_latLong[i])+str(np.round(np.float64(doubleKeo_angle[i]),2)).rstrip('0').rstrip('.')+'_'+str(np.round(np.float64(doubleKeo_width[i]),2)).rstrip('0').rstrip('.')+'_'+ \
            str(doubleKeo_N[i])+'_'+str(doubleKeo_45vsLatLong[i])+'_'+str(doubleKeo_AMPERE_latAlign[i])+'_'+ \
            doubleKeo_xcorr_TEC_filtMethod.replace(' ','').replace('-','').lower() + \
            '_'+str(doubleKeo_xcorr_noiseIterations); #hash of all of the settings in string form 
            
            
        if( os.path.isfile(settings['paths']['cache']+'\\'+'keoTECnoise_'+noiseHash+'.pkl') == 1 ):
            #if the data already exists, load it in
            with open(settings['paths']['cache']+'\\'+'keoTECnoise_'+noiseHash+'.pkl', 'rb') as doubleKeo_filer:
                doubleKeo_keo_noise_xcorr[i] = pickle.load(doubleKeo_filer); #load in the data
            #END WITH
            FLG_doubleKeo_xcorr_makeNoise = 0; #set the flag to off, data was already made and saved
        else:
            FLG_doubleKeo_xcorr_makeNoise = 1; #set the flag to on, data needs to be made
            print('JSYK: Calculating TEC Noise, it takes a LONG time. Like 1.5-5 hrs depending on pts involved PER keogram zone (on '+str(i+1)+' of '+str(len(doubleKeo_latLong))+').'); #warn
            tic = time.time(); #prep timer
        #END IF
        
        for j in range(0,doubleKeo_xcorr_noiseIterations):
            #--- TEC Noise, EXPENSIVE CALCS if not cached ---
            if( FLG_doubleKeo_xcorr_makeNoise == 1 ):
                #!exxpensive NOISE CALCS on lots of data!
                k = ((np.min(doubleKeo_latLong[i][0]) <= data['TEC']['lat']) & (np.max(doubleKeo_latLong[i][0]) >= data['TEC']['lat'])) & \
                    ((np.min(doubleKeo_latLong[i][1]) <= data['TEC']['long']) & (np.max(doubleKeo_latLong[i][1]) >= data['TEC']['long'])); #get only east coast to lower calcs needed
                TEC_noise = GRITI_TEC_randomSynth(k.sum(),data['TEC']['lat'][k],data['TEC']['long'][k],data['TEC']['time'][k], \
                        noise_background_mean,noise_background_stdev,Re,dateRange_zeroHr, \
                        plotLatRange,plotLongRange,plotLatRange_autoTick,plotLongRange_autoTick, \
                        wave_latRange,wave_longRange,wave_N,wave_angle,wave_phase,wave_waveLength,wave_period,wave_amp, \
                        FONT_titleFM,FONT_axisTick,FONT_axisLabelFM,TEC_plotLimValu,1,FLG_plotStuff=0); #replace the delta-vTEC data with random data 
            
                (doubleKeo_keo_noise, _) = \
                    GRITI_keo_keogrammer(TEC_noise ,data['TEC']['time'][k], data['TEC']['lat'][k], data['TEC']['long'][k],
                        TEC_timeUnique, TEC_timeUnique, dates, \
                        settings['double keo'][i], settings_paths, settings_doubleKeo_map[i], settings_plot,
                        FLG_fancyPlot=FLG_fancyPlot,FLG_disablePlot=2,FLG_disableText=1,FLG_disableCache=1,FLG_useRightExact=0);
                        #call the mecha function that runs the keo alg and makes a plot showing the averaging are
                    
                #--- Filter if req'd ---
                doubleKeo_keo_noise_xcorr[i][j] = subfun_filter( doubleKeo_keo_noise[:, np.where( np.min(np.abs(doubleKeo_plotSpacing[i] - doubleKeo_AMPERE_latAlign[i])) == np.abs(doubleKeo_plotSpacing[i] - doubleKeo_AMPERE_latAlign[i]) )[0][0]], (TEC_timeUnique - dateRange_dayNum_zeroHr[1]*86400), doubleKeo_xcorr_TEC_filtMethod, settings_spectra, dataRate = TEC_dataRate);
        
                #--- Time match to 6 minutes if needed ---
                if( (np.isclose(TEC_dataRate,360.) == False) ):
                    doubleKeo_keo_noise_xcorr[i][j], _ = subfun_timeMatch(doubleKeo_keo_noise_xcorr[i][j], (TEC_timeUnique - dateRange_dayNum_zeroHr[1]*86400), sixMin_timeUnique, timeMatch_delta=360., FLG_removeNaNs=0, FLG_useSum=0); #time match alg to align to 6 minute cadence, add because it's a count (?)
                else:
                    if( TEC_timeUnique.size == sixMin_timeUnique.size ):
                        if( np.all(np.isclose((TEC_timeUnique - dateRange_dayNum_zeroHr[1]*86400),sixMin_timeUnique)) ):
                            #doubleKeo_keo_noise_xcorr[i][j] = doubleKeo_keo_noise[:,np.where( np.abs(np.min(doubleKeo_plotSpacing[i] - doubleKeo_AMPERE_latAlign[i])) == np.min(doubleKeo_plotSpacing[i] - doubleKeo_AMPERE_latAlign[i]) )[0][0]]
                            pass; 
                        else:
                            doubleKeo_keo_noise_xcorr[i][j], _ = subfun_timeMatch(doubleKeo_keo_noise_xcorr[i][j], (TEC_timeUnique - dateRange_dayNum_zeroHr[1]*86400), sixMin_timeUnique, timeMatch_delta=TEC_dataRate, FLG_useSum=0); #time match alg to align to 6 minute cadence, add because it's a count (?)
                        #END IF
                    else:
                        doubleKeo_keo_noise_xcorr[i][j], _ = subfun_timeMatch(doubleKeo_keo_noise_xcorr[i][j], (TEC_timeUnique - dateRange_dayNum_zeroHr[1]*86400), sixMin_timeUnique, timeMatch_delta=TEC_dataRate, FLG_useSum=0); #time match alg to align to 6 minute cadence, add because it's a count (?)
                    #END IF
                #END IF
            #END IF
            
            #--- AMPERE noise ---
            doubleKeo_AMPERE_noise_xcorr[i][j] = np.abs(np.random.normal(loc=0,scale=np.nanstd(doubleKeo_AMPERE_integrated[i]),size=doubleKeo_AMPERE_xcorr[i].size)); #create some fake data
            #--- Remove NaNs, replace with 0's so filtering stuff works ---
            doubleKeo_AMPERE_noise_xcorr[i][j][np.isnan(doubleKeo_AMPERE_noise_xcorr[i][j])] = 0; #replace NaNs with 0s
            #--- Filter if req'd ---
            doubleKeo_AMPERE_noise_xcorr[i][j] = subfun_filter( doubleKeo_AMPERE_noise_xcorr[i][j], AMPERE_timeUnique, doubleKeo_xcorr_AMPERE_filtMethod, settings_spectra, dataRate = AMPERE_data['data rate']);
            
            #TEC CUTOUT NOW
            keo_noise_xcorr_cutOut[i] = doubleKeo_keo_noise_xcorr[i][j];
            #keo_xcorr_time_cutOut[i] = doubleKeo_keo_xcorr_time[i]; #already made
            
            #AMPERE CUTOUT NOW
            AMPERE_noise_xcorr_cutOut[i] = doubleKeo_AMPERE_noise_xcorr[i][j];
            AMPERE_xcorr_time_cutOut[i] = doubleKeo_AMPERE_xcorr_time[i];
            
            #CALC PWR
            pwr_TECN[i] = np.sqrt(1/keo_noise_xcorr_cutOut[i].size*np.sum(keo_noise_xcorr_cutOut[i]**2)); #estimate power of signal
            pwr_AMPEREN[i] = np.sqrt(1/AMPERE_noise_xcorr_cutOut[i].size*np.sum(AMPERE_noise_xcorr_cutOut[i]**2)); #estimate power of signal
            
            [_,Cxy_TECNvAMPERE] = signal.csd(1/pwr_TECN[i]*keo_noise_xcorr_cutOut[i],1/pwr_AMPERE[i]*AMPERE_xcorr_cutOut[i],window=settings['spectra']['window'],noverlap=settings['spectra']['noverlap'],nfft=settings['spectra']['nfft']['6min'],fs=Fs);
            Axy_TECNvAMPERE = np.angle(Cxy_TECNvAMPERE)*180/np.pi; 
            Pxy_TECNvAMPERE[i] = np.abs(Cxy_TECNvAMPERE);
            
            [_,Cxy_TECvAMPEREN] = signal.csd(1/pwr_TEC[i]*keo_xcorr_cutOut[i],1/pwr_AMPEREN[i]*AMPERE_noise_xcorr_cutOut[i],window=settings['spectra']['window'],noverlap=settings['spectra']['noverlap'],nfft=settings['spectra']['nfft']['6min'],fs=Fs);
            Axy_TECvAMPEREN = np.angle(Cxy_TECvAMPEREN)*180/np.pi; 
            Pxy_TECvAMPEREN[i] = np.abs(Cxy_TECvAMPEREN);
            
            #RECORD FOR POSTERITY
            TECNvAMPERE_mat[:,j] = Pxy_TECNvAMPERE[i];
            TECvAMPEREN_mat[:,j] = Pxy_TECvAMPEREN[i];
            
            #Real quick side move to calc correlation coefficients
            R_keoNvsAMPERE_mat[j] = np.corrcoef(1/pwr_TECN[i]*keo_noise_xcorr_cutOut[i],1/pwr_AMPERE[i]*AMPERE_xcorr_cutOut[i])[0,1];
            R_keovsAMPEREN_mat[j] = np.corrcoef(1/pwr_TEC[i]*keo_xcorr_cutOut[i],1/pwr_AMPEREN[i]*AMPERE_noise_xcorr_cutOut[i])[0,1];
        #END FOR j
        if( FLG_doubleKeo_xcorr_makeNoise == 1 ):
            #save the noise data if it was newly made
            with open(settings['paths']['cache']+'\\'+'keoTECnoise_'+noiseHash+'.pkl', 'wb') as doubleKeo_filer:
                pickle.dump(doubleKeo_keo_noise_xcorr[i], doubleKeo_filer); #save that data
            #END WITH
            toc = time.time() - tic; #calc the time it took
            print('Time to run TEC noise making: '+str(np.round(toc/3600,2))+'.');
        #END IF
        
        R_keoNvsAMPERE[i] = np.mean(R_keoNvsAMPERE_mat);
        R_keovsAMPEREN[i] = np.mean(R_keovsAMPEREN_mat);
        stringer += '\nWhole Keo Noise '+str(doubleKeo_xcorr_noiseIterations)+' iterations vs AMPERE #'+str(i+1)+': '+str(np.round(R_keoNvsAMPERE[i],3));
        stringer += '\nWhole Keo vs AMPERE #'+str(i+1)+' Noise '+str(doubleKeo_xcorr_noiseIterations)+' iterations: '+str(np.round(R_keovsAMPEREN[i],3));
        Pxy_TECNvAMPERE[i] = np.mean(TECNvAMPERE_mat,axis=1);
        Pxy_TECvAMPEREN[i] = np.mean(TECvAMPEREN_mat,axis=1);
    #END FOR i
    print(stringer); #report the coeff
    
    #--- Start the plot ---
    fig, ax = plt.subplots(nrows=len(doubleKeo_latLong), ncols=1); #use instead of fig because it inits an axis too (I think I dunno)
    figManager = plt.get_current_fig_manager(); #req to maximize
    figManager.window.showMaximized(); #force maximized
    #Remove the aspect ratio from the basemap so it fills the screen better
    cntr = 0; #prep
    for i in range(0,len(doubleKeo_latLong)):
        ax[i].set_aspect('auto');
        pZ = []; #prep
        lZ = []; #prep
        
        pT, = ax[i].plot(keo_xcorr_time_cutOut[i]/3600,1/pwr_TEC[i]*keo_xcorr_cutOut[i],color=settings['plot']['color'][cntr],linewidth=PLOT_lineWidthPlus, linestyle=settings['plot']['line style'][cntr]);
        cntr += 1; #increment
        pZ.append(pT); #add onto the plot list
        lZ.append('Keo #'+str(cntr+1)); #add onto the legend list
        
        pT, = ax[i].plot( (AMPERE_xcorr_time_cutOut[i]-dateRange_dayNum_zeroHr[1]*86400)/3600,1/pwr_AMPERE[i]*AMPERE_xcorr_cutOut[i],color=settings['plot']['color'][cntr],linewidth=PLOT_lineWidthPlus, linestyle=settings['plot']['line style'][cntr]);
        cntr += 1; #increment
        pZ.append(pT); #add onto the plot list
        lZ.append('AMPERE #'+str(cntr+1)); #add onto the legend list
        
        pT, = ax[i].plot(keo_xcorr_time_cutOut[i]/3600,1/pwr_TECN[i]*keo_noise_xcorr_cutOut[i],color=settings['plot']['color'][cntr],linewidth=PLOT_lineWidthPlus, linestyle=settings['plot']['line style'][cntr]);
        cntr += 1; #increment
        pZ.append(pT); #add onto the plot list
        lZ.append('Keo Noise (Last Iteration) #'+str(cntr+1)); #add onto the legend list
        
        pT, = ax[i].plot( (AMPERE_xcorr_time_cutOut[i]-dateRange_dayNum_zeroHr[1]*86400)/3600,1/pwr_AMPEREN[i]*AMPERE_noise_xcorr_cutOut[i],color=settings['plot']['color'][cntr],linewidth=PLOT_lineWidthPlus, linestyle=settings['plot']['line style'][cntr]);
        cntr += 1; #increment
        pZ.append(pT); #add onto the plot list
        lZ.append('AMPERE Noise (Last Iteration) #'+str(cntr+1)); #add onto the legend list
        
        ax[i].legend(pZ, lZ, loc='upper right', framealpha=0.5);
        ax[i].set_ylabel('Normalized Ampltiude',fontproperties=FONT_axisLabelFM);
        
        ax[i].set_title('TEC Keo at '+str(np.round(doubleKeo_AMPERE_latAlign[i],2)).strip('0').strip('.')+' lat & AMPERE (Time Delay '+str(doubleKeo_AMPERE_timeDelay[i])+') Whole Time on Day '+str(dateRange_dayNum_zeroHr[1])+', '+str(dateRange_dayNum_zeroHr[0]), \
            fontproperties=FONT_titleFM);
    #END FOR i
    ax[i].set_xlabel('Time [hr]',fontproperties=FONT_axisLabelFM);
    
    
    # xAxisTicks = np.arange( 0, settings['spectra']['period limit max']/60+10, 10); #sets the start hr, stop hr, and the step size between (in this case, 2 hr)
    # ax.set_xticks(xAxisTicks); #set x axis ticks
    # ax.set_xlim( (settings['spectra']['period limit min']/60, settings['spectra']['period limit max']/60) );
    #final plot adjusting stuff
    figFitter(fig); #fit that fig fast
    #fig.subplots_adjust(left = 0.065, right = 0.975, top = 0.96, bottom = 0.065 , hspace = 0.225); #sets padding to small numbers for minimal white space
    #fig.tight_layout(); #function for a tight layout, doesn't seem to do much here
    plt.show(); #req to make plot show up
    
    #--- Start the plot ---
    warnings.filterwarnings("ignore", category=RuntimeWarning); #silences warnings about NaNs used in a logical comparisons #yolo
    fig, ax = plt.subplots(nrows=len(doubleKeo_latLong), ncols=1); #use instead of fig because it inits an axis too (I think I dunno)
    figManager = plt.get_current_fig_manager(); #req to maximize
    figManager.window.showMaximized(); #force maximized
    #Remove the aspect ratio from the basemap so it fills the screen better

    cntr = 0; #prep
    for i in range(0,len(doubleKeo_latLong)):
        ax[i].set_aspect('auto');
        pZ = []; #prep
        lZ = []; #prep
        
        pT, = ax[i].plot(1/freqs_TECvAMPERE[i]/60,(Pxy_TECvAMPERE[i]),color=settings['plot']['color'][cntr],linewidth=PLOT_lineWidthPlus, linestyle=settings['plot']['line style'][cntr]);
        cntr += 1; #increment
        pZ.append(pT); #add onto the plot list
        lZ.append('Whole Keo vs AMPERE #'+str(i+1)); #add onto the legend list
        
        pT, = ax[i].plot(1/freqs_TECvAMPERE[i]/60,(Pxy_TECNvAMPERE[i]),color=settings['plot']['color'][cntr],linewidth=PLOT_lineWidthPlus, linestyle=settings['plot']['line style'][cntr]);
        cntr += 1; #increment
        pZ.append(pT); #add onto the plot list
        lZ.append('Whole Keo Noise '+str(doubleKeo_xcorr_noiseIterations)+' iterations vs AMPERE #'+str(i+1)); #add onto the legend list
        
        pT, = ax[i].plot(1/freqs_TECvAMPERE[i]/60,(Pxy_TECvAMPEREN[i]),color=settings['plot']['color'][cntr],linewidth=PLOT_lineWidthPlus, linestyle=settings['plot']['line style'][cntr]);
        cntr += 1; #increment
        pZ.append(pT); #add onto the plot list
        lZ.append('Whole Keo '+str(doubleKeo_xcorr_noiseIterations)+' iterations vs AMPERE Noise #'+str(i+1)); #add onto the legend list
    
        ax[i].set_ylabel('Arb. Power',fontproperties=FONT_axisLabelFM);
        ax[i].set_title('CSD - TEC Keo at '+str(np.round(doubleKeo_AMPERE_latAlign[i],2)).strip('0').strip('.')+' lat & AMPERE (Time Delay '+str(doubleKeo_AMPERE_timeDelay[i])+') Whole Time on Day '+str(dateRange_dayNum_zeroHr[1])+', '+str(dateRange_dayNum_zeroHr[0]), \
            fontproperties=FONT_titleFM);
        ax[i].legend(pZ, lZ, loc='upper right', framealpha=0.5);
        
        xAxisTicks = np.arange( 0, settings['spectra']['period limit max']/60+10, 10); #sets the start hr, stop hr, and the step size between (in this case, 2 hr)
        ax[i].set_xticks(xAxisTicks); #set x axis ticks
        ax[i].set_xlim( (settings['spectra']['period limit min']/60, settings['spectra']['period limit max']/60) );
    #END FOR i
    ax[i].set_xlabel('Periods [min]',fontproperties=FONT_axisLabelFM);
    
    #final plot adjusting stuff
    figFitter(fig); #fit that fig fast
    #fig.subplots_adjust(left = 0.065, right = 0.975, top = 0.96, bottom = 0.065 , hspace = 0.225); #sets padding to small numbers for minimal white space
    #fig.tight_layout(); #function for a tight layout, doesn't seem to do much here
    plt.show(); #req to make plot show up
    warnings.filterwarnings("default", category=RuntimeWarning); #silences warnings about NaNs used in a logical comparisons #yolo
    
    #--- Just FFTs for good measure --- ['high-pass & 0 mean','high-pass & log10 & 0 mean']
    GRITI_spectral_6minAnalysisPlot([[keo_xcorr_cutOut[i],AMPERE_xcorr_cutOut[i],keo_noise_xcorr_cutOut[i],AMPERE_noise_xcorr_cutOut[i]] for i in range(0,len(doubleKeo_latLong))], 
        [[keo_xcorr_time_cutOut[i],AMPERE_xcorr_time_cutOut[i],keo_xcorr_time_cutOut[i],AMPERE_xcorr_time_cutOut[i]] for i in range(0,len(doubleKeo_latLong))], 
        [['sec','sec','sec','sec'] for i in range(0,len(doubleKeo_latLong))], [[360.,360.,360.,360.] for i in range(0,len(doubleKeo_latLong))], 
        [['sec','sec','sec','sec'] for i in range(0,len(doubleKeo_latLong))], 'min',
        [['none','none','none','none'] for i in range(0,len(doubleKeo_latLong))], [['fft','fft','fft','fft'] for i in range(0,len(doubleKeo_latLong))], 
        dates, settings_spectra, settings_plot, settings_paths, 
        [['TEC Keo at '+str(np.round(doubleKeo_AMPERE_latAlign[i],2)).strip('0').strip('.'),'AMPERE (Time Delay '+str(doubleKeo_AMPERE_timeDelay[i])+')','TEC Keo Noise '+str(doubleKeo_xcorr_noiseIterations)+' iterations at '+str(np.round(doubleKeo_AMPERE_latAlign[i],2)).strip('0').strip('.'),'AMPERE (Time Delay '+str(doubleKeo_AMPERE_timeDelay[i])+') Noise '+str(doubleKeo_xcorr_noiseIterations)+' iterations'] for i in range(0,len(doubleKeo_latLong))],
        reduceWindow=0); #insane plot call
    
    #--- Cutout Time Comparison ---
    Pxy_TECvAMPERE = [[] for jj in range(0,len(doubleKeo_latLong))]; #prep
    freqs_TECvAMPERE = [[] for jj in range(0,len(doubleKeo_latLong))]; #prep
    keo_xcorr_cutOut = [[] for jj in range(0,len(doubleKeo_latLong))]; #prep
    keo_xcorr_time_cutOut = [[] for jj in range(0,len(doubleKeo_latLong))]; #prep
    AMPERE_xcorr_cutOut = [[] for jj in range(0,len(doubleKeo_latLong))]; #prep
    AMPERE_xcorr_time_cutOut = [[] for jj in range(0,len(doubleKeo_latLong))]; #prep
    pwr_TEC = [[] for jj in range(0,len(doubleKeo_latLong))]; #prep
    pwr_AMPERE = [[] for jj in range(0,len(doubleKeo_latLong))]; #prep
    stringer = ''; #prep
    Fs = 1/(360); #sec, time delta in freq form
    for i in range(0,len(doubleKeo_latLong)):
        #TEC CUTOUT NOW
        time_cutout_indexes = np.array( ( np.where(np.min(np.abs( doubleKeo_keo_xcorr_time[i] - np.min(time_cutout_range) )) == np.abs( doubleKeo_keo_xcorr_time[i] - np.min(time_cutout_range) ) )[0][0] , \
            np.where(np.min(np.abs( doubleKeo_keo_xcorr_time[i] - np.max(time_cutout_range) )) == np.abs( doubleKeo_keo_xcorr_time[i] - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range
        keo_xcorr_cutOut[i] = doubleKeo_keo_xcorr[i][time_cutout_indexes[0]:time_cutout_indexes[1]+1];
        keo_xcorr_time_cutOut[i] = doubleKeo_keo_xcorr_time[i][time_cutout_indexes[0]:time_cutout_indexes[1]+1];
        
        #AMPERE CUTOUT NOW
        time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (doubleKeo_AMPERE_xcorr_time[i]-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (doubleKeo_AMPERE_xcorr_time[i]-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , \
            np.where(np.min(np.abs( (doubleKeo_AMPERE_xcorr_time[i]-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (doubleKeo_AMPERE_xcorr_time[i]-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range
        AMPERE_xcorr_cutOut[i] = doubleKeo_AMPERE_xcorr[i][time_cutout_indexes[0]:time_cutout_indexes[1]+1];
        AMPERE_xcorr_time_cutOut[i] = doubleKeo_AMPERE_xcorr_time[i][time_cutout_indexes[0]:time_cutout_indexes[1]+1];
        
        #enforce a local 0 mean
        if( strstr(doubleKeo_xcorr_AMPERE_filtMethod.lower().replace('-','').replace(' ',''),'0mean').size > 0 ):
            AMPERE_xcorr_cutOut[i] = subfun_filter( AMPERE_xcorr_cutOut[i], AMPERE_xcorr_time_cutOut[i], '0 mean', settings_spectra);
        #END IF
        if( strstr(doubleKeo_xcorr_TEC_filtMethod.lower().replace('-','').replace(' ',''),'0mean').size > 0 ):
            keo_xcorr_cutOut[i] = subfun_filter( keo_xcorr_cutOut[i], keo_xcorr_time_cutOut[i], '0 mean', settings_spectra);
        #END IF
        
        #CALC PWR
        pwr_TEC[i] = np.sqrt(1/keo_xcorr_cutOut[i].size*np.sum(keo_xcorr_cutOut[i]**2)); #estimate power of signal
        pwr_AMPERE[i] = np.sqrt(1/AMPERE_xcorr_cutOut[i].size*np.sum(AMPERE_xcorr_cutOut[i]**2)); #estimate power of signal
        
        if( (settings['spectra']['window'].size > keo_xcorr_cutOut[i].size) | (settings['spectra']['window'].size  > AMPERE_xcorr_cutOut[i].size) ):
            if( keo_xcorr_cutOut[i].size < AMPERE_xcorr_cutOut[i].size ):
                winnow = np.hamming(keo_xcorr_cutOut[i].size - 1); #adjust
            else:
                winnow = np.hamming(AMPERE_xcorr_cutOut[i].size - 1); #adjust
            #END IF
            nooverlap = winnow.size - 10; #adjust
        else:
            winnow = settings['spectra']['window']; #keep reg
            nooverlap = settings['spectra']['noverlap']; #keep reg
        #END IF
        
        #CALC THE XCORR
        [freqs_TECvAMPERE[i],Cxy_TECvAMPERE] = signal.csd(1/pwr_TEC[i]*keo_xcorr_cutOut[i],1/pwr_AMPERE[i]*AMPERE_xcorr_cutOut[i],window=winnow,noverlap=nooverlap,nfft=settings['spectra']['nfft']['6min'],fs=Fs);
        Axy_TECvAMPERE = np.angle(Cxy_TECvAMPERE)*180/np.pi; 
        Pxy_TECvAMPERE[i] = np.abs(Cxy_TECvAMPERE);
        
        #Real quick side move to calc correlation coefficients
        R_keovsAMPERE = np.corrcoef(1/pwr_TEC[i]*keo_xcorr_cutOut[i],1/pwr_AMPERE[i]*AMPERE_xcorr_cutOut[i])[0,1];
        if( i == 0 ):
            stringer += 'Corr Coeff:\n';
        #END IF
        stringer += 'Cutout '+str(time_cutout_range/3600)+' Keo vs AMPERE #'+str(i+1)+': '+str(np.round(R_keovsAMPERE,3));
        if( i != len(doubleKeo_latLong)-1 ):
            stringer += ' | ';
        #END IF
    #END FOR i
    print(stringer); #report the coeff
    
    #--- ROLLING TIME DELAY TO FIND OPTIMAL CORR COEFF ---
    doubleKeo_AMPERE_timeDelay_shift = [[] for jj in range(0,len(doubleKeo_latLong))]; #prep
    doubleKeo_AMPERE_timeDelay_shiftCorr = [[] for jj in range(0,len(doubleKeo_latLong))]; #prep
    for i in range(0,len(doubleKeo_latLong)):
        doubleKeo_AMPERE_timeDelay_shift[i] = np.arange(0,doubleKeo_AMPERE_timeDelay[i]*5+doubleKeo_AMPERE_timeDelay_shiftStep/60,doubleKeo_AMPERE_timeDelay_shiftStep/60); #get some time
        doubleKeo_AMPERE_timeDelay_shiftCorr[i] = np.empty(doubleKeo_AMPERE_timeDelay_shift[i].size); #preallocate it
        
        #--- Integrate AMPERE Data ---
        doubleKeo_AMPERE_integrated_static = GRITI_AMPERE_integrator(data['AMPERE'], dates, settings_AMPERE, doubleKeo_latLong[i][0], doubleKeo_latLong[i][1], FLG_doubleKeo_AMPERE_integrateMethod[i], doubleKeo_AMPERE_integrateMethod_val); #integrate with the integrator function
    
        #--- Filter if req'd ---
        doubleKeo_AMPERE_integrated_static = subfun_filter( doubleKeo_AMPERE_integrated_static, AMPERE_timeUnique, FLG_doubleKeo_AMPERE_filtMethod, settings_spectra, dataRate = AMPERE_data['data rate']); #filter (or not)
            
        for j in range(0,doubleKeo_AMPERE_timeDelay_shift[i].size):
            #--- Adjust by the time offset ---
            #Do this before the time matching so everything is well aligned
            if( np.isclose(np.mod(doubleKeo_AMPERE_timeDelay_shift[i][j]*3600,1),0.0) ):
                doubleKeo_AMPERE_time_adj = AMPERE_timeUnique + np.int32(doubleKeo_AMPERE_timeDelay_shift[i][j]*3600); #it all stays integers
            else:
                doubleKeo_AMPERE_time_adj = np.float64(AMPERE_timeUnique) + doubleKeo_AMPERE_timeDelay_shift[i][j]*3600; #it all becomes floats
            #END IF
            
            #--- Remove NaNs, replace with 0's so filtering stuff works ---
            doubleKeo_AMPERE_xcorr_adj =  np.copy(doubleKeo_AMPERE_integrated_static); #copy over for edits
            doubleKeo_AMPERE_xcorr_adj[np.isnan(doubleKeo_AMPERE_xcorr_adj)] = 0; #replace NaNs with 0s
            
            #--- Filter if req'd ---
            doubleKeo_AMPERE_xcorr_adj = subfun_filter( doubleKeo_AMPERE_xcorr_adj, AMPERE_timeUnique, doubleKeo_xcorr_AMPERE_filtMethod, settings_spectra, dataRate = 360.);
            
            #--- Time match to 6 minutes on TEC time frame to deal with correlation stuff ---
            sixMin_timeUnique = np.arange(dates['date range zero hr hour bounds'][0]*3600,dates['date range zero hr hour bounds'][1]*3600,360); #sec, arange time stamps in 6 minute steps
            if( np.all(np.isclose((doubleKeo_AMPERE_time_adj - dateRange_dayNum_zeroHr[1]*86400),sixMin_timeUnique)) ):
                pass
                # doubleKeo_AMPERE_xcorr_adj = np.copy(doubleKeo_AMPERE_xcorr_adj); #copy it over, no changes needed
                # doubleKeo_AMPERE_timeHr[i] = (doubleKeo_AMPERE_time_adj - dateRange_dayNum_zeroHr[1]*86400)/3600; #hr, convert to hr with 0 hr at specified day
            else:
                doubleKeo_AMPERE_xcorr_adj, doubleKeo_AMPERE_time_adj = subfun_timeMatch(doubleKeo_AMPERE_xcorr_adj, (doubleKeo_AMPERE_time_adj - dateRange_dayNum_zeroHr[1]*86400), sixMin_timeUnique, timeMatch_delta=360., FLG_removeNaNs=0, FLG_useSum=1); #time match alg to align to 6 minute cadence, add because it's a count (?)
                doubleKeo_AMPERE_time_adj += dateRange_dayNum_zeroHr[1]*86400; #add back in the day offset b/c it's assumed it is there
                # doubleKeo_AMPERE_timeHr[i] = (doubleKeo_AMPERE_time_adj - dateRange_dayNum_zeroHr[1]*86400)/3600; #hr, convert to hr with 0 hr at specified day                #END IF
            #END IF
            
            #--- Remove NaNs, replace with 0's so filtering stuff works ---
            # doubleKeo_AMPERE_xcorr_adj =  np.copy(doubleKeo_AMPERE_integrated_static); #copy over for edits
            doubleKeo_AMPERE_xcorr_adj[np.isnan(doubleKeo_AMPERE_xcorr_adj)] = 0; #replace NaNs with 0s
                        
            #AMPERE CUTOUT NOW
            time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (doubleKeo_AMPERE_time_adj-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (doubleKeo_AMPERE_time_adj-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , \
                np.where(np.min(np.abs( (doubleKeo_AMPERE_time_adj-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (doubleKeo_AMPERE_time_adj-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range
            AMPERE_xcorr_cutOut_adj = doubleKeo_AMPERE_xcorr_adj[time_cutout_indexes[0]:time_cutout_indexes[1]+1];

            pwr_AMPERE_adj = np.sqrt(1/AMPERE_xcorr_cutOut_adj.size*np.sum(AMPERE_xcorr_cutOut_adj**2)); #estimate power of signal
            
            #Real quick side move to calc correlation coefficients
            doubleKeo_AMPERE_timeDelay_shiftCorr[i][j] = np.corrcoef(1/pwr_TEC[i]*keo_xcorr_cutOut[i],1/pwr_AMPERE_adj*AMPERE_xcorr_cutOut_adj)[0,1];
        #END FOR j
        k = np.where( doubleKeo_AMPERE_timeDelay_shiftCorr[i] == np.max(doubleKeo_AMPERE_timeDelay_shiftCorr[i]))[0]; #get maximum values
        k = k[np.min(np.mod(np.round(doubleKeo_AMPERE_timeDelay_shift[i][k]*60,10),6)) == np.mod(np.round(doubleKeo_AMPERE_timeDelay_shift[i][k]*60,10),6)].item(); #get one closest to 6 minutes
        print('Cutout '+str(time_cutout_range/3600)+'#'+str(i+1)+' Maximum correlation possible: '+str(np.round(np.max(doubleKeo_AMPERE_timeDelay_shiftCorr[i]),3)).rstrip('0').rstrip('.')+' at time delay: '+str(doubleKeo_AMPERE_timeDelay_shift[i][k])+\
            ' Current time delay: '+str(doubleKeo_AMPERE_timeDelay[i]) );#print resupts
    #END FOR i
    
    #now, noise comparisons
    Pxy_TECNvAMPERE = [[] for jj in range(0,len(doubleKeo_latLong))]; #prep
    keo_noise_xcorr_cutOut = [[] for jj in range(0,len(doubleKeo_latLong))]; #prep
    pwr_TECN = [[] for jj in range(0,len(doubleKeo_latLong))]; #prep
    TECNvAMPERE_mat = np.empty((np.int64(512/2+1),avgPt_TECnoise_iterations));
    R_keoNvsAMPERE_mat = np.empty((avgPt_TECnoise_iterations));
    R_keoNvsAMPERE = [[] for jj in range(0,len(doubleKeo_latLong))]; #prep
    stringer = ''; #prep
    for i in range(0,len(doubleKeo_latLong)):
        for j in range(0,doubleKeo_xcorr_noiseIterations):       
            #already did the exxpensive noise raytracing calcs earlier, can re-use here
                
            #TEC CUTOUT NOW
            time_cutout_indexes = np.array( ( np.where(np.min(np.abs( doubleKeo_keo_xcorr_time[i] - np.min(time_cutout_range) )) == np.abs( doubleKeo_keo_xcorr_time[i] - np.min(time_cutout_range) ) )[0][0] , \
                np.where(np.min(np.abs( doubleKeo_keo_xcorr_time[i] - np.max(time_cutout_range) )) == np.abs( doubleKeo_keo_xcorr_time[i] - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range
            keo_noise_xcorr_cutOut[i] = doubleKeo_keo_noise_xcorr[i][j][time_cutout_indexes[0]:time_cutout_indexes[1]+1];
            keo_xcorr_time_cutOut[i] = doubleKeo_keo_xcorr_time[i][time_cutout_indexes[0]:time_cutout_indexes[1]+1];
            
            #AMPERE CUTOUT NOW
            time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (doubleKeo_AMPERE_xcorr_time[i]-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (doubleKeo_AMPERE_xcorr_time[i]-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , \
                np.where(np.min(np.abs( (doubleKeo_AMPERE_xcorr_time[i]-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (doubleKeo_AMPERE_xcorr_time[i]-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range
            AMPERE_noise_xcorr_cutOut[i] = doubleKeo_AMPERE_noise_xcorr[i][j][time_cutout_indexes[0]:time_cutout_indexes[1]+1];
            AMPERE_xcorr_time_cutOut[i] = doubleKeo_AMPERE_xcorr_time[i][time_cutout_indexes[0]:time_cutout_indexes[1]+1];
            
            #enforce a local 0 mean
            if( strstr(doubleKeo_xcorr_TEC_filtMethod.lower().replace('-','').replace(' ',''),'0mean').size > 0 ):
                keo_noise_xcorr_cutOut[i] = subfun_filter( keo_noise_xcorr_cutOut[i], keo_xcorr_time_cutOut[i], '0 mean', settings_spectra);
            #END IF
            if( strstr(doubleKeo_xcorr_AMPERE_filtMethod.lower().replace('-','').replace(' ',''),'0mean').size > 0 ):
                AMPERE_noise_xcorr_cutOut[i] = subfun_filter( AMPERE_noise_xcorr_cutOut[i], AMPERE_xcorr_time_cutOut[i], '0 mean', settings_spectra);
            #END IF
            
            #CALC PWR
            pwr_TECN[i] = np.sqrt(1/keo_noise_xcorr_cutOut[i].size*np.sum(keo_noise_xcorr_cutOut[i]**2)); #estimate power of signal
            pwr_AMPEREN[i] = np.sqrt(1/AMPERE_noise_xcorr_cutOut[i].size*np.sum(AMPERE_noise_xcorr_cutOut[i]**2)); #estimate power of signal
            
            if( (settings['spectra']['window'].size > keo_noise_xcorr_cutOut[i].size) | (settings['spectra']['window'].size  > AMPERE_noise_xcorr_cutOut[i].size) ):
                if( keo_noise_xcorr_cutOut[i].size < AMPERE_noise_xcorr_cutOut[i].size ):
                    winnow = np.hamming(keo_noise_xcorr_cutOut[i].size - 1); #adjust
                else:
                    winnow = np.hamming(AMPERE_noise_xcorr_cutOut[i].size - 1); #adjust
                #END IF
                nooverlap = winnow.size - 10; #adjust
            else:
                winnow = settings['spectra']['window']; #keep reg
                nooverlap = settings['spectra']['noverlap']; #keep reg
            #END IF
            
            [_,Cxy_TECNvAMPERE] = signal.csd(1/pwr_TECN[i]*keo_noise_xcorr_cutOut[i],1/pwr_AMPERE[i]*AMPERE_xcorr_cutOut[i],window=winnow,noverlap=nooverlap,nfft=settings['spectra']['nfft']['6min'],fs=Fs);
            Axy_TECNvAMPERE = np.angle(Cxy_TECNvAMPERE)*180/np.pi; 
            Pxy_TECNvAMPERE[i] = np.abs(Cxy_TECNvAMPERE);
            
            [_,Cxy_TECvAMPEREN] = signal.csd(1/pwr_TEC[i]*keo_xcorr_cutOut[i],1/pwr_AMPEREN[i]*AMPERE_noise_xcorr_cutOut[i],window=winnow,noverlap=nooverlap,nfft=settings['spectra']['nfft']['6min'],fs=Fs);
            Axy_TECvAMPEREN = np.angle(Cxy_TECvAMPEREN)*180/np.pi; 
            Pxy_TECvAMPEREN[i] = np.abs(Cxy_TECvAMPEREN);
            
            #RECORD FOR POSTERITY
            TECNvAMPERE_mat[:,j] = Pxy_TECNvAMPERE[i];
            TECvAMPEREN_mat[:,j] = Pxy_TECvAMPEREN[i];
            
            #Real quick side move to calc correlation coefficients
            R_keoNvsAMPERE_mat[j] = np.corrcoef(1/pwr_TECN[i]*keo_noise_xcorr_cutOut[i],1/pwr_AMPERE[i]*AMPERE_xcorr_cutOut[i])[0,1];
            R_keovsAMPEREN_mat[j] = np.corrcoef(1/pwr_TEC[i]*keo_xcorr_cutOut[i],1/pwr_AMPEREN[i]*AMPERE_noise_xcorr_cutOut[i])[0,1];
        #END FOR j
        R_keoNvsAMPERE[i] = np.mean(R_keoNvsAMPERE_mat);
        R_keovsAMPEREN[i] = np.mean(R_keovsAMPEREN_mat);
        stringer += '\nCutout '+str(time_cutout_range/3600)+' Keo Noise '+str(doubleKeo_xcorr_noiseIterations)+' iterations vs AMPERE #'+str(i+1)+': '+str(np.round(R_keoNvsAMPERE[i],3));
        stringer += '\nCutout '+str(time_cutout_range/3600)+' Keo vs AMPERE #'+str(i+1)+' Noise '+str(doubleKeo_xcorr_noiseIterations)+' iterations: '+str(np.round(R_keovsAMPEREN[i],3));
        Pxy_TECNvAMPERE[i] = np.mean(TECNvAMPERE_mat,axis=1);
        Pxy_TECvAMPEREN[i] = np.mean(TECvAMPEREN_mat,axis=1);
    #END FOR i
    print(stringer); #report the coeff
    
    #--- Start the plot ---
    fig, ax = plt.subplots(nrows=len(doubleKeo_latLong), ncols=1); #use instead of fig because it inits an axis too (I think I dunno)
    figManager = plt.get_current_fig_manager(); #req to maximize
    figManager.window.showMaximized(); #force maximized
    #Remove the aspect ratio from the basemap so it fills the screen better
    cntr = 0; #prep
    for i in range(0,len(doubleKeo_latLong)):
        ax[i].set_aspect('auto');
        pZ = []; #prep
        lZ = []; #prep
        
        pT, = ax[i].plot(keo_xcorr_time_cutOut[i]/3600,1/pwr_TEC[i]*keo_xcorr_cutOut[i],color=settings['plot']['color'][cntr],linewidth=PLOT_lineWidthPlus, linestyle=settings['plot']['line style'][cntr]);
        cntr += 1; #increment
        pZ.append(pT); #add onto the plot list
        lZ.append('Cutout '+str(time_cutout_range/3600)+' Keo #'+str(i+1)); #add onto the legend list
        
        pT, = ax[i].plot( (AMPERE_xcorr_time_cutOut[i]-dateRange_dayNum_zeroHr[1]*86400)/3600,1/pwr_AMPERE[i]*AMPERE_xcorr_cutOut[i],color=settings['plot']['color'][cntr],linewidth=PLOT_lineWidthPlus, linestyle=settings['plot']['line style'][cntr]);
        cntr += 1; #increment
        pZ.append(pT); #add onto the plot list
        lZ.append('Cutout '+str(time_cutout_range/3600)+' AMPERE #'+str(i+1)); #add onto the legend list
        
        pT, = ax[i].plot(keo_xcorr_time_cutOut[i]/3600,1/pwr_TEC[i]*keo_noise_xcorr_cutOut[i],color=settings['plot']['color'][cntr],linewidth=PLOT_lineWidthPlus, linestyle=settings['plot']['line style'][cntr]);
        cntr += 1; #increment
        pZ.append(pT); #add onto the plot list
        lZ.append('Cutout '+str(time_cutout_range/3600)+' Keo Noise (Last Iteration) #'+str(i+1)); #add onto the legend list
        
        pT, = ax[i].plot( (AMPERE_xcorr_time_cutOut[i]-dateRange_dayNum_zeroHr[1]*86400)/3600,1/pwr_AMPEREN[i]*AMPERE_noise_xcorr_cutOut[i],color=settings['plot']['color'][cntr],linewidth=PLOT_lineWidthPlus, linestyle=settings['plot']['line style'][cntr]);
        cntr += 1; #increment
        pZ.append(pT); #add onto the plot list
        lZ.append('Cutout '+str(time_cutout_range/3600)+' AMPERE Noise (Last Iteration) #'+str(i+1)); #add onto the legend list
        
        ax[i].legend(pZ, lZ, loc='upper right', framealpha=0.5);
        ax[i].set_ylabel('Normalized Ampltiude',fontproperties=FONT_axisLabelFM);
        
        ax[i].set_title('TEC Keo at '+str(np.round(doubleKeo_AMPERE_latAlign[i],2)).strip('0').strip('.')+' lat & AMPERE (Time Delay '+str(doubleKeo_AMPERE_timeDelay[i])+') Time Limited to '+str(str(np.round(time_cutout_range[0]/3600,2)).rstrip('0').rstrip('.'))+' to '+str(str(np.round(time_cutout_range[-1]/3600,2)).rstrip('0').rstrip('.'))+' hrs on Day '+str(dateRange_dayNum_zeroHr[1])+', '+str(dateRange_dayNum_zeroHr[0]), \
            fontproperties=FONT_titleFM);
    #END FOR i
    ax[i].set_xlabel('Time [hr]',fontproperties=FONT_axisLabelFM);
    
    
    # xAxisTicks = np.arange( 0, settings['spectra']['period limit max']/60+10, 10); #sets the start hr, stop hr, and the step size between (in this case, 2 hr)
    # ax.set_xticks(xAxisTicks); #set x axis ticks
    # ax.set_xlim( (settings['spectra']['period limit min']/60, settings['spectra']['period limit max']/60) );
    #final plot adjusting stuff
    figFitter(fig); #fit that fig fast
    #fig.subplots_adjust(left = 0.065, right = 0.975, top = 0.96, bottom = 0.065 , hspace = 0.225); #sets padding to small numbers for minimal white space
    #fig.tight_layout(); #function for a tight layout, doesn't seem to do much here
    plt.show(); #req to make plot show up
    
    warnings.filterwarnings("ignore", category=RuntimeWarning); #silences warnings about NaNs used in a logical comparisons #yolo
    fig, ax = plt.subplots(nrows=len(doubleKeo_latLong), ncols=1); #use instead of fig because it inits an axis too (I think I dunno)
    figManager = plt.get_current_fig_manager(); #req to maximize
    figManager.window.showMaximized(); #force maximized
    
    cntr = 0; #prep
    for i in range(0,len(doubleKeo_latLong)):
        #Remove the aspect ratio from the basemap so it fills the screen better
        ax[i].set_aspect('auto');
        pZ = []; #prep
        lZ = []; #prep
        
        pT, = ax[i].plot(1/freqs_TECvAMPERE[i]/60,(Pxy_TECvAMPERE[i]),color=settings['plot']['color'][cntr],linewidth=PLOT_lineWidthPlus, linestyle=settings['plot']['line style'][cntr]);
        cntr += 1; #increment
        pZ.append(pT); #add onto the plot list
        lZ.append('Cutout '+str(time_cutout_range/3600)+' Keo vs AMPERE #'+str(i+1)); #add onto the legend list
        
        pT, = ax[i].plot(1/freqs_TECvAMPERE[i]/60,(Pxy_TECNvAMPERE[i]),color=settings['plot']['color'][cntr],linewidth=PLOT_lineWidthPlus, linestyle=settings['plot']['line style'][cntr]);
        cntr += 1; #increment
        pZ.append(pT); #add onto the plot list
        lZ.append('Cutout '+str(time_cutout_range/3600)+' Keo Noise '+str(doubleKeo_xcorr_noiseIterations)+' iterations vs AMPERE #'+str(i+1)); #add onto the legend list
    
        pT, = ax[i].plot(1/freqs_TECvAMPERE[i]/60,(Pxy_TECvAMPEREN[i]),color=settings['plot']['color'][cntr],linewidth=PLOT_lineWidthPlus, linestyle=settings['plot']['line style'][cntr]);
        cntr += 1; #increment
        pZ.append(pT); #add onto the plot list
        lZ.append('Cutout '+str(time_cutout_range/3600)+' Keo vs AMPERE Noise '+str(doubleKeo_xcorr_noiseIterations)+' iterations #'+str(i+1)); #add onto the legend list
    
        ax[i].set_ylabel('Arb. Power',fontproperties=FONT_axisLabelFM);
        ax[i].set_title('CSD - TEC Keo at '+str(np.round(doubleKeo_AMPERE_latAlign[i],2)).strip('0').strip('.')+' lat & AMPERE (Time Delay '+str(doubleKeo_AMPERE_timeDelay[i])+') Time Limited to '+str(str(np.round(time_cutout_range[0]/3600,2)).rstrip('0').rstrip('.'))+' to '+str(str(np.round(time_cutout_range[-1]/3600,2)).rstrip('0').rstrip('.'))+' hrs on Day '+str(dateRange_dayNum_zeroHr[1])+', '+str(dateRange_dayNum_zeroHr[0]), \
            fontproperties=FONT_titleFM);
        ax[i].legend(pZ, lZ, loc='upper right', framealpha=0.5);
        
        xAxisTicks = np.arange( 0, settings['spectra']['period limit max']/60+10, 10); #sets the start hr, stop hr, and the step size between (in this case, 2 hr)
        ax[i].set_xticks(xAxisTicks); #set x axis ticks
        ax[i].set_xlim( (settings['spectra']['period limit min']/60, settings['spectra']['period limit max']/60) );
    #END FOR i
    ax[i].set_xlabel('Periods [min]',fontproperties=FONT_axisLabelFM);

    #final plot adjusting stuff
    figFitter(fig); #fit that fig fast
    #fig.subplots_adjust(left = 0.065, right = 0.975, top = 0.96, bottom = 0.065 , hspace = 0.225); #sets padding to small numbers for minimal white space
    #fig.tight_layout(); #function for a tight layout, doesn't seem to do much here
    plt.show(); #req to make plot show up
    warnings.filterwarnings("default", category=RuntimeWarning); #silences warnings about NaNs used in a logical comparisons #yolo
    
    #--- Just FFTs for good measure ---
    GRITI_spectral_6minAnalysisPlot([[keo_xcorr_cutOut[i],AMPERE_xcorr_cutOut[i],keo_noise_xcorr_cutOut[i],AMPERE_noise_xcorr_cutOut[i]] for i in range(0,len(doubleKeo_latLong))], 
        [[keo_xcorr_time_cutOut[i],AMPERE_xcorr_time_cutOut[i],keo_xcorr_time_cutOut[i],AMPERE_xcorr_time_cutOut[i]] for i in range(0,len(doubleKeo_latLong))], 
        [['sec','sec','sec','sec'] for i in range(0,len(doubleKeo_latLong))], [[360.,360.,360.,360.] for i in range(0,len(doubleKeo_latLong))], 
        [['sec','sec','sec','sec'] for i in range(0,len(doubleKeo_latLong))], 'min',
        [['none','none','none','none'] for i in range(0,len(doubleKeo_latLong))], [['fft','fft','fft','fft'] for i in range(0,len(doubleKeo_latLong))], 
        dates, settings_spectra, settings_plot, settings_paths, 
        [['TEC Keo at '+str(np.round(doubleKeo_AMPERE_latAlign[i],2)).strip('0').strip('.')+' lat','AMPERE (Time Delay '+str(doubleKeo_AMPERE_timeDelay[i])+') Time Limited to '+str(str(np.round(time_cutout_range[0]/3600,2)).rstrip('0').rstrip('.'))+' to '+str(str(np.round(time_cutout_range[-1]/3600,2)).rstrip('0').rstrip('.'))+' hrs','TEC Keo Noise '+str(doubleKeo_xcorr_noiseIterations)+' iterations at '+str(np.round(doubleKeo_AMPERE_latAlign[i],2)).strip('0').strip('.')+' lat','AMPERE (Time Delay '+str(doubleKeo_AMPERE_timeDelay[i])+') Noise '+str(doubleKeo_xcorr_noiseIterations)+' iterations Time Limited to '+str(str(np.round(time_cutout_range[0]/3600,2)).rstrip('0').rstrip('.'))+' to '+str(str(np.round(time_cutout_range[-1]/3600,2)).rstrip('0').rstrip('.'))+' hrs'] for i in range(0,len(doubleKeo_latLong))],
        reduceWindow=1); #insane plot call
    
    if( doubleKeo_xcorr_timeRangePer[0] != False ): #apply different time cutouts per keo
        stringer = ''; #prep
        Fs = 1/(360); #sec, time delta in freq form
        for i in range(0,len(doubleKeo_latLong)):
            #TEC CUTOUT NOW
            time_cutout_indexes = np.array( ( np.where(np.min(np.abs( doubleKeo_keo_xcorr_time[i] - np.min(doubleKeo_xcorr_timeRangePer[i]) )) == np.abs( doubleKeo_keo_xcorr_time[i] - np.min(doubleKeo_xcorr_timeRangePer[i]) ) )[0][0] , \
                np.where(np.min(np.abs( doubleKeo_keo_xcorr_time[i] - np.max(doubleKeo_xcorr_timeRangePer[i]) )) == np.abs( doubleKeo_keo_xcorr_time[i] - np.max(doubleKeo_xcorr_timeRangePer[i]) ) )[0][0] ) ); #get the indexes for that time cutout range
            keo_xcorr_cutOut[i] = doubleKeo_keo_xcorr[i][time_cutout_indexes[0]:time_cutout_indexes[1]+1];
            keo_xcorr_time_cutOut[i] = doubleKeo_keo_xcorr_time[i][time_cutout_indexes[0]:time_cutout_indexes[1]+1];
            
            #AMPERE CUTOUT NOW
            time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (doubleKeo_AMPERE_xcorr_time[i]-dateRange_dayNum_zeroHr[1]*86400) - np.min(doubleKeo_xcorr_timeRangePer[i]) )) == np.abs( (doubleKeo_AMPERE_xcorr_time[i]-dateRange_dayNum_zeroHr[1]*86400) - np.min(doubleKeo_xcorr_timeRangePer[i]) ) )[0][0] , \
                np.where(np.min(np.abs( (doubleKeo_AMPERE_xcorr_time[i]-dateRange_dayNum_zeroHr[1]*86400) - np.max(doubleKeo_xcorr_timeRangePer[i]) )) == np.abs( (doubleKeo_AMPERE_xcorr_time[i]-dateRange_dayNum_zeroHr[1]*86400) - np.max(doubleKeo_xcorr_timeRangePer[i]) ) )[0][0] ) ); #get the indexes for that time cutout range
            AMPERE_xcorr_cutOut[i] = doubleKeo_AMPERE_xcorr[i][time_cutout_indexes[0]:time_cutout_indexes[1]+1];
            AMPERE_xcorr_time_cutOut[i] = doubleKeo_AMPERE_xcorr_time[i][time_cutout_indexes[0]:time_cutout_indexes[1]+1];
            
            #enforce a local 0 mean
            if( strstr(doubleKeo_xcorr_AMPERE_filtMethod.lower().replace('-','').replace(' ',''),'0mean').size > 0 ):
                AMPERE_xcorr_cutOut[i] = subfun_filter( AMPERE_xcorr_cutOut[i], AMPERE_xcorr_time_cutOut[i], '0 mean', settings_spectra);
            #END IF
            if( strstr(doubleKeo_xcorr_TEC_filtMethod.lower().replace('-','').replace(' ',''),'0mean').size > 0 ):
                keo_xcorr_cutOut[i] = subfun_filter( keo_xcorr_cutOut[i], keo_xcorr_time_cutOut[i], '0 mean', settings_spectra);
            #END IF
        
            #CALC PWR
            pwr_TEC[i] = np.sqrt(1/keo_xcorr_cutOut[i].size*np.sum(keo_xcorr_cutOut[i]**2)); #estimate power of signal
            pwr_AMPERE[i] = np.sqrt(1/AMPERE_xcorr_cutOut[i].size*np.sum(AMPERE_xcorr_cutOut[i]**2)); #estimate power of signal
            
            if( (settings['spectra']['window'].size > keo_xcorr_cutOut[i].size) | (settings['spectra']['window'].size  > AMPERE_xcorr_cutOut[i].size) ):
                if( keo_xcorr_cutOut[i].size < AMPERE_xcorr_cutOut[i].size ):
                    winnow = np.hamming(keo_xcorr_cutOut[i].size - 1); #adjust
                else:
                    winnow = np.hamming(AMPERE_xcorr_cutOut[i].size - 1); #adjust
                #END IF
                nooverlap = winnow.size - 10; #adjust
            else:
                winnow = settings['spectra']['window']; #keep reg
                nooverlap = settings['spectra']['noverlap']; #keep reg
            #END IF
            
            #CALC THE XCORR
            [freqs_TECvAMPERE[i],Cxy_TECvAMPERE] = signal.csd(1/pwr_TEC[i]*keo_xcorr_cutOut[i],1/pwr_AMPERE[i]*AMPERE_xcorr_cutOut[i],window=winnow,noverlap=nooverlap,nfft=settings['spectra']['nfft']['6min'],fs=Fs);
            Axy_TECvAMPERE = np.angle(Cxy_TECvAMPERE)*180/np.pi; 
            Pxy_TECvAMPERE[i] = np.abs(Cxy_TECvAMPERE);
            
            #Real quick side move to calc correlation coefficients
            R_keovsAMPERE = np.corrcoef(1/pwr_TEC[i]*keo_xcorr_cutOut[i],1/pwr_AMPERE[i]*AMPERE_xcorr_cutOut[i])[0,1];
            if( i == 0 ):
                stringer += 'Corr Coeff:\n';
            #END IF
            stringer += 'Cutout '+str(np.asarray(doubleKeo_xcorr_timeRangePer[i])/3600)+' Keo vs AMPERE #'+str(i+1)+': '+str(np.round(R_keovsAMPERE,3));
            if( i != len(doubleKeo_latLong)-1 ):
                stringer += ' | ';
            #end if
        #END FOR i
        print(stringer); #report the coeff
        
        stringer = ''; #prep
        for i in range(0,len(doubleKeo_latLong)):
            for j in range(0,doubleKeo_xcorr_noiseIterations):       
                #already did the exxpensive noise raytracing calcs earlier, can re-use here
                    
                #TEC CUTOUT NOW
                time_cutout_indexes = np.array( ( np.where(np.min(np.abs( doubleKeo_keo_xcorr_time[i] - np.min(doubleKeo_xcorr_timeRangePer[i]) )) == np.abs( doubleKeo_keo_xcorr_time[i] - np.min(doubleKeo_xcorr_timeRangePer[i]) ) )[0][0] , \
                    np.where(np.min(np.abs( doubleKeo_keo_xcorr_time[i] - np.max(doubleKeo_xcorr_timeRangePer[i]) )) == np.abs( doubleKeo_keo_xcorr_time[i] - np.max(doubleKeo_xcorr_timeRangePer[i]) ) )[0][0] ) ); #get the indexes for that time cutout range
                keo_noise_xcorr_cutOut[i] = doubleKeo_keo_noise_xcorr[i][j][time_cutout_indexes[0]:time_cutout_indexes[1]+1];
                keo_xcorr_time_cutOut[i] = doubleKeo_keo_xcorr_time[i][time_cutout_indexes[0]:time_cutout_indexes[1]+1];
                
                #AMPERE CUTOUT NOW
                time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (doubleKeo_AMPERE_xcorr_time[i]-dateRange_dayNum_zeroHr[1]*86400) - np.min(doubleKeo_xcorr_timeRangePer[i]) )) == np.abs( (doubleKeo_AMPERE_xcorr_time[i]-dateRange_dayNum_zeroHr[1]*86400) - np.min(doubleKeo_xcorr_timeRangePer[i]) ) )[0][0] , \
                    np.where(np.min(np.abs( (doubleKeo_AMPERE_xcorr_time[i]-dateRange_dayNum_zeroHr[1]*86400) - np.max(doubleKeo_xcorr_timeRangePer[i]) )) == np.abs( (doubleKeo_AMPERE_xcorr_time[i]-dateRange_dayNum_zeroHr[1]*86400) - np.max(doubleKeo_xcorr_timeRangePer[i]) ) )[0][0] ) ); #get the indexes for that time cutout range
                AMPERE_noise_xcorr_cutOut[i] = doubleKeo_AMPERE_noise_xcorr[i][j][time_cutout_indexes[0]:time_cutout_indexes[1]+1];
                AMPERE_xcorr_time_cutOut[i] = doubleKeo_AMPERE_xcorr_time[i][time_cutout_indexes[0]:time_cutout_indexes[1]+1];
                
                #enforce a local 0 mean
                if( strstr(doubleKeo_xcorr_TEC_filtMethod.lower().replace('-','').replace(' ',''),'0mean').size > 0 ):
                    keo_noise_xcorr_cutOut[i] = subfun_filter( keo_noise_xcorr_cutOut[i], keo_xcorr_time_cutOut[i], '0 mean', settings_spectra);
                #END IF
                if( strstr(doubleKeo_xcorr_AMPERE_filtMethod.lower().replace('-','').replace(' ',''),'0mean').size > 0 ):
                    AMPERE_noise_xcorr_cutOut[i] = subfun_filter( AMPERE_noise_xcorr_cutOut[i], AMPERE_xcorr_time_cutOut[i], '0 mean', settings_spectra);
                #END IF
                
                #CALC PWR
                pwr_TECN[i] = np.sqrt(1/keo_noise_xcorr_cutOut[i].size*np.sum(keo_noise_xcorr_cutOut[i]**2)); #estimate power of signal
                pwr_AMPEREN[i] = np.sqrt(1/AMPERE_noise_xcorr_cutOut[i].size*np.sum(AMPERE_noise_xcorr_cutOut[i]**2)); #estimate power of signal
                
                if( (settings['spectra']['window'].size > keo_noise_xcorr_cutOut[i].size) | (settings['spectra']['window'].size  > AMPERE_noise_xcorr_cutOut[i].size) ):
                    if( keo_noise_xcorr_cutOut[i].size < AMPERE_noise_xcorr_cutOut[i].size ):
                        winnow = np.hamming(keo_noise_xcorr_cutOut[i].size - 1); #adjust
                    else:
                        winnow = np.hamming(AMPERE_noise_xcorr_cutOut[i].size - 1); #adjust
                    #END IF
                    nooverlap = winnow.size - 10; #adjust
                else:
                    winnow = settings['spectra']['window']; #keep reg
                    nooverlap = settings['spectra']['noverlap']; #keep reg
                #END IF
                
                [_,Cxy_TECNvAMPERE] = signal.csd(1/pwr_TECN[i]*keo_noise_xcorr_cutOut[i],1/pwr_AMPERE[i]*AMPERE_xcorr_cutOut[i],window=winnow,noverlap=nooverlap,nfft=settings['spectra']['nfft']['6min'],fs=Fs);
                Axy_TECNvAMPERE = np.angle(Cxy_TECNvAMPERE)*180/np.pi; 
                Pxy_TECNvAMPERE[i] = np.abs(Cxy_TECNvAMPERE);
                
                [_,Cxy_TECvAMPEREN] = signal.csd(1/pwr_TEC[i]*keo_xcorr_cutOut[i],1/pwr_AMPEREN[i]*AMPERE_noise_xcorr_cutOut[i],window=winnow,noverlap=nooverlap,nfft=settings['spectra']['nfft']['6min'],fs=Fs);
                Axy_TECvAMPEREN = np.angle(Cxy_TECvAMPEREN)*180/np.pi; 
                Pxy_TECvAMPEREN[i] = np.abs(Cxy_TECvAMPEREN);
                
                #RECORD FOR POSTERITY
                TECNvAMPERE_mat[:,j] = Pxy_TECNvAMPERE[i];
                TECvAMPEREN_mat[:,j] = Pxy_TECvAMPEREN[i];
                
                #Real quick side move to calc correlation coefficients
                R_keoNvsAMPERE_mat[j] = np.corrcoef(1/pwr_TECN[i]*keo_noise_xcorr_cutOut[i],1/pwr_AMPERE[i]*AMPERE_xcorr_cutOut[i])[0,1];
                R_keovsAMPEREN_mat[j] = np.corrcoef(1/pwr_TEC[i]*keo_xcorr_cutOut[i],1/pwr_AMPEREN[i]*AMPERE_noise_xcorr_cutOut[i])[0,1];
            #END FOR j
            R_keoNvsAMPERE[i] = np.mean(R_keoNvsAMPERE_mat);
            R_keovsAMPEREN[i] = np.mean(R_keovsAMPEREN_mat);
            stringer += '\nCutout '+str(np.asarray(doubleKeo_xcorr_timeRangePer[i])/3600)+' Keo Noise '+str(doubleKeo_xcorr_noiseIterations)+' iterations vs AMPERE #'+str(i+1)+': '+str(np.round(R_keoNvsAMPERE[i],3));
            stringer += '\nCutout '+str(np.asarray(doubleKeo_xcorr_timeRangePer[i])/3600)+' Keo vs AMPERE #'+str(i+1)+' Noise '+str(doubleKeo_xcorr_noiseIterations)+' iterations: '+str(np.round(R_keovsAMPEREN[i],3));
            Pxy_TECNvAMPERE[i] = np.mean(TECNvAMPERE_mat,axis=1);
            Pxy_TECvAMPEREN[i] = np.mean(TECvAMPEREN_mat,axis=1);
        #END FOR i
        print(stringer); #report the coeff
        
        warnings.filterwarnings("ignore", category=RuntimeWarning); #silences warnings about NaNs used in a logical comparisons #yolo
        fig, ax = plt.subplots(nrows=len(doubleKeo_latLong), ncols=1); #use instead of fig because it inits an axis too (I think I dunno)
        figManager = plt.get_current_fig_manager(); #req to maximize
        figManager.window.showMaximized(); #force maximized
        
        cntr = 0; #prep
        for i in range(0,len(doubleKeo_latLong)):
            #Remove the aspect ratio from the basemap so it fills the screen better
            ax[i].set_aspect('auto');
            pZ = []; #prep
            lZ = []; #prep
            
            pT, = ax[i].plot(1/freqs_TECvAMPERE[i]/60,(Pxy_TECvAMPERE[i]),color=settings['plot']['color'][cntr],linewidth=PLOT_lineWidthPlus, linestyle=settings['plot']['line style'][cntr]);
            cntr += 1; #increment
            pZ.append(pT); #add onto the plot list
            lZ.append('Cutout '+str(np.asarray(doubleKeo_xcorr_timeRangePer[i])/3600)+' Keo vs AMPERE #'+str(i+1)); #add onto the legend list
            
            pT, = ax[i].plot(1/freqs_TECvAMPERE[i]/60,(Pxy_TECNvAMPERE[i]),color=settings['plot']['color'][cntr],linewidth=PLOT_lineWidthPlus, linestyle=settings['plot']['line style'][cntr]);
            cntr += 1; #increment
            pZ.append(pT); #add onto the plot list
            lZ.append('Cutout '+str(np.asarray(doubleKeo_xcorr_timeRangePer[i])/3600)+' Keo Noise '+str(doubleKeo_xcorr_noiseIterations)+' iterations vs AMPERE #'+str(i+1)); #add onto the legend list
        
            pT, = ax[i].plot(1/freqs_TECvAMPERE[i]/60,(Pxy_TECvAMPEREN[i]),color=settings['plot']['color'][cntr],linewidth=PLOT_lineWidthPlus, linestyle=settings['plot']['line style'][cntr]);
            cntr += 1; #increment
            pZ.append(pT); #add onto the plot list
            lZ.append('Cutout '+str(np.asarray(doubleKeo_xcorr_timeRangePer[i])/3600)+' Keo vs AMPERE Noise '+str(doubleKeo_xcorr_noiseIterations)+' iterations #'+str(i+1)); #add onto the legend list
        
            ax[i].set_ylabel('Arb. Power',fontproperties=FONT_axisLabelFM);
            ax[i].set_title('CSD - TEC Keo at '+str(np.round(doubleKeo_AMPERE_latAlign[i],2)).strip('0').strip('.')+' lat & AMPERE (Time Delay '+str(doubleKeo_AMPERE_timeDelay[i])+') Time Limited to '+str(str(np.round(doubleKeo_xcorr_timeRangePer[i][0]/3600,2)).rstrip('0').rstrip('.'))+' to '+str(str(np.round(doubleKeo_xcorr_timeRangePer[i][-1]/3600,2)).rstrip('0').rstrip('.'))+' hrs on Day '+str(dateRange_dayNum_zeroHr[1])+', '+str(dateRange_dayNum_zeroHr[0]), \
                fontproperties=FONT_titleFM);
            ax[i].legend(pZ, lZ, loc='upper right', framealpha=0.5);
            
            xAxisTicks = np.arange( 0, settings['spectra']['period limit max']/60+10, 10); #sets the start hr, stop hr, and the step size between (in this case, 2 hr)
            ax[i].set_xticks(xAxisTicks); #set x axis ticks
            ax[i].set_xlim( (settings['spectra']['period limit min']/60, settings['spectra']['period limit max']/60) );
        #END FOR i
        ax[i].set_xlabel('Periods [min]',fontproperties=FONT_axisLabelFM);
    
        #final plot adjusting stuff
        figFitter(fig); #fit that fig fast
        #fig.subplots_adjust(left = 0.065, right = 0.975, top = 0.96, bottom = 0.065 , hspace = 0.225); #sets padding to small numbers for minimal white space
        #fig.tight_layout(); #function for a tight layout, doesn't seem to do much here
        plt.show(); #req to make plot show up
        warnings.filterwarnings("default", category=RuntimeWarning); #silences warnings about NaNs used in a logical comparisons #yolo
    
        #--- Just FFTs for good measure ---
        GRITI_spectral_6minAnalysisPlot([[keo_xcorr_cutOut[i],AMPERE_xcorr_cutOut[i],keo_noise_xcorr_cutOut[i],AMPERE_noise_xcorr_cutOut[i]] for i in range(0,len(doubleKeo_latLong))], 
            [[keo_xcorr_time_cutOut[i],AMPERE_xcorr_time_cutOut[i],keo_xcorr_time_cutOut[i],AMPERE_xcorr_time_cutOut[i]] for i in range(0,len(doubleKeo_latLong))], 
            [['sec','sec','sec','sec'] for i in range(0,len(doubleKeo_latLong))], [[360.,360.,360.,360.] for i in range(0,len(doubleKeo_latLong))], 
            [['sec','sec','sec','sec'] for i in range(0,len(doubleKeo_latLong))], 'min',
            [['none','none','none','none'] for i in range(0,len(doubleKeo_latLong))], [['fft','fft','fft','fft'] for i in range(0,len(doubleKeo_latLong))], 
            dates, settings_spectra, settings_plot, settings_paths, 
            [['TEC Keo at '+str(np.round(doubleKeo_AMPERE_latAlign[i],2)).strip('0').strip('.')+' lat','AMPERE (Time Delay '+str(doubleKeo_AMPERE_timeDelay[i])+') Time Limited to '+str(str(np.round(doubleKeo_xcorr_timeRangePer[i][0]/3600,2)).rstrip('0').rstrip('.'))+' to '+str(str(np.round(doubleKeo_xcorr_timeRangePer[i][-1]/3600,2)).rstrip('0').rstrip('.'))+' hrs','TEC Keo Noise '+str(doubleKeo_xcorr_noiseIterations)+' iterations at '+str(np.round(doubleKeo_AMPERE_latAlign[i],2)).strip('0').strip('.')+' lat','AMPERE (Time Delay '+str(doubleKeo_AMPERE_timeDelay[i])+') Noise '+str(doubleKeo_xcorr_noiseIterations)+' iterations Time Limited to '+str(str(np.round(doubleKeo_xcorr_timeRangePer[i][0]/3600,2)).rstrip('0').rstrip('.'))+' to '+str(str(np.round(doubleKeo_xcorr_timeRangePer[i][-1]/3600,2)).rstrip('0').rstrip('.'))+' hrs'] for i in range(0,len(doubleKeo_latLong))],
            reduceWindow=1); #insane plot call
        #END IF
    #END IF
    
    if( doubleKeo_xcorr_timeRangeSlam[0] != False ): #slam together multiple keo time periods
        stringer = ''; #prep
        keo_xcorr_cutOut_combSize = np.empty(len(doubleKeo_latLong), dtype=np.int64);
        AMPERE_xcorr_cutOut_combSize = np.empty(len(doubleKeo_latLong), dtype=np.int64);
        Fs = 1/(360); #sec, time delta in freq form
        for i in range(0,len(doubleKeo_latLong)):
            #TEC CUTOUT NOW
            time_cutout_indexes = np.array( ( np.where(np.min(np.abs( doubleKeo_keo_xcorr_time[i] - np.min(doubleKeo_xcorr_timeRangeSlam[i]) )) == np.abs( doubleKeo_keo_xcorr_time[i] - np.min(doubleKeo_xcorr_timeRangeSlam[i]) ) )[0][0] , \
                np.where(np.min(np.abs( doubleKeo_keo_xcorr_time[i] - np.max(doubleKeo_xcorr_timeRangeSlam[i]) )) == np.abs( doubleKeo_keo_xcorr_time[i] - np.max(doubleKeo_xcorr_timeRangeSlam[i]) ) )[0][0] ) ); #get the indexes for that time cutout range
            keo_xcorr_cutOut[i] = doubleKeo_keo_xcorr[i][time_cutout_indexes[0]:time_cutout_indexes[1]+1];
            keo_xcorr_time_cutOut[i] = doubleKeo_keo_xcorr_time[i][time_cutout_indexes[0]:time_cutout_indexes[1]+1];
            
            #AMPERE CUTOUT NOW
            time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (doubleKeo_AMPERE_xcorr_time[i]-dateRange_dayNum_zeroHr[1]*86400) - np.min(doubleKeo_xcorr_timeRangeSlam[i]) )) == np.abs( (doubleKeo_AMPERE_xcorr_time[i]-dateRange_dayNum_zeroHr[1]*86400) - np.min(doubleKeo_xcorr_timeRangeSlam[i]) ) )[0][0] , \
                np.where(np.min(np.abs( (doubleKeo_AMPERE_xcorr_time[i]-dateRange_dayNum_zeroHr[1]*86400) - np.max(doubleKeo_xcorr_timeRangeSlam[i]) )) == np.abs( (doubleKeo_AMPERE_xcorr_time[i]-dateRange_dayNum_zeroHr[1]*86400) - np.max(doubleKeo_xcorr_timeRangeSlam[i]) ) )[0][0] ) ); #get the indexes for that time cutout range
            AMPERE_xcorr_cutOut[i] = doubleKeo_AMPERE_xcorr[i][time_cutout_indexes[0]:time_cutout_indexes[1]+1];
            AMPERE_xcorr_time_cutOut[i] = doubleKeo_AMPERE_xcorr_time[i][time_cutout_indexes[0]:time_cutout_indexes[1]+1];
            
            #enforce a local 0 mean
            if( strstr(doubleKeo_xcorr_AMPERE_filtMethod.lower().replace('-','').replace(' ',''),'0mean').size > 0 ):
                AMPERE_xcorr_cutOut[i] = subfun_filter( AMPERE_xcorr_cutOut[i], AMPERE_xcorr_time_cutOut[i], '0 mean', settings_spectra);
            #END IF
            if( strstr(doubleKeo_xcorr_TEC_filtMethod.lower().replace('-','').replace(' ',''),'0mean').size > 0 ):
                keo_xcorr_cutOut[i] = subfun_filter( keo_xcorr_cutOut[i], keo_xcorr_time_cutOut[i], '0 mean', settings_spectra);
            #END IF
            
            #deal with shared time stamp if cut out ranges start and end at the same time
            if( i != 0 ):
                if( np.min(doubleKeo_xcorr_timeRangeSlam[i]) == np.max(doubleKeo_xcorr_timeRangeSlam[i-1]) ):
                    keo_xcorr_cutOut[i] = keo_xcorr_cutOut[i][1:]; #remove 1st entry
                    keo_xcorr_time_cutOut[i] = keo_xcorr_time_cutOut[i][1:]; #remove 1st entry
                    AMPERE_xcorr_cutOut[i] = AMPERE_xcorr_cutOut[i][1:]; #remove 1st entry
                    AMPERE_xcorr_time_cutOut[i] = AMPERE_xcorr_time_cutOut[i][1:]; #remove 1st entry
                #END IF
            #END IF            
            keo_xcorr_cutOut_combSize[i] = keo_xcorr_cutOut[i].size; #add on the total size
            AMPERE_xcorr_cutOut_combSize[i] = AMPERE_xcorr_cutOut[i].size; #add on the total size
        #END FOR i
        keo_xcorr_cutOut_comb = np.empty( keo_xcorr_cutOut_combSize.sum() ); #preallocate
        keo_xcorr_time_cutOut_comb = np.empty( keo_xcorr_cutOut_combSize.sum() ); #preallocate
        AMPERE_xcorr_cutOut_comb = np.empty( AMPERE_xcorr_cutOut_combSize.sum() ); #preallocate
        AMPERE_xcorr_time_cutOut_comb = np.empty( AMPERE_xcorr_cutOut_combSize.sum() ); #preallocate
        cntrKeo = 0; #prep
        cntrAMPERE = 0; #prep
        for i in range(0,len(doubleKeo_latLong)):
            keo_xcorr_cutOut_comb[cntrKeo:cntrKeo+keo_xcorr_cutOut_combSize[i]] = keo_xcorr_cutOut[i]; #put in the data
            keo_xcorr_time_cutOut_comb[cntrKeo:cntrKeo+keo_xcorr_cutOut_combSize[i]] = keo_xcorr_time_cutOut[i]; #put in the data
            AMPERE_xcorr_cutOut_comb[cntrAMPERE:cntrAMPERE+AMPERE_xcorr_cutOut_combSize[i]] = AMPERE_xcorr_cutOut[i]; #put in the data
            AMPERE_xcorr_time_cutOut_comb[cntrAMPERE:cntrAMPERE+AMPERE_xcorr_cutOut_combSize[i]] = AMPERE_xcorr_time_cutOut[i]; #put in the data
            cntrKeo += keo_xcorr_cutOut_combSize[i]; #increment
            cntrAMPERE += AMPERE_xcorr_cutOut_combSize[i]; #increment
        #END FOR i
            
        #CALC PWR
        pwr_TEC = np.sqrt(1/keo_xcorr_cutOut_comb.size*np.sum(keo_xcorr_cutOut_comb**2)); #estimate power of signal
        pwr_AMPERE = np.sqrt(1/AMPERE_xcorr_cutOut_comb.size*np.sum(AMPERE_xcorr_cutOut_comb**2)); #estimate power of signal
        
        if( (settings['spectra']['window'].size > keo_xcorr_cutOut_comb.size) | (settings['spectra']['window'].size  > AMPERE_xcorr_cutOut_comb.size) ):
            if( keo_xcorr_cutOut_comb.size < AMPERE_xcorr_cutOut_comb.size ):
                winnow = np.hamming(keo_xcorr_cutOut_comb.size - 1); #adjust
            else:
                winnow = np.hamming(AMPERE_xcorr_cutOut_comb.size - 1); #adjust
            #END IF
            nooverlap = winnow.size - 10; #adjust
        else:
            winnow = settings['spectra']['window']; #keep reg
            nooverlap = settings['spectra']['noverlap']; #keep reg
        #END IF
        
        #CALC THE XCORR
        [freqs_TECvAMPERE,Cxy_TECvAMPERE] = signal.csd(1/pwr_TEC*keo_xcorr_cutOut_comb,1/pwr_AMPERE*AMPERE_xcorr_cutOut_comb,window=winnow,noverlap=nooverlap,nfft=settings['spectra']['nfft']['6min'],fs=Fs);
        Axy_TECvAMPERE = np.angle(Cxy_TECvAMPERE)*180/np.pi; 
        Pxy_TECvAMPERE = np.abs(Cxy_TECvAMPERE);
        
        #Real quick side move to calc correlation coefficients
        R_keovsAMPERE = np.corrcoef(1/pwr_TEC*keo_xcorr_cutOut_comb,1/pwr_AMPERE*AMPERE_xcorr_cutOut_comb)[0,1];
        
        stringer += 'Corr Coeff:\nSlammed Cutout ['+str(doubleKeo_xcorr_timeRangeSlam[0][0]/3600)+'  '+str(doubleKeo_xcorr_timeRangeSlam[-1][-1]/3600)+'] Keo vs AMPERE COMBINED SLAM: '+str(np.round(R_keovsAMPERE,3));
        print(stringer); #report the coeff
        
        warnings.filterwarnings("ignore", category=RuntimeWarning); #silences warnings about NaNs used in a logical comparisons #yolo
        fig, ax = plt.subplots(nrows=1, ncols=1); #use instead of fig because it inits an axis too (I think I dunno)
        figManager = plt.get_current_fig_manager(); #req to maximize
        figManager.window.showMaximized(); #force maximized
        
        cntr = 0; #prep
        #Remove the aspect ratio from the basemap so it fills the screen better
        ax.set_aspect('auto');
        pZ = []; #prep
        lZ = []; #prep
        
        pT, = ax.plot(1/freqs_TECvAMPERE/60,(Pxy_TECvAMPERE),color=settings['plot']['color'][cntr],linewidth=PLOT_lineWidthPlus, linestyle=settings['plot']['line style'][cntr]);
        cntr += 1; #increment
        pZ.append(pT); #add onto the plot list
        lZ.append('Slammed Cutout ['+str(doubleKeo_xcorr_timeRangeSlam[0][0]/3600)+'  '+str(doubleKeo_xcorr_timeRangeSlam[0][0]/3600)+']  Keo vs AMPERE COMBINED SLAM'); #add onto the legend list
        
        # pT, = ax.plot(1/freqs_TECvAMPERE[i]/60,(Pxy_TECNvAMPERE[i]),color=settings['plot']['color'][cntr],linewidth=PLOT_lineWidthPlus, linestyle=settings['plot']['line style'][cntr]);
        # cntr += 1; #increment
        # pZ.append(pT); #add onto the plot list
        # lZ.append('Cutout '+str(time_cutout_range/3600)+' Keo Noise '+str(doubleKeo_xcorr_noiseIterations)+' iterations vs AMPERE #'+str(i+1)); #add onto the legend list
    
        # pT, = ax.plot(1/freqs_TECvAMPERE[i]/60,(Pxy_TECvAMPEREN[i]),color=settings['plot']['color'][cntr],linewidth=PLOT_lineWidthPlus, linestyle=settings['plot']['line style'][cntr]);
        # cntr += 1; #increment
        # pZ.append(pT); #add onto the plot list
        # lZ.append('Cutout '+str(time_cutout_range/3600)+' Keo vs AMPERE Noise '+str(doubleKeo_xcorr_noiseIterations)+' iterations #'+str(i+1)); #add onto the legend list
    
        ax.set_ylabel('Arb. Power',fontproperties=FONT_axisLabelFM);
        strang = 'CSD - Combined SLAM of ';
        for i in range(0,len(doubleKeo_latLong)):
            strang += 'Time Range '+str(np.round(doubleKeo_xcorr_timeRangeSlam[i][0]/3600,2)).rstrip('0').rstrip('.')+' to '+str(np.round(doubleKeo_xcorr_timeRangeSlam[i][-1]/3600,2)).rstrip('0').rstrip('.')+' hrs & ';
        #END FOR i
        strang = strang.rstrip(' & '); #remove last one of these
        ax.set_title(strang, \
            fontproperties=FONT_titleFM);
        ax.legend(pZ, lZ, loc='upper right', framealpha=0.5);
        
        xAxisTicks = np.arange( 0, settings['spectra']['period limit max']/60+10, 10); #sets the start hr, stop hr, and the step size between (in this case, 2 hr)
        ax.set_xticks(xAxisTicks); #set x axis ticks
        ax.set_xlim( (settings['spectra']['period limit min']/60, settings['spectra']['period limit max']/60) );
        ax.set_xlabel('Periods [min]',fontproperties=FONT_axisLabelFM);
    
        #final plot adjusting stuff
        figFitter(fig); #fit that fig fast
        #fig.subplots_adjust(left = 0.065, right = 0.975, top = 0.96, bottom = 0.065 , hspace = 0.225); #sets padding to small numbers for minimal white space
        #fig.tight_layout(); #function for a tight layout, doesn't seem to do much here
        plt.show(); #req to make plot show up
        warnings.filterwarnings("default", category=RuntimeWarning); #silences warnings about NaNs used in a logical comparisons #yolo
        
        #--- Just FFTs for good measure ---
        GRITI_spectral_6minAnalysisPlot([keo_xcorr_cutOut_comb,AMPERE_xcorr_cutOut_comb], 
            [keo_xcorr_time_cutOut_comb,AMPERE_xcorr_time_cutOut_comb], 
            ['sec','sec'], [360.,360.], 
            ['sec','sec'], 'min',
            ['none','none'], ['fft','fft'], 
            dates, settings_spectra, settings_plot, settings_paths, 
            ['TEC SLAM Time Range '+str(str(np.round(doubleKeo_xcorr_timeRangeSlam[0][0]/3600,2)).rstrip('0').rstrip('.'))+' to '+str(np.round(doubleKeo_xcorr_timeRangeSlam[-1][-1]/3600,2)).rstrip('0').rstrip('.'),'AMPERE SLAM Time Range '+str(str(np.round(doubleKeo_xcorr_timeRangeSlam[0][0]/3600,2)).rstrip('0').rstrip('.'))+' to '+str(np.round(doubleKeo_xcorr_timeRangeSlam[-1][-1]/3600,2)).rstrip('0').rstrip('.')],
            reduceWindow=1); #insane plot call
        #END IF
    #END IF
#END IF
    

if( FLG_doubleKeo_TECnMag == 1 ):
    from matplotlib.patches import ConnectionPatch, Rectangle
    from subfun_timeMatch import subfun_timeMatch
    from subfun_figFitter import figFitter
    from subfun_filter import subfun_filter
    from GRITI_keo_keogrammer import GRITI_keo_keogrammer
    
    #prep TEC data
    (doubleKeo_TECnMag_TEC_keo, doubleKeo_TECnMag_TEC_angle, doubleKeo_TECnMag_TEC_width, \
    doubleKeo_TECnMag_TEC_plotRangeChunks, doubleKeo_TECnMag_TEC_plotRangeName) = \
        GRITI_keo_keogrammer(dates,settings,doubleKeo_TECnMag_TEC_latLong[0],doubleKeo_TECnMag_TEC_latLong[1],TEC_timeUnique,\
            TEC_plotLimValu,doubleKeo_TECnMag_TEC_colorMap,data['TEC']['dTEC'],data['TEC']['time'],data['TEC']['lat'],data['TEC']['long'],time_Ref,doubleKeo_TECnMag_TEC_angleOrig, \
            doubleKeo_TECnMag_TEC_N,doubleKeo_TECnMag_TEC_widthOrig,doubleKeo_TECnMag_TEC_45vsLatLong,avgPt_coords,geoMap_projectionStyle,\
            dateRange_dayNum_zeroHr,plotLatRange_autoTick,plotLongRange_autoTick,plotLongRange_autoTick_Crunched, gif_Millstone_Marker, gif_Millstone_Marker_Color, \
            gif_Millstone_Marker_Size,FONT_titleFM,FONT_axisTick,FONT_axisTickFM,FONT_axisLabelFM,BasemapFixDir,\
            doubleKeo_TECnMag_TEC_dataName,doubleKeo_TECnMag_TEC_dataName_wUnits,FLG_fancyPlot,PLOT_lineWidth, folder, journal_width_2C,journal_height_max,journal_dpi,\
            avg_anyAngle_polarMode=0,FLG_disablePlot=2);
            #call the mecha function that runs the keo alg and makes a plot showing the averaging are
    
    #Calc magnetometer keogram
    localSettings = {
        'Mag':{
            'delta method':doubleKeo_TECnMag_Mag_filtMethod,
            'keo plot name':'Magnitude of Magnetic Field [nT]', #label for plotting
            'keo angle':doubleKeo_TECnMag_Mag_angle, #orig b/c this can be adjusted slightly if 0 or 90
            'keo width orig':doubleKeo_TECnMag_Mag_width, #orig b/c this can be adjusted if it's bigger than the averaging area [easy way to guarantee full coverage is to set to 360]
            'keo N':doubleKeo_TECnMag_Mag_N, #number of times to split the area the keogram covers
            'keo polar mode':doubleKeo_TECnMag_Mag_polarMode,
            'keo 45 lat/long':doubleKeo_TECnMag_Mag_45vsLatLong,
            'keo colorbar':doubleKeo_TECnMag_Mag_colorMap,
            'keo normalize':doubleKeo_TECnMag_Mag_normalize,
            'keo set plot range':doubleKeo_TECnMag_Mag_setPlotRange,
            'keo set plot range range':doubleKeo_TECnMag_Mag_setPlotRange_range,
            'keo set stations':doubleKeo_TECnMag_Mag_setStations,
            'keo set stations names':doubleKeo_TECnMag_Mag_setStations_names,
            },
        'plot':settings['plot'],
        'spectra':settings['spectra'],
        'map':settings['map'],
        };
    #-----Get the plot lat/long ranges based on the site locations involved-----
    if( doubleKeo_TECnMag_Mag_setPlotRange == 0 ):
        siteLocs = np.zeros( (2, len(data['Mag']['site names'])) ); #preallocate
        for j in range(0,len(data['Mag']['site names'])):
            siteLocs[0,j] = data['Mag'][data['Mag']['site names'][j]]['lat'];
            siteLocs[1,j] = data['Mag'][data['Mag']['site names'][j]]['long'];
        #END FOR j
        
        Mag_plotLatRange = [np.min(siteLocs[0,:]), np.max(siteLocs[0,:])]; # get lat extent
        Mag_plotLongRange = [np.min(siteLocs[1,:]), np.max(siteLocs[1,:])]; # get long extent
        #Adjust these ranges as needed
        if( np.remainder(np.ceil(Mag_plotLatRange[1]),5) == 0 ):
            Mag_plotLatRange[1] = np.ceil(Mag_plotLatRange[1]) + 5; #keep up to a 5 degc lat boundary
        else:
            Mag_plotLatRange[1] = np.ceil(Mag_plotLatRange[1]) + (5-np.remainder(np.ceil(Mag_plotLatRange[1]),5)); #keep up to a 5 degc lat boundary
        #END IF
        if( np.remainder(np.floor(Mag_plotLatRange[0]),5) == 0 ):
            Mag_plotLatRange[0] = np.floor(Mag_plotLatRange[0]) - 5; #keep up to a 5 degc lat boundary
        else:
            Mag_plotLatRange[0] = np.floor(Mag_plotLatRange[0]) - np.remainder(np.floor(Mag_plotLatRange[0]),5); #keep up to a 5 degc lat boundary
        #END IF
        if( np.remainder(np.ceil(Mag_plotLongRange[1]),5) == 0 ):
            Mag_plotLongRange[1] = np.ceil(Mag_plotLongRange[1]) + 5; #keep up to a 5 degc lat boundary
        else:
            Mag_plotLongRange[1] = np.ceil(Mag_plotLongRange[1]) + (5-np.remainder(np.ceil(Mag_plotLongRange[1]),5)); #keep up to a 5 degc long boundary
        #END IF
        if( np.remainder(np.floor(Mag_plotLongRange[0]),5) == 0 ):
            Mag_plotLongRange[0] = np.floor(Mag_plotLongRange[0]) - 5; #keep up to a 5 degc lat boundary
        else:
            Mag_plotLongRange[0] = np.floor(Mag_plotLongRange[0]) - np.remainder(np.floor(Mag_plotLongRange[0]),5); #keep up to a 5 degc long boundary
        #END IF
        localSettings['Mag']['lat range'] = Mag_plotLatRange; #record Mag's custom lat range for when only Mag is in play
        localSettings['Mag']['long range'] = Mag_plotLongRange; #record Mag's custom long range for when only Mag is in play
    else:
        #otherwise, let user set the lat/long range at will
        localSettings['Mag']['lat range'] = doubleKeo_TECnMag_Mag_setPlotRange_range[0]; #arcdeg, set it by user
        localSettings['Mag']['long range'] = doubleKeo_TECnMag_Mag_setPlotRange_range[1]; #arcdeg, set it by user
    #END IF
    doubleKeo_TECnMag_Mag_latLong = [localSettings['Mag']['lat range'],localSettings['Mag']['long range']]; #make a latlong range

    (doubleKeo_TECnMag_Mag_keo, doubleKeo_TECnMag_Mag_time, doubleKeo_TECnMag_Mag_timeHr, \
    doubleKeo_TECnMag_Mag_angle, doubleKeo_TECnMag_Mag_width, \
    doubleKeo_TECnMag_Mag_plotRangeChunks,doubleKeo_TECnMag_Mag_plotRangeName) = \
        GRITI_Mag_keo(data,dates,localSettings,FLG_disablePlot=0);
    #call the mecha function that runs the keo alg and makes a plot showing the averaging area [FLG_normalize makes each site normalized to each other - the magnitude reduces as latitude drops]
    
    data['double keo TECnMag'] = {
        'TEC keo':doubleKeo_TECnMag_TEC_keo,
        'TEC lat long':doubleKeo_TECnMag_TEC_latLong,
        'TEC angle':doubleKeo_TECnMag_TEC_angle,
        'TEC width':doubleKeo_TECnMag_TEC_width,
        'TEC plot spacing':doubleKeo_TECnMag_TEC_plotRangeChunks,
        'TEC plot spacing name':doubleKeo_TECnMag_TEC_plotRangeName,
        'Mag keo':doubleKeo_TECnMag_Mag_keo,
        'Mag lat long':doubleKeo_TECnMag_Mag_latLong,
        'Mag time':doubleKeo_TECnMag_Mag_time,
        'Mag time hr':doubleKeo_TECnMag_Mag_timeHr,
        'Mag angle':doubleKeo_TECnMag_Mag_angle,
        'Mag width':doubleKeo_TECnMag_Mag_width,
        'Mag plot spacing':doubleKeo_TECnMag_Mag_plotRangeChunks,
        'Mag plot spacing name':doubleKeo_TECnMag_Mag_plotRangeName,
        };
    
    #-----Plot TEC results as a Keogram w/ AMPERE integrated line as well-----
    #Prep the plot
    fig, ax = plt.subplots(nrows=2, ncols=1); #use instead of fig because it inits an axis too (I think I dunno)
    figManager = plt.get_current_fig_manager(); #req to maximize
    figManager.window.showMaximized(); #force maximized
    cax = []; #prep
    divider = []; #prep
    im = []; #prep
    cbar = []; #prep
    
    divider.append(make_axes_locatable(ax[0])); #prep to add an axis
    divider.append(make_axes_locatable(ax[1])); #prep to add an axis
    cax.append(divider[0].append_axes('right', size='2.0%', pad=1.75)); #make a color bar axis, append
    cax.append(divider[1].append_axes('right', size='2.0%', pad=1.75)); #make a color bar axis, append
    
    #Remove the aspect ratio from the basemap so it fills the screen better
    ax[0].set_aspect('auto');
    ax[1].set_aspect('auto');
    
    #-----Plot Mag results as a keogram-----
    i = 0; #for plotting purposes
    pltHelprX, pltHelprY = np.meshgrid( data['double keo TECnMag']['Mag time hr'], \
                data['double keo TECnMag']['Mag plot spacing']);
    im.append(ax[i].pcolormesh(pltHelprX, pltHelprY,  data['double keo TECnMag']['Mag keo'].T,cmap=doubleKeo_TECnMag_Mag_colorMap)); # pseudocolor plot "stretched" to the grid
    cbar.append(fig.colorbar(im[i], cax=cax[i], orientation='vertical')); #create a colorbar using the prev. defined cax
    if( doubleKeo_TECnMag_Mag_plotLimVal != None ): 
        cax[i].yaxis.set_ticks(np.linspace(np.min(doubleKeo_TECnMag_Mag_plotLimVal),np.max(doubleKeo_TECnMag_Mag_plotLimVal),5)); #create useful tick marks
    #END IF
    # cax[i].yaxis.set_major_formatter(FormatStrFormatter('%.2f')); #force a rounded format
    cbar[i].set_label(settings['Mag']['keo plot name']); #tabel the colorbar
    cbar[i].ax.tick_params(labelsize=FONT_axisTick);
    if( doubleKeo_TECnMag_Mag_plotLimVal != None ): 
        #cbar[i].set_clim(vmin=np.min(doubleKeo_TECnMag_Mag_plotLimVal), vmax=np.max(doubleKeo_TECnMag_Mag_plotLimVal)); #they changed how the code works, this doesn't work anymore
        cbar[i].mappable.set_clim(vmin=np.min(doubleKeo_TECnMag_Mag_plotLimVal), vmax=np.max(doubleKeo_TECnMag_Mag_plotLimVal)); #now it's this
    #END IF
    cax[i].yaxis.label.set_font_properties(FONT_axisLabelFM);
    
    #-----Plot TEC results as a keogram-----
    i = 1; #for plotting purposes
    pltHelprX, pltHelprY = np.meshgrid( (TEC_timeUnique - dateRange_dayNum_zeroHr[1]*86400), \
                doubleKeo_TECnMag_TEC_plotRangeChunks);
    im.append(ax[i].pcolormesh(pltHelprX, pltHelprY,  doubleKeo_TECnMag_TEC_keo.T ,vmin=np.min(settings['TEC']['plot lim']), vmax=np.max(settings['TEC']['plot lim']),cmap=settings['TEC']['colormap'])); # pseudocolor plot "stretched" to the grid
    cbar.append(fig.colorbar(im[i], cax=cax[i], orientation='vertical')); #create a colorbar using the prev. defined cax
    cax[i].yaxis.set_ticks(np.linspace(np.min(settings['TEC']['plot lim']),np.max(settings['TEC']['plot lim']),5)); #create useful tick marks
    cax[i].yaxis.set_major_formatter(FormatStrFormatter('%.2f')); #force a rounded format
    cbar[i].set_label(settings['TEC']['plot label']); #tabel the colorbar
    cbar[i].ax.tick_params(labelsize=FONT_axisTick);
    #cbar[i].set_clim(vmin=np.min(settings['TEC']['plot lim']), vmax=np.max(settings['TEC']['plot lim'])); #they changed how the code works, this doesn't work anymore
    cbar[i].mappable.set_clim(vmin=np.min(settings['TEC']['plot lim']), vmax=np.max(settings['TEC']['plot lim'])); #now it's this
    cax[i].yaxis.label.set_font_properties(FONT_axisLabelFM);
    
    xAxisTicks = np.arange( (np.round((np.min(TEC_timeUnique)-dateRange_dayNum_zeroHr[1]*86400)) - np.mod(np.round((np.min(TEC_timeUnique)-dateRange_dayNum_zeroHr[1]*86400)), 4)) , \
        (np.round((np.max(TEC_timeUnique)-dateRange_dayNum_zeroHr[1]*86400)) - np.mod(np.round((np.max(TEC_timeUnique)-dateRange_dayNum_zeroHr[1]*86400)),2)) + 4 , \
        4); #sets the start hr, stop hr, and the step size between (in this case, 4 hr)
    i = 0;
    ax[i].set_xticks(xAxisTicks); #set x axis ticks
    ax[i].set_xlim( np.min(xAxisTicks) , np.max(xAxisTicks) ); #set x axis limits
    i = 1;
    ax[i].set_xticks(xAxisTicks); #set x axis ticks
    ax[i].set_xlim( np.min(xAxisTicks) , np.max(xAxisTicks) ); #set x axis limits
    fig.subplots_adjust(hspace = 0.0); #make the plots touch
        
    # #-----Plot Shading to represent 'night'-----
    # doubleKeo_AMPERE_niteTimes_array = np.zeros( (dateRange_zeroHr_hrs.size,2) );
    # for j in range(0,dateRange_zeroHr_hrs.size):
    #     doubleKeo_AMPERE_niteTimes_array[j,:] = np.array(doubleKeo_AMPERE_niteTimes[i])+dateRange_zeroHr_hrs[j];
    # #END FOR j
    # #FIFTH STEP: PLOT THIS STUFF
    # for j in range(0,doubleKeo_AMPERE_niteTimes_array.shape[0]):
    #     ax[i].axvspan(doubleKeo_AMPERE_niteTimes_array[j,0], doubleKeo_AMPERE_niteTimes_array[j,1], alpha=0.25, color='xkcd:black');
    # #END FOR j
    
    string_title = settings['Mag']['keo plot name'].replace(' [nT]','')+' Keo Angle of '+str(np.round(doubleKeo_TECnMag_Mag_angle,2)).rstrip('0').rstrip('.')+' deg & Width of '+str(np.round(doubleKeo_TECnMag_Mag_width,2)).rstrip('0').rstrip('.')+' arcdeg | '+settings['TEC']['plot label no units']+' Keo Angle of '+str(np.round(doubleKeo_TECnMag_TEC_angle,2)).rstrip('0').rstrip('.')+' deg & Width of '+ \
        str(np.round(doubleKeo_TECnMag_TEC_width,2)).rstrip('0').rstrip('.')+' arcdeg'; #create mecha title
    ax[0].set_title(string_title,fontproperties=FONT_titleFM); #set the title
    ax[1].set_xlabel('Time in UT - 0 Hr on Day '+str(dateRange_dayNum_zeroHr[1])+', '+str(dateRange_dayNum_zeroHr[0])+' [hr]',fontproperties=FONT_axisLabelFM); #set the x axis label
    ax[0].set_ylabel(doubleKeo_TECnMag_Mag_plotRangeName+' [arcdeg]',fontproperties=FONT_axisLabelFM); #set the y axis label
    ax[1].set_ylabel(doubleKeo_TECnMag_TEC_plotRangeName+' [arcdeg]',fontproperties=FONT_axisLabelFM); #set the y axis label
    
    autoTick = (np.ceil(np.max(doubleKeo_TECnMag_Mag_plotRangeChunks)) - np.floor(np.min(doubleKeo_TECnMag_Mag_plotRangeChunks)))/13; #tries to split the latitude range into 13 parts (based off of 180/15+1)
    if( autoTick > 25 ):
        autoTick = 30; #sets the tick setting to 15 arcdegrees per tick
    elif( autoTick > 10 ):
        autoTick = 15; #sets the tick setting to 15 arcdegrees per tick
    elif( autoTick > 5 ):
        autoTick = 10; #sets the tick setting to 10 arcdegrees per tick
    elif( autoTick > 2 ):
        autoTick = 5; #sets the tick setting to 5 arcdegrees per tick
    elif( autoTick > 1 ):
        autoTick = 2; #sets the tick setting to 5 arcdegrees per tick
    elif( autoTick >= 0.6 ): #0.6 because 15/25 = 0.6, so there will be enough 1 arcdeg ticks
        autoTick = 1; #                                                        sets the tick setting to 1 arcdegree per tick
    else:
        if(doubleKeo_TECnMag_Mag_plotRangeName == 'Latitude'): #if Y axis is latitude, use latitude
            autoTick = (np.max(doubleKeo_TECnMag_Mag_latLong[0]) - np.min(doubleKeo_TECnMag_Mag_latLong[0]))/13; #just goes for it if it's a super tiny range
        elif(doubleKeo_TECnMag_Mag_plotRangeName == 'Longitude'): #if Y axis is longitude, use longitude
            autoTick = (np.max(doubleKeo_TECnMag_Mag_latLong[1]) - np.min(doubleKeo_TECnMag_Mag_latLong[1]))/13; #just goes for it if it's a super tiny range
        #END IF
    #END IF
    autoTickM = np.copy(autoTick).item(); #get the Mag auto tick
    autoTick = (np.ceil(np.max(doubleKeo_TECnMag_TEC_plotRangeChunks)) - np.floor(np.min(doubleKeo_TECnMag_TEC_plotRangeChunks)))/13; #tries to split the latitude range into 13 parts (based off of 180/15+1)
    if( autoTick > 25 ):
        autoTick = 30; #sets the tick setting to 15 arcdegrees per tick
    elif( autoTick > 10 ):
        autoTick = 15; #sets the tick setting to 15 arcdegrees per tick
    elif( autoTick > 5 ):
        autoTick = 10; #sets the tick setting to 10 arcdegrees per tick
    elif( autoTick > 2 ):
        autoTick = 5; #sets the tick setting to 5 arcdegrees per tick
    elif( autoTick > 1 ):
        autoTick = 2; #sets the tick setting to 5 arcdegrees per tick
    elif( autoTick >= 0.6 ): #0.6 because 15/25 = 0.6, so there will be enough 1 arcdeg ticks
        autoTick = 1; #                                                        sets the tick setting to 1 arcdegree per tick
    else:
        if(doubleKeo_TECnMag_TEC_plotRangeName == 'Latitude'): #if Y axis is latitude, use latitude
            autoTick = (np.max(doubleKeo_TECnMag_TEC_latLong[0]) - np.min(doubleKeo_TECnMag_TEC_latLong[0]))/13; #just goes for it if it's a super tiny range
        elif(doubleKeo_TECnMag_TEC_plotRangeName == 'Longitude'): #if Y axis is longitude, use longitude
            autoTick = (np.max(doubleKeo_TECnMag_TEC_latLong[1]) - np.min(doubleKeo_TECnMag_TEC_latLong[1]))/13; #just goes for it if it's a super tiny range
        #END IF
    #END IF
    autoTickT = np.copy(autoTick).item(); #get the TEC auto tick
    if(autoTickM > autoTickT):
        autoTick = autoTickM; #use larger one
    else:
        autoTick = autoTickT; #use larger one
    #END IF
    yAxisTicks = np.round(np.arange( np.floor(np.min(doubleKeo_TECnMag_Mag_plotRangeChunks)),np.ceil(np.max(doubleKeo_TECnMag_Mag_plotRangeChunks)),autoTick ),2); #creates y ticks automagically
    ax[0].set_yticks(yAxisTicks); #set y axis ticks
    yAxisTicks = np.round(np.arange( np.floor(np.min(doubleKeo_TECnMag_TEC_plotRangeChunks)),np.ceil(np.max(doubleKeo_TECnMag_TEC_plotRangeChunks)),autoTick ),2); #creates y ticks automagically
    ax[1].set_yticks(yAxisTicks); #set y axis ticks
    
    # #Now drawing line of interest
    # if( doubleKeo_plotSpacingName[i] == 'Latitude' ): #if true, latitude
    #     if( (np.min(doubleKeo_latLong[i][0]) <= doubleKeo_AMPERE_latAlign[i]) & (np.max(doubleKeo_latLong[i][0]) >= doubleKeo_AMPERE_latAlign[i]) ): #only plot if it's in the lat range specified
    #         ax[i].plot( np.linspace(np.min((TEC_timeUnique - dateRange_dayNum_zeroHr[1]*86400)/3600),np.max((TEC_timeUnique - dateRange_dayNum_zeroHr[1]*86400)/3600),10,endpoint=True) , #X time hr
    #             np.tile(doubleKeo_AMPERE_latAlign[i],10) , #Y latitude OR longitude arcdeg
    #             c='xkcd:black',linewidth=settings['plot']['line width']['smol']); #plots a point with a black line
    #     #END IF
    # else:
    #     if( (np.min(doubleKeo_latLong[i][1]) <= doubleKeo_AMPERE_latAlign[i]) & (np.max(doubleKeo_latLong[i][1]) >= doubleKeo_AMPERE_latAlign[i]) ): #only plot if it's in the lat range specified
    #         ax[i].plot( np.linspace(np.min((TEC_timeUnique - dateRange_dayNum_zeroHr[1]*86400)/3600),np.max((TEC_timeUnique - dateRange_dayNum_zeroHr[1]*86400)/3600),10,endpoint=True) , #X time hr
    #             np.tile(doubleKeo_AMPERE_latAlign[i],10) , #Y latitude OR longitude arcdeg
    #             c='xkcd:black',linewidth=settings['plot']['line width']['smol']); #plots a point with a black line
    #     #END IF
    # #END IF
    
    # #-----Draw line from 1st TEC event to 2nd-----
    # con = ConnectionPatch(xyA=(-11.81,doubleKeo_AMPERE_latAlign[0]), coordsA=ax[0].transData,
    #                       xyB=(-11.13,doubleKeo_AMPERE_latAlign[1]), coordsB=ax[1].transData,
    #                       arrowstyle="-|>", shrinkA=5, shrinkB=5,mutation_scale=20, fc="xkcd:pink",
    #                       color='xkcd:pink', linewidth=settings['plot']['line width']['double plus']); #prep a line between plots
    # fig.add_artist(con); #draw the line
    
    figFitter(fig); #fit the fig fast
    # fig.subplots_adjust(left = 0.055, right = 0.935, top = 0.96, bottom = 0.075, hspace = 0.18); #sets padding to small numbers for minimal white space
    #fig.tight_layout(); #function for a tight layout, doesn't seem to do much here
    plt.show(); #req to make plot show up
    
#END IF
    

#==============Analysis: delta-vTEC Activity Index==============
if( FLG_activityIndex == 1 ):

    activityIndex_time = 6; #min, minutes to average together to caclulate activity
    
    activityIndex_zone1 = np.array( ((30,-125),(50,-125),(30,-60),(50,-60)) ); #USA
    activityIndex_zone1_name = 'USA';
    activityIndex_zone2 = np.array( ((30,-15),(75,-15),(30,40),(75,40)) ); #Europe   
    activityIndex_zone2_name = 'Europe';
    TEC_activityIndex_step = 0.05; #TECU, steps to run through
    
    activityIndex_zones = np.stack( (activityIndex_zone1,activityIndex_zone2) ,axis=2 ); #stack em up
    activityIndex_zonesNames = [activityIndex_zone1_name, activityIndex_zone2_name];
    
    activityIndex_bins = np.arange(-TEC_plotLimValu,TEC_plotLimValu+TEC_activityIndex_step,TEC_activityIndex_step); #make the bins
    activityIndex_time_day = activityIndex_time/1440; #days, convert to days
    activityIndex_timeRange = np.arange( np.min(TEC_timeUnique), np.max(TEC_timeUnique)+activityIndex_time_day, activityIndex_time_day); #days, get the time range to go through
    activityIndex_timeRange_hr = (activityIndex_timeRange - dateRange_dayNum_zeroHr[1]*86400); #hr, convert to hrs
    activityIndex_mean = np.zeros( (activityIndex_zones.shape[2] , activityIndex_timeRange.size-1 ) );
    activityIndex_var = np.zeros( (activityIndex_zones.shape[2] , activityIndex_timeRange.size-1 ) );
    activityIndex_meanAbs = np.zeros( (activityIndex_zones.shape[2] , activityIndex_timeRange.size-1 ) );
    activityIndex_median = np.zeros( (activityIndex_zones.shape[2] , activityIndex_timeRange.size-1 ) );
    activityIndex_medianAbs = np.zeros( (activityIndex_zones.shape[2] , activityIndex_timeRange.size-1 ) );
    
    for irate in range(0,activityIndex_zones.shape[2]): #number of zones
        TEC_inZone = np.where( (data['TEC']['lat'] <= np.max(activityIndex_zones[:,0,irate]) ) & (data['TEC']['lat'] >= np.min(activityIndex_zones[:,0,irate]) ) & \
            (data['TEC']['long'] <= np.max(activityIndex_zones[:,1,irate]) ) & (data['TEC']['long'] >= np.min(activityIndex_zones[:,1,irate]) ) )[0];
        
        for i in range(activityIndex_timeRange.size-1):
            k = np.where( (data['TEC']['time'][TEC_inZone] < activityIndex_timeRange[i+1]) & (data['TEC']['time'][TEC_inZone] >= activityIndex_timeRange[i]) )[0]; #get where the time point is, make sure it is within the data rate window
            
            
            activityIndex_mean[irate,i] = np.mean(data['TEC']['dTEC'][TEC_inZone[k]]);
            activityIndex_var[irate,i] = np.var(data['TEC']['dTEC'][TEC_inZone[k]]);
            activityIndex_meanAbs[irate,i] = np.mean(np.abs(data['TEC']['dTEC'][TEC_inZone[k]]));
            activityIndex_medianAbs[irate,i] = np.median(np.abs(data['TEC']['dTEC'][TEC_inZone[k]]));
            activityIndex_median[irate,i] = np.median(activityIndex_median[irate,i]-np.abs(data['TEC']['dTEC'][TEC_inZone[k]]));
            
            #Histogram to check if Gaussian shaped
    #        (activityIndex, _) = np.histogram(data['TEC']['dTEC'][TEC_inZone[k]], bins=activityIndex_bins)
    #        #Start the Activity Index plot
    #        fig, ax = plt.subplots(); #use instead of fig because it inits an axis too (I think I dunno)
    #        figManager = plt.get_current_fig_manager(); #req to maximize
    #        figManager.window.showMaximized(); #force maximized
    #        
    #        #ax.plot( activityIndex_bins[0:-1], activityIndex ); #plot
    #        ax.hist(data['TEC']['dTEC'][TEC_inZone[k]], bins=activityIndex_bins); #alternate
    #        
    #        string_title = 'Activity for '+activityIndex_zonesNames[irate]+' at '+str(activityIndex_timeRange_hr[i])+' hrs'; #create mecha title
    #        ax.set_title(string_title,fontproperties=FONT_titleFM); #set the title
    #        
    #        fig.subplots_adjust(left = 0.050, right = 0.985, top = 0.96, bottom = 0.065); #sets padding to small numbers for minimal white space
    #        #fig.tight_layout(); #function for a tight layout, doesn't seem to do much here
    #        plt.show(); #req to make plot show up    
        
        #END FOR i
        
        #Start the Mean Activity Index plot
        fig, ax = plt.subplots(); #use instead of fig because it inits an axis too (I think I dunno)
        figManager = plt.get_current_fig_manager(); #req to maximize
        figManager.window.showMaximized(); #force maximized
        
        ax.plot( activityIndex_timeRange_hr[0:-1], activityIndex_mean[irate,:] ); #plot
        
        string_title = 'Mean Activity for '+activityIndex_zonesNames[irate]; #create mecha title
        ax.set_title(string_title,fontproperties=FONT_titleFM); #set the title
        
        fig.subplots_adjust(left = 0.050, right = 0.985, top = 0.96, bottom = 0.065); #sets padding to small numbers for minimal white space
        #fig.tight_layout(); #function for a tight layout, doesn't seem to do much here
        plt.show(); #req to make plot show up  
        
        #Start the Var Activity Index plot
        fig, ax = plt.subplots(); #use instead of fig because it inits an axis too (I think I dunno)
        figManager = plt.get_current_fig_manager(); #req to maximize
        figManager.window.showMaximized(); #force maximized
        
        ax.plot( activityIndex_timeRange_hr[0:-1], activityIndex_var[irate,:] ); #plot
        
        string_title = 'Var Activity for '+activityIndex_zonesNames[irate]; #create mecha title
        ax.set_title(string_title,fontproperties=FONT_titleFM); #set the title
        
        fig.subplots_adjust(left = 0.050, right = 0.985, top = 0.96, bottom = 0.065); #sets padding to small numbers for minimal white space
        #fig.tight_layout(); #function for a tight layout, doesn't seem to do much here
        plt.show(); #req to make plot show up  
        
        #Start the Abs Mean Activity Index plot
        fig, ax = plt.subplots(); #use instead of fig because it inits an axis too (I think I dunno)
        figManager = plt.get_current_fig_manager(); #req to maximize
        figManager.window.showMaximized(); #force maximized
        
        ax.plot( activityIndex_timeRange_hr[0:-1], activityIndex_meanAbs[irate,:] ); #plot
        
        string_title = 'Abs Mean Activity for '+activityIndex_zonesNames[irate]; #create mecha title
        ax.set_title(string_title,fontproperties=FONT_titleFM); #set the title
        
        fig.subplots_adjust(left = 0.050, right = 0.985, top = 0.96, bottom = 0.065); #sets padding to small numbers for minimal white space
        #fig.tight_layout(); #function for a tight layout, doesn't seem to do much here
        plt.show(); #req to make plot show up  
        
        
        #Start the Mean Activity Index plot
        fig, ax = plt.subplots(); #use instead of fig because it inits an axis too (I think I dunno)
        figManager = plt.get_current_fig_manager(); #req to maximize
        figManager.window.showMaximized(); #force maximized
        
        ax.plot( activityIndex_timeRange_hr[0:-1], activityIndex_mean[irate,:] ); #plot
        
        string_title = 'Mean Activity for '+activityIndex_zonesNames[irate]; #create mecha title
        ax.set_title(string_title,fontproperties=FONT_titleFM); #set the title
        
        fig.subplots_adjust(left = 0.050, right = 0.985, top = 0.96, bottom = 0.065); #sets padding to small numbers for minimal white space
        #fig.tight_layout(); #function for a tight layout, doesn't seem to do much here
        plt.show(); #req to make plot show up  
        
        
            #Start the Mean Activity Index plot
        fig, ax = plt.subplots(); #use instead of fig because it inits an axis too (I think I dunno)
        figManager = plt.get_current_fig_manager(); #req to maximize
        figManager.window.showMaximized(); #force maximized
        
        ax.plot( activityIndex_timeRange_hr[0:-1], activityIndex_median[irate,:] ); #plot
        
        string_title = 'Median Activity for '+activityIndex_zonesNames[irate]; #create mecha title
        ax.set_title(string_title,fontproperties=FONT_titleFM); #set the title
        
        fig.subplots_adjust(left = 0.050, right = 0.985, top = 0.96, bottom = 0.065); #sets padding to small numbers for minimal white space
        #fig.tight_layout(); #function for a tight layout, doesn't seem to do much here
        plt.show(); #req to make plot show up  
        
        
        
            #Start the Mean Activity Index plot
        fig, ax = plt.subplots(); #use instead of fig because it inits an axis too (I think I dunno)
        figManager = plt.get_current_fig_manager(); #req to maximize
        figManager.window.showMaximized(); #force maximized
        
        ax.plot( activityIndex_timeRange_hr[0:-1], activityIndex_medianAbs[irate,:] ); #plot
        
        string_title = 'Median Abs Activity for '+activityIndex_zonesNames[irate]; #create mecha title
        ax.set_title(string_title,fontproperties=FONT_titleFM); #set the title
        
        fig.subplots_adjust(left = 0.050, right = 0.985, top = 0.96, bottom = 0.065); #sets padding to small numbers for minimal white space
        #fig.tight_layout(); #function for a tight layout, doesn't seem to do much here
        plt.show(); #req to make plot show up  
    
        
    #END FOR irate
     
        
    AMPERE_timeUnique_hr = (AMPERE_timeUnique - dateRange_dayNum_zeroHr[1]*86400); #hr, convert to hr with 0 hr at specified day
    
    if( np.mod(np.round(np.min(AMPERE_timeUnique_hr)),2) == 0 ):
        AMPERE_time_hr_axis_min = np.round(np.min(AMPERE_timeUnique_hr)); #is even, good to go
    else:
        AMPERE_time_hr_axis_min = np.round(np.min(AMPERE_timeUnique_hr))+1; #is odd, make even
    #END IF
    if( np.mod(np.round(np.max(AMPERE_timeUnique_hr)),2) == 0 ):
        AMPERE_time_hr_axis_max = np.round(np.max(AMPERE_timeUnique_hr)); #is even, good to go
    else:
        AMPERE_time_hr_axis_max = np.round(np.max(AMPERE_timeUnique_hr))-1; #is odd, make even
    #END IF
    
    OMNI_timeUnique_hr = (OMNI_timeUnique - dateRange_dayNum_zeroHr[1]*86400); #hr, convert to hr with 0 hr at specified day
         
    for irate in range(0,activityIndex_zones.shape[2]):
    
        #-----BEGIN THE PLOTTING!------
        if( np.min(data['AMPERE']['lat']) < 0 ):
            #that means there is southern hemisphere data
            pass;
        else:
            #otherwise only northern hemisphere data
            
            AMPERE_integrate = np.zeros( AMPERE_timeUnique_hr.size , dtype=np.float64); #prep integrated joule heating
            for i in range(AMPERE_timeUnique_hr.size):
                k = np.where(AMPERE_timeUnique[i] == data['AMPERE']['time'])[0]
                AMPERE_integrate[i] = np.sum(AMPERE_data[k,locAMPERE_jouleHeating]); #ergs/(cm^2*sec), get the Joule Heating for the current time stamp
            #END FOR i
            
            #Start the AMPERE and OMNI AE plot
            fig, ax = plt.subplots(nrows=2, ncols=1); #use instead of fig because it inits an axis too (I think I dunno)
            figManager = plt.get_current_fig_manager(); #req to maximize
            figManager.window.showMaximized(); #force maximized
            
            #-----PLOT AMPERE-----
            ax[0].set_aspect('auto'); #Remove the aspect ratio from the basemap so it fills the screen better
            ax[0].plot( AMPERE_timeUnique_hr, AMPERE_integrate , linewidth=PLOT_lineWidth ); #plot
            
            if( (np.abs((np.min(AMPERE_timeUnique_hr)/24 + dateRange_dayNum_zeroHr[1]) - np.min(time_Ref))*24 >= 0.25) & ((time_Reference != 'Kp') & (time_Reference != 'AMPERE')) ): #as long as min Kp time is 15 min diff or more from the other time reference, plot where the time ref begins (not Kp tho)
                ax[0].plot( np.repeat( (np.min(time_Ref) - dateRange_dayNum_zeroHr[1]*86400) , 10) , np.linspace(np.min(AMPERE_integrate),np.max(AMPERE_integrate),num=10), linewidth=1.75, color='r'); #plot red lines showing ISR data time
            if( (np.abs((np.max(AMPERE_timeUnique_hr)/24 + dateRange_dayNum_zeroHr[1]) - np.max(time_Ref))*24 >= 0.25) & ((time_Reference != 'Kp') & (time_Reference != 'AMPERE')) ): #as long as max Kp time is 15 min diff or more from the other time reference, plot where the time ref ends (not Kp tho)
                ax[0].plot( np.repeat( (np.max(time_Ref) - dateRange_dayNum_zeroHr[1]*86400) , 10) , np.linspace(np.min(AMPERE_integrate),np.max(AMPERE_integrate),num=10), linewidth=1.75, color='r'); #plot red lines showing ISR data time
            #END IF
            
            xAxisTicks = np.arange(AMPERE_time_hr_axis_min,AMPERE_time_hr_axis_max+4,4); #sets the start hr, stop hr, and the step size between (in this case, 4 hr)
            ax[0].set_xticks(xAxisTicks); #set x axis ticks
            
    #        ax[0].set_xticklabels([]); #if statement to remove x axis labels except for the last line
    #        ax[0].tick_params(axis="x",direction="in");
            
            ax[0].set_xlim( AMPERE_time_hr_axis_min , AMPERE_time_hr_axis_max ); #set y axis limits
            
            ax[0].set_ylabel("Int. AMPERE JH [ergs/(cm^2*sec)]",fontproperties=FONT_axisLabelFM); #set the y axis label
            
            ax[0].set_ylim( np.min(AMPERE_integrate) , 150000 ); #set y axis limits
            
            ax[0].grid(b=True, which='major', axis='both', color='xkcd:light grey'); #sets major axis grid lines to be on                
            
            string_title = 'Integrated AMPERE Joule Heating in the Nothern Hemisphere & delta-vTEC Median over '+activityIndex_zonesNames[irate]+' for '+str(dateRange[0,1])+'/'+str(dateRange[0,2])+ \
            '/'+str(dateRange[0,0])+' to '+str(dateRange[-1,1])+ \
            '/'+str(dateRange[-1,2])+'/'+str(dateRange[-1,0])+ \
            ' (M/D/Y)'; #create mecha title
            ax[0].set_title(string_title,fontproperties=FONT_titleFM); #set the title
            
            #-----PLOT dTEC ACTIVITY MEDIAN----
            ax[1].set_aspect('auto'); #Remove the aspect ratio from the basemap so it fills the screen better
    
            ax[1].plot( activityIndex_timeRange_hr[0:-1], activityIndex_median[irate,:] ); #plot
            if( (np.abs((np.min(AMPERE_timeUnique_hr)/24 + dateRange_dayNum_zeroHr[1]) - np.min(time_Ref))*24 >= 0.25) & ((time_Reference != 'Kp') & (time_Reference != 'AMPERE')) ): #as long as min Kp time is 15 min diff or more from the other time reference, plot where the time ref begins (not Kp tho)
                ax[1].plot( np.repeat( (np.min(time_Ref) - dateRange_dayNum_zeroHr[1]*86400) , 10) , np.linspace(np.min(activityIndex_var[irate,:]),np.max(activityIndex_var[irate,:]),num=10), linewidth=1.75, color='r'); #plot red lines showing ISR data time
            if( (np.abs((np.max(AMPERE_timeUnique_hr)/24 + dateRange_dayNum_zeroHr[1]) - np.max(time_Ref))*24 >= 0.25) & ((time_Reference != 'Kp') & (time_Reference != 'AMPERE')) ): #as long as max Kp time is 15 min diff or more from the other time reference, plot where the time ref ends (not Kp tho)
                ax[1].plot( np.repeat( (np.max(time_Ref) - dateRange_dayNum_zeroHr[1]*86400) , 10) , np.linspace(np.min(activityIndex_var[irate,:]),np.max(activityIndex_var[irate,:]),num=10), linewidth=1.75, color='r'); #plot red lines showing ISR data time
            #END IF
            
            ax[1].set_xticks(xAxisTicks); #set x axis ticks
            
            ax[1].set_xlim( AMPERE_time_hr_axis_min , AMPERE_time_hr_axis_max ); #set y axis limits
            
            ax[1].set_ylabel('delta-vTEC Median',fontproperties=FONT_axisLabelFM); #set the y axis label
            
            ax[1].grid(b=True, which='major', axis='both', color='xkcd:light grey'); #sets major axis grid lines to be on                
          
            ax[1].set_ylim( 0 , 0.25 ); #set y axis limits
    
            ax[1].set_xlabel('Time in UT (hr) - 0 Hr on '+dateRange_zeroHr_monthName+' '+str(dateRange_zeroHr[2])+dateRange_zeroHr_dayPostfix+' | Day '+str(dateRange_dayNum_zeroHr[1])+', '+str(dateRange_dayNum_zeroHr[0]),fontproperties=FONT_axisLabelFM); #set the x axis label
            
            fig.subplots_adjust(left = 0.070, right = 0.985, top = 0.96, bottom = 0.065); #sets padding to small numbers for minimal white space
            #fig.tight_layout(); #function for a tight layout, doesn't seem to do much here
            plt.show(); #req to make plot show up
        #END IF
    #END FOR irate
#END IF        

    

    
    
#==============Analysis: average delta-vTEC at a single point==============
if( FLG_avgPt == 1 ): #average delta-vTEC around avgPt_coords in a radius of avgPt_pointRadius
    pointRadiusAngular = (avgPt_pointRadius/Re)*180/np.pi; #deg, (based on s=R*theta) angular radius around the point allowed
    
    
    for i in range(0,avgPt_coords.shape[0]):
        #================THIS IS TO VIEW DATA AVG RANGE BEING TAKEN==============
        fig, ax = plt.subplots(); #use instead of fig because it inits an axis too (I think I dunno)
        figManager = plt.get_current_fig_manager(); #req to maximize
        figManager.window.showMaximized(); #force maximized
        divider = make_axes_locatable(ax); #prep to add an axis
        cax = divider.append_axes('right', size='2.0%', pad=0.35); #make a color bar axis
        fig.subplots_adjust(left = 0.04, right = 0.945, top = 0.96, bottom = 0.035); #sets padding to small numbers for minimal white space
        fig.canvas.flush_events(); #this is req. to get get_window_extent() to get the current window size correctly
        
        bboxFig = fig.get_window_extent().transformed(fig.dpi_scale_trans.inverted()); #get the entire figure dimensions
        bboxAx0 = ax.get_window_extent().transformed(fig.dpi_scale_trans.inverted()); #get the plot dimensions
        plot_ratio = (bboxAx0.width/bboxAx0.height); #get the plot ratio, will use it to fix up the circle
        avgPt_plotLongMax = plot_ratio*avgPt_plotLatMax; #degc, automagically scale it
        
        avgPt_plotLatRange = np.array( (avgPt_coords[i,0]-avgPt_plotLatMax,avgPt_coords[i,0]+avgPt_plotLatMax) ); #create a temporary range for this plot
        avgPt_plotLongRange = np.array( (avgPt_coords[i,1]-avgPt_plotLongMax,avgPt_coords[i,1]+avgPt_plotLongMax) ); #create a temporary range for this plot
    
        #plot help with autotick calculating - for this custom range
        plotLongRange_autoTick = (np.max(avgPt_plotLongRange) - np.min(avgPt_plotLongRange))/25; #tries to split the longitude range into 25 parts (based off of 360/15+1)
        if( plotLongRange_autoTick > 10 ):
            plotLongRange_autoTick = 15; #sets the tick setting to 15 arcdegrees per tick
        elif( plotLongRange_autoTick > 5 ):
            plotLongRange_autoTick = 10; #sets the tick setting to 10 arcdegrees per tick
        elif( plotLongRange_autoTick > 2 ):
            plotLongRange_autoTick = 5; #sets the tick setting to 5 arcdegrees per tick
        elif( plotLongRange_autoTick > 1 ):
            plotLongRange_autoTick = 2; #sets the tick setting to 5 arcdegrees per tick
        elif( plotLongRange_autoTick >= 0.6 ): #0.6 because 15/25 = 0.6, so there will be enough 1 arcdeg ticks
            plotLongRange_autoTick = 1; #sets the tick setting to 1 arcdegree per tick
        else:
    #        plotLongRange_autoTick = (np.max(avgPt_plotLongRange) - np.min(avgPt_plotLongRange))/15; #just goes for it if it's a super tiny range
            plotLongRange_autoTick = 1; #sets the tick setting to 1 arcdegree per tick
        #END IF
        plotLatRange_autoTick = (np.max(avgPt_plotLatRange) - np.min(avgPt_plotLatRange))/13; #tries to split the latitude range into 13 parts (based off of 180/15+1)
        if( plotLatRange_autoTick > 10 ):
            plotLatRange_autoTick = 15; #sets the tick setting to 15 arcdegrees per tick
        elif( plotLatRange_autoTick > 5 ):
            plotLatRange_autoTick = 10; #sets the tick setting to 10 arcdegrees per tick
        elif( plotLatRange_autoTick > 2 ):
            plotLatRange_autoTick = 5; #sets the tick setting to 5 arcdegrees per tick
        elif( plotLatRange_autoTick > 1 ):
            plotLatRange_autoTick = 2; #sets the tick setting to 2 arcdegrees per tick
        elif( plotLatRange_autoTick > 0.75 ): #0.75 because 10/13 = 0.76something and it sounded good for enough 1 arcdeg ticks
            plotLatRange_autoTick = 1; #sets the tick setting to 1 arcdegree per tick
        else:
    #        plotLatRange_autoTick = (np.max(avgPt_plotLatRange) - np.min(avgPt_plotLatRange))/15; #just goes for it if it's a super tiny range
            plotLatRange_autoTick = 1; #sets the tick setting to 1 arcdegree per tick
        #END IF
        
        #mill for square Mercator style
        #robin for oval shape
        #mill forced here since it will always be a non-global plot
        geoMap = Basemap(projection='mill', lat_0=np.mean(avgPt_plotLatRange), lon_0=np.mean(avgPt_plotLongRange), #projection type, and I think lat_0/lon_0 are the centers?
            resolution = 'i', area_thresh = 10000, ax=ax, #resolutions I know are l, i, h - i seems good. area_thresh being big prevents it drawing lil lakes, 0.1 makes everything
            llcrnrlon=np.float32(avgPt_plotLongRange[0]), llcrnrlat=np.float32(avgPt_plotLatRange[0]), #lower left corner lat/long - MUST BE FLOAT cause CODED BY THE BEST
            urcrnrlon=np.float32(avgPt_plotLongRange[1]), urcrnrlat=np.float32(avgPt_plotLatRange[1])); #upper right corner lat/long - MUST BE FLOAT cause CODED BY THE BEST
        
        geoMap.drawcoastlines();
        #map.drawcountries()
        #map.fillcontinents(color='coral')
        #map.drawmapboundary()
        
        #Remove the aspect ratio from the basemap so it fills the screen better
        ax.set_aspect('auto');
        
        #np.linspace(startlat,endlat,5) # 5 = number of "ticks"
        geoMap.drawmeridians( np.round(np.arange(np.floor(np.min(avgPt_plotLongRange)),np.ceil(np.max(avgPt_plotLongRange))+1,plotLongRange_autoTick),2), 
            labels=[True,False,False,True], labelstyle='+/-', dashes=[6,15000], color='w' ); #adds the labels but keeps the lines invisible
        geoMap.drawparallels(np.round(np.arange(np.floor(np.min(avgPt_plotLatRange)),np.ceil(np.max(avgPt_plotLatRange))+1,plotLatRange_autoTick),2), 
            labels=[True,False,True,False], labelstyle='+/-', dashes=[6,15000], color='w' ); #adds the labels but keeps the lines invisible
        #dashes[6,15000] seems to be enough to keep the repeating dash from happening on a world plot (I think it's how wide a dash is and the dash spacing). 900 was good for 22 degc longitude, for ref.
        #labels=[left,right,top,bottom] is the order. true/false to turn them on and off. not sure why there's a top/bottom for the parallels but w/e people do it
        
        #xticks( np.round(np.arange(np.floor(np.min(avgPt_plotLongRange)),np.ceil(np.max(avgPt_plotLongRange))+1,plotLongRange_autoTick),2) ); #creates x ticks automagically
        #yticks( np.round(np.arange(np.floor(np.min(avgPt_plotLatRange)),np.ceil(np.max(avgPt_plotLatRange))+1,plotLatRange_autoTick),2) ); #creates y ticks automagically
        klatlongtimelim = (data['TEC']['lat'] <= np.max(avgPt_plotLatRange)) & (data['TEC']['lat'] >= np.min(avgPt_plotLatRange)) & (data['TEC']['long'] <= np.max(avgPt_plotLongRange)) & (data['TEC']['long'] >= np.min(avgPt_plotLongRange)); #only bother plotting stuff that'll show up
        klatlongtimelim = klatlongtimelim & (data['TEC']['time'] == data['TEC']['time'][np.where(klatlongtimelim==1)[0][0]]); #limit some more, to get a time when there's data (in case there might not be at index 0 or something)
        TEC_timeTemp = data['TEC']['time'][klatlongtimelim]; #get the temp time
        TEC_dTECTemp = data['TEC']['dTEC'][klatlongtimelim]; #get the temp time
        TEC_latTemp = data['TEC']['lat'][klatlongtimelim]; #get the temp time
        TEC_longTemp = data['TEC']['long'][klatlongtimelim]; #get the temp time
        k = np.where( TEC_timeTemp == TEC_timeTemp[0])[0]; #gets during a time period
        TEC_latLongMapped = geoMap(TEC_longTemp[k],TEC_latTemp[k]); #convert the lat/long arcdeg to the current map coordinates
        
        im = ax.scatter(TEC_latLongMapped[0],TEC_latLongMapped[1],s=20,c=TEC_dTECTemp[k],cmap='jet', vmin=-TEC_plotLimValu, vmax=TEC_plotLimValu);
        cbar = fig.colorbar(im, cax=cax, orientation='vertical'); #create a colorbar using the prev. defined cax
        cax.yaxis.set_ticks(np.linspace(-TEC_plotLimValu,TEC_plotLimValu,5)); #create useful tick marks
        cax.yaxis.set_major_formatter(FormatStrFormatter('%.2f')); #force a rounded format
        cbar.set_label("delta-vTEC [TECU]"); #tabel the colorbar
        cbar.ax.tick_params(labelsize=FONT_axisTick) 
        cbar.mappable.set_clim(vmin=-TEC_plotLimValu, vmax=TEC_plotLimValu)
        cax.yaxis.label.set_font_properties(FONT_axisLabelFM)
        string_title = 'Radius of '+str(avgPt_pointRadius)+' km around '+avgPt_coordsName[i];
        ax.set_title(string_title,fontproperties=FONT_titleFM); #set the title
        
        #draw a circle where the data will be averaged
        temp_mapCoords = geoMap( pointRadiusAngular*np.cos(np.arange(0,2*np.pi+np.pi/50,np.pi/50)) + avgPt_coords[i,1], pointRadiusAngular*np.sin(np.arange(0,2*np.pi+np.pi/50,np.pi/50)) + avgPt_coords[i,0] ); #convert to the geographic map coords
        ax.plot( temp_mapCoords[0],  #X longitude arcdeg
            temp_mapCoords[1],  #Y latitude arcdeg
            c=gif_Millstone_Marker_Color,linewidth=4);
                
        #plot a * where the averaging center is
        temp_mapCoords = geoMap(avgPt_coords[i,1],avgPt_coords[i,0]); #convert the lat/long arcdeg to the current map coordinates
        ax.plot(temp_mapCoords[0],temp_mapCoords[1],marker=gif_Millstone_Marker, color='xkcd:red orange', markersize=gif_Millstone_Marker_Size, zorder=50);
           
    #    fig.subplots_adjust(left = 0.035, right = 0.95, top = 0.96, bottom = 0.03); #sets padding to small numbers for minimal white space
    #    fig.tight_layout(); #function for a tight layout, doesn't seem to do much here
        plt.show(); #req to make plot show up
    #END FOR i
    
    
    #=======================NOW ACTUALLY CALC THE STUFF===========================
    
#    k = zeros(size(pplat)); #preallocate this
#    tempRadius = zeros(size(latPoints,2),length(pplat)); #record the radius calc'd
#    tempRadius(gg,:) = sqrt((pplat - latPoints(gg)).^2 + (pplong - longPoints(gg)).^2); #record the radius calc'd b/c why not save calc's
#    k = k | (pointRadiusAngular > tempRadius(gg,:));
    #END FOR i
    avgPt_vTEC, avgPt_vTEC_HP, avgPt_vTEC_time, _, _, _ = GRITI_TEC_avgPt(TEC_timeUnique,data['TEC']['lat'],data['TEC']['long'],data['TEC']['time'],data['TEC']['dTEC'], \
        avgPt_coords[0,:],avgPt_pointRadius,Re,dateRange_dayNum_zeroHr, \
        dataReject,dataRejectOrig,dataRejectLimit,dataRejectLimitOrig,dataRejectMax,FLG_report=1); #average points in a radius
        
    avgPt_vTEC_MISA, avgPt_vTEC_HP_MISA, avgPt_vTEC_time_MISA, _, _, _  = GRITI_TEC_avgPt(TEC_timeUnique,data['TEC']['lat'],data['TEC']['long'],data['TEC']['time'],data['TEC']['dTEC'], \
        avgPt_coords[1,:],avgPt_pointRadius,Re,dateRange_dayNum_zeroHr, \
        dataReject,dataRejectOrig,dataRejectLimit,dataRejectLimitOrig,dataRejectMax,FLG_report=1); #average points in a radius
    
    # import warnings
#     warnings.filterwarnings("ignore", category=RuntimeWarning); #silences warnings about NaNs used in a logical comparisons #yolo
    # k = pointRadiusAngular**2 >= ((data['TEC']['lat'] - avgPt_coords[0])**2 + (data['TEC']['long'] - avgPt_coords[1])**2); #get all of the data pts within the radius
    # tempTime = data['TEC']['time'][k];
    # tempTEC = data['TEC']['dTEC'][k];
    
    # avgPt_vTEC = np.zeros( (TEC_timeUnique.size)); #preallocate
    # for t in range(0,TEC_timeUnique.size):
        
    #     j = tempTime == TEC_timeUnique[t]; #find the time that connect to the time we are at
        
    #     tempTempTEC = tempTEC[j]; #get the delta-vTEC involved, do some filtering
    #     if( tempTempTEC.size > 1 ):
    #         tempMean = np.mean( tempTempTEC ); #get the mean
            
    #         tempVar = np.var( tempTempTEC, ddof=1 ); #get variance, ddof=1 to reduce bias (matlab does automatically)
            
    #         #loop to prevent too much data being nixed
    #         while( (tempTempTEC.size - np.sum(((tempMean+dataReject*tempVar) > tempTempTEC) & ((tempMean-dataReject*tempVar) < tempTempTEC) ) )*100/tempTempTEC.size > dataRejectLimit ):
    #             dataReject = dataReject*1.05; #increase the data rejection ratio to include more data
    #             if( dataReject > dataRejectMax ):
    #                 dataRejectLimit = 100; #if this goes on for a bit then it is halted with this manuever
    #             #END IF
    # #             (length(tempTempTEC) - sum(((tempMean+dataReject*tempVar) > tempTempTEC) & ((tempMean-dataReject*tempVar) < tempTempTEC) ) )*100/length(tempTempTEC)
    # #             dataReject
    # #             dataRejectLimit
    #         #END WHILE
            
    #         if( dataReject <= dataRejectMax ): #if this occured leave the data, it is too sparse or too varied to deal with effectively
    #             tempTempTEC = tempTempTEC[ ((tempMean+dataReject*tempVar) > tempTempTEC) & ((tempMean-dataReject*tempVar) < tempTempTEC) ]; #delete some extraneous data
    #             #this is normal operation
    #         #END IF
            
    #         dataReject = dataRejectOrig; #reset dataReject
    #         dataRejectLimit = dataRejectLimitOrig; #reset dataRejectLimit
            
    #         avgPt_vTEC[t] = np.mean(tempTempTEC); #TECU, average of the delta-vTEC points in that radius at the same time into one value
    #     else:
    #         avgPt_vTEC[t] = np.nan; #
    #     #END IF
    # #END FOR t
    # warnings.filterwarnings("default", category=RuntimeWarning); #silences warnings about NaNs used in a logical comparisons #yolo
    
#     #now, make optional dataset that has the NaNs interpolated over
#     jk = np.where( np.isnan(avgPt_vTEC) == 1)[0]; #find NaNs existing
#     jl = np.where( np.isnan(avgPt_vTEC) != 1)[0]; #find NaNs not existing
#     #interped data unused since spectrum analysis done using Lomb-Scargle approach which doens't require consistent timing intervals
# #    avgPt_vTEC_interped = avgPt_vTEC; #save the O.G. data
# #    avgPt_vTEC_interped[jk] = np.interp(jk,jl,avgPt_vTEC[jl]); #fill in the gaps with the spline fill in
#     print('\navgPt_vTEC Calcs:\nAt lat '+str(np.round(avgPt_coords[0,0],3))+' deg/long '+str(np.round(avgPt_coords[0,1],3))+' deg w/ '+str(avgPt_pointRadius)+' km radius, '+str(np.round(jk.size/avgPt_vTEC.size*100,3))+'% of data was NaN and interpolated over.'); #report % data filled in
    
#     #purge NANs from avgPt_vTEC so it can be scargled w/o issue, also make a time var for it
#     avgPt_vTEC = avgPt_vTEC[jl]; #get rid of the NaNs
#     avgPt_vTEC_time = TEC_timeUnique[jl]; #get the times that correspond
    
#     avgPt_vTEC_HP = subfun_highpass( (avgPt_vTEC_time-dateRange_dayNum_zeroHr[1]*86400) , avgPt_vTEC); #highpass that data to boot
#END IF
    
    
#==============Analysis: Time match the point-avg'd data to the ISR and then high-pass it, also average the ISR data in altitude==============
if( FLG_avgPt_timeMatch == 1 ):
    #Match the data in the 1st input (and its time in the 2nd input) to the time scale given in the 3rd input time and return that data and that data's highpassed form
    avgPt_vTEC_timeMatch, avgPt_vTEC_timeMatch_HP, avgPt_vTEC_timeMatch_time = GRITI_TEC_avgPt_timeMatch(avgPt_vTEC,avgPt_vTEC_time,Zenith_time,dateRange_dayNum_zeroHr,filter_cutoffPeriod=filter_cutoffPeriod);
    
    #now MISA
    avgPt_vTEC_timeMatch_MISA, avgPt_vTEC_timeMatch_HP_MISA, avgPt_vTEC_timeMatch_time_MISA = GRITI_TEC_avgPt_timeMatch(avgPt_vTEC_MISA,avgPt_vTEC_time_MISA,MISA_time,dateRange_dayNum_zeroHr,filter_cutoffPeriod=filter_cutoffPeriod);
    
    #Now for the ISR stuff    
    Zenith_height_atISRavgAlt = np.where( np.min(np.abs( Zenith_height - pointAltitude )) == np.abs( Zenith_height - pointAltitude ) )[0][0]; #get the index of where Zenith_height is closest to pointAltitude (in km)
    Zenith_height_atISRavgAltIndexes = np.array( ( np.where(np.min(np.abs( (Zenith_height[Zenith_height_atISRavgAlt]-avgPt_ISRavgAlt) - Zenith_height)) == np.abs(Zenith_height[Zenith_height_atISRavgAlt]-avgPt_ISRavgAlt - Zenith_height) )[0][0] , \
                                    np.where(np.min(np.abs( (Zenith_height[Zenith_height_atISRavgAlt]+avgPt_ISRavgAlt) - Zenith_height)) == np.abs(Zenith_height[Zenith_height_atISRavgAlt]+avgPt_ISRavgAlt - Zenith_height) )[0][0] ) ); #get the upper and lower indexes of height to average (+/- avgPt_ISRavgAlt in km)
    Zenith_SNR_hp_altAvgd = np.mean( Zenith_SNR_hp[Zenith_height_atISRavgAltIndexes[0]:Zenith_height_atISRavgAltIndexes[1]+1,:] , axis=0 ); #average +/- avgPt_ISRavgAlt in km around the center altitude pointAltitude in km
    Zenith_POPL_hp_altAvgd = np.mean( Zenith_POPL_hp[Zenith_height_atISRavgAltIndexes[0]:Zenith_height_atISRavgAltIndexes[1]+1,:] , axis=0 ); #average +/- avgPt_ISRavgAlt in km around the center altitude pointAltitude in km
    
    MISA_height_atISRavgAlt = np.where( np.min(np.abs( MISA_height - pointAltitude )) == np.abs( MISA_height - pointAltitude ) )[0][0]; #get the index of where MISA_height is closest to pointAltitude (in km)
    MISA_height_atISRavgAltIndexes = np.array( ( np.where(np.min(np.abs( (MISA_height[MISA_height_atISRavgAlt]-avgPt_ISRavgAlt) - MISA_height)) == np.abs(MISA_height[MISA_height_atISRavgAlt]-avgPt_ISRavgAlt - MISA_height) )[0][0] , 
                                    np.where(np.min(np.abs( (MISA_height[MISA_height_atISRavgAlt]+avgPt_ISRavgAlt) - MISA_height)) == np.abs(MISA_height[MISA_height_atISRavgAlt]+avgPt_ISRavgAlt - MISA_height) )[0][0] ) ); #get the upper and lower indexes of height to average (+/- avgPt_ISRavgAlt in km)
    MISA_SNR_hp_altAvgd = np.mean( MISA_SNR_hp[MISA_height_atISRavgAltIndexes[0]:MISA_height_atISRavgAltIndexes[1]+1,:] , axis=0 ); #average +/- avgPt_ISRavgAlt in km around the center altitude pointAltitude in km
    MISA_POPL_hp_altAvgd = np.mean( MISA_POPL_hp[MISA_height_atISRavgAltIndexes[0]:MISA_height_atISRavgAltIndexes[1]+1,:] , axis=0 ); #average +/- avgPt_ISRavgAlt in km around the center altitude pointAltitude in km
    
    
    if( (FLG_avgPt_HP_timeMatch_POPLnOMNI_CPSD_cutOut == 1) | (FLG_avgPt_HP_timeMatch_POPLnOMNInTECNOISE_CPSD_cutOut == 1) | (FLG_avgPt_HP_timeMatch_POPLnOMNI_FFT_cutOut == 1) ): #now OMNI, if it being used       
        from scipy.interpolate import interp1d    
    
        #now OMNI on Zenith time
        OMNI_data_timeMatch_Zenith, OMNI_data_timeMatch_HP_Zenith, OMNI_data_timeMatch_time_Zenith = GRITI_TEC_avgPt_timeMatch(OMNI_data[:,OMNI_dict[OMNI_plot_name]],OMNI_timeUnique,Zenith_time+time_cutout_range_delay_OMNI/24,dateRange_dayNum_zeroHr,filter_cutoffPeriod=filter_cutoffPeriod);
        
        #fix possible data-gaps
        if( Zenith_time.size != OMNI_data_timeMatch_time_Zenith.size ):
            Zenith_time_delay = Zenith_time+time_cutout_range_delay_OMNI/24; #get a temporary adjusted time reference
            interpFun = interp1d(OMNI_data_timeMatch_time_Zenith, OMNI_data_timeMatch_HP_Zenith, kind='linear', fill_value='extrapolate'); #get an interpolation function
            _, indx, _ = np.intersect1d(Zenith_time_delay, OMNI_data_timeMatch_time_Zenith,assume_unique=True, return_indices=True); #get where they intersect
            temp = np.nan*np.ones(Zenith_time.shape); #prep a full-size variable, set all to NaN
            temp[indx] = OMNI_data_timeMatch_HP_Zenith; #set the non-NaN values to their non-NaN values
            OMNI_data_timeMatch_HP_Zenith = temp; #overwrite with full-size temp
            jk = np.isnan(OMNI_data_timeMatch_HP_Zenith); #get the NaN locations
            OMNI_data_timeMatch_HP_Zenith[jk] = interpFun(Zenith_time_delay[jk]); #only interpolate at the points that were NaNs
            OMNI_data_timeMatch_time_Zenith = Zenith_time_delay; #overwrite
        #END IF
        
        #now OMNI on MISA time
        OMNI_data_timeMatch_MISA, OMNI_data_timeMatch_HP_MISA, OMNI_data_timeMatch_time_MISA = GRITI_TEC_avgPt_timeMatch(OMNI_data[:,OMNI_dict[OMNI_plot_name]],OMNI_timeUnique,MISA_time+time_cutout_range_delay_OMNI/24,dateRange_dayNum_zeroHr,filter_cutoffPeriod=filter_cutoffPeriod);
    
        #fix possible data-gaps
        if( MISA_time.size != OMNI_data_timeMatch_time_MISA.size ):
            MISA_time_delay = MISA_time+time_cutout_range_delay_OMNI/24; #get a temporary adjusted time reference
            interpFun = interp1d(OMNI_data_timeMatch_time_MISA, OMNI_data_timeMatch_HP_MISA, kind='linear', fill_value='extrapolate'); #get an interpolation function
            _, indx, _ = np.intersect1d(MISA_time_delay, OMNI_data_timeMatch_time_MISA,assume_unique=True, return_indices=True); #get where they intersect
            temp = np.nan*np.ones(MISA_time.shape); #prep a full-size variable, set all to NaN
            temp[indx] = OMNI_data_timeMatch_HP_MISA; #set the non-NaN values to their non-NaN values
            OMNI_data_timeMatch_HP_MISA = temp; #overwrite with full-size temp
            jk = np.isnan(OMNI_data_timeMatch_HP_MISA); #get the NaN locations
            OMNI_data_timeMatch_HP_MISA[jk] = interpFun(MISA_time_delay[jk]); #only interpolate at the points that were NaNs
            OMNI_data_timeMatch_time_MISA = MISA_time_delay; #overwrite
        #END IF
    #END IF
#END IF
    
#==============Analysis: Plot the delta-vTEC point-averaged time series with the ISR SNR HP altitude-averaged time series, along with an ISR RTI plot, over a cut-out time period==============
if( FLG_avgPt_HP_timeMatch_plotWithISR_cutOut == 1 ):
    
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (avgPt_vTEC_timeMatch_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (avgPt_vTEC_timeMatch_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , \
        np.where(np.min(np.abs( (avgPt_vTEC_timeMatch_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (avgPt_vTEC_timeMatch_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range
    
    avgPt_vTEC_timeMatch_HP_cutOut = avgPt_vTEC_timeMatch_HP[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    avgPt_vTEC_timeMatch_time_cutOut = avgPt_vTEC_timeMatch_time[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , \
        np.where(np.min(np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range
    
    Zenith_time_cutOut = Zenith_time[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    Zenith_SNR_hp_cutOut = Zenith_SNR_hp[:,time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    Zenith_SNR_hp_altAvgd_cutOut = Zenith_SNR_hp_altAvgd[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , \
        np.where(np.min(np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range

    MISA_time_cutOut = MISA_time[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    MISA_SNR_hp_cutOut = MISA_SNR_hp[:,time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    MISA_SNR_hp_altAvgd_cutOut = MISA_SNR_hp_altAvgd[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    
    GRITI_TEC_avgPt_HP_timeMatch_plotWithISR_cutOut(avgPt_vTEC_timeMatch_HP_cutOut,avgPt_vTEC_timeMatch_time_cutOut,Zenith_time_cutOut,Zenith_height,Zenith_SNR_hp_cutOut,Zenith_SNR_hp_altAvgd_cutOut,MISA_time_cutOut,MISA_height,MISA_SNR_hp_cutOut,MISA_SNR_hp_altAvgd_cutOut,filter_cutoffPeriod,ISR_RTI_heightLimValues,ISR_plotLimValu,avgPt_coords[0,:],avgPt_ISRavgAlt,pointAltitude,time_cutout_range,dateRange,dateRange_dayNum,dateRange_dayNum_zeroHr,FONT_titleFM,FONT_axisTick,FONT_axisLabelFM,PLOT_lineWidth);  
    
#END IF
    

#==============Analysis: Plot the delta-vTEC point-averaged time series with the ISR POPL HP altitude-averaged time series, along with an ISR RTI plot, over a cut-out time period==============
if( FLG_avgPt_HP_timeMatch_POPL_plotWithISR_cutOut == 1 ):
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (avgPt_vTEC_timeMatch_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (avgPt_vTEC_timeMatch_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , \
        np.where(np.min(np.abs( (avgPt_vTEC_timeMatch_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (avgPt_vTEC_timeMatch_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range
    
    avgPt_vTEC_timeMatch_HP_cutOut = avgPt_vTEC_timeMatch_HP[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    avgPt_vTEC_timeMatch_time_cutOut = avgPt_vTEC_timeMatch_time[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , \
        np.where(np.min(np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range
    
    Zenith_time_cutOut = Zenith_time[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    Zenith_POPL_hp_cutOut = Zenith_POPL_hp[:,time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    Zenith_POPL_hp_altAvgd_cutOut = Zenith_POPL_hp_altAvgd[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , \
        np.where(np.min(np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range

    MISA_time_cutOut = MISA_time[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    MISA_POPL_hp_cutOut = MISA_POPL_hp[:,time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    MISA_POPL_hp_altAvgd_cutOut = MISA_POPL_hp_altAvgd[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    
    GRITI_TEC_avgPt_HP_timeMatch_POPL_plotWithISR_cutOut(avgPt_vTEC_timeMatch_HP_cutOut,avgPt_vTEC_timeMatch_time_cutOut,Zenith_time_cutOut,Zenith_height,Zenith_POPL_hp_cutOut,Zenith_POPL_hp_altAvgd_cutOut,MISA_time_cutOut,MISA_height,MISA_POPL_hp_cutOut,MISA_POPL_hp_altAvgd_cutOut,filter_cutoffPeriod,ISR_RTI_heightLimValues,ISR_POPL_plotLimValu,avgPt_coords[0,:],avgPt_ISRavgAlt,pointAltitude,time_cutout_range,dateRange,dateRange_dayNum,dateRange_dayNum_zeroHr,FONT_titleFM,FONT_axisTick,FONT_axisLabelFM,PLOT_lineWidth);
#END IF

#==============Analysis: Plot the delta-vTEC point-averaged time series with the ISR POPL HP altitude-averaged time series, along with an ISR RTI plot, over a cut-out time period==============
if( (FLG_avgPt_HP_timeMatch_POPL_plotWithISR_cutOut == 1) & (FLG_fancyPlot == 1) ):
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (avgPt_vTEC_timeMatch_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (avgPt_vTEC_timeMatch_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , \
        np.where(np.min(np.abs( (avgPt_vTEC_timeMatch_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (avgPt_vTEC_timeMatch_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range
    
    avgPt_vTEC_timeMatch_HP_cutOut = avgPt_vTEC_timeMatch_HP[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    avgPt_vTEC_timeMatch_time_cutOut = avgPt_vTEC_timeMatch_time[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , \
        np.where(np.min(np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range
    
    Zenith_time_cutOut = Zenith_time[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    Zenith_POPL_hp_cutOut = Zenith_POPL_hp[:,time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    Zenith_POPL_hp_altAvgd_cutOut = Zenith_POPL_hp_altAvgd[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    
    # time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , \
    #     np.where(np.min(np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( MISA_time - np.min(Zenith_time_cutOut) )) == np.abs( MISA_time - np.min(Zenith_time_cutOut) ) )[0][0] , \
        np.where(np.min(np.abs( MISA_time - np.max(Zenith_time_cutOut) )) == np.abs( MISA_time - np.max(Zenith_time_cutOut) ) )[0][0] ) ); #get the indexes for that time cutout range
        #this makes the MISA match the Zenith plot when cut to the same axis limits as Zenith
    MISA_time_cutOut = MISA_time[time_cutout_indexes[0]-1:time_cutout_indexes[1]+1+1]; #EXTRA down 1 up 1 to adjust for Zenith/MISA time mismatches
    MISA_POPL_hp_cutOut = MISA_POPL_hp[:,time_cutout_indexes[0]-1:time_cutout_indexes[1]+1+1]; #EXTRA down 1 up 1 to adjust for Zenith/MISA time mismatches
    MISA_POPL_hp_altAvgd_cutOut = MISA_POPL_hp_altAvgd[time_cutout_indexes[0]-1:time_cutout_indexes[1]+1+1]; #EXTRA down 1 up 1 to adjust for Zenith/MISA time mismatches
    
    GRITI_TEC_avgPt_HP_timeMatch_POPL_fancyPlot_plotWithISR_cutOut(avgPt_vTEC_timeMatch_HP_cutOut,avgPt_vTEC_timeMatch_time_cutOut, \
        Zenith_time_cutOut,Zenith_height,Zenith_POPL_hp_cutOut,Zenith_POPL_hp_altAvgd_cutOut,MISA_time_cutOut,MISA_height, \
        MISA_POPL_hp_cutOut,MISA_POPL_hp_altAvgd_cutOut,filter_cutoffPeriod,ISR_RTI_heightLimValues,ISR_POPL_plotLimValu, \
        avgPt_coords,avgPt_ISRavgAlt,pointAltitude,time_cutout_range,dateRange,dateRange_dayNum,dateRange_dayNum_zeroHr,
        dateRange_zeroHr, dateRange_zeroHr_monthName, dateRange_zeroHr_dayPostfix, \
        FONT_grandioseFM, FONT_titleFM,FONT_axisTick,FONT_axisLabelFM,PLOT_lineWidth, folder, journal_width_2C,journal_height_max,journal_dpi);
#END IF
    

#==============Analysis: Plot the delta-vTEC point-averaged time series with the ISR SNR HP altitude-averaged time series, along with an ISR RTI plot, over a cut-out time period==============
if( FLG_avgPt_HP_timeMatch_plotWithISR_ZenithOnly_cutOut == 1 ):
    #ZENITH ONLY - NO MISA!!!
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (avgPt_vTEC_timeMatch_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (avgPt_vTEC_timeMatch_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , \
        np.where(np.min(np.abs( (avgPt_vTEC_timeMatch_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (avgPt_vTEC_timeMatch_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range
    
    avgPt_vTEC_timeMatch_HP_cutOut = avgPt_vTEC_timeMatch_HP[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    avgPt_vTEC_timeMatch_time_cutOut = avgPt_vTEC_timeMatch_time[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , \
        np.where(np.min(np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range
    
    Zenith_time_cutOut = Zenith_time[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    Zenith_SNR_hp_cutOut = Zenith_SNR_hp[:,time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    Zenith_SNR_hp_altAvgd_cutOut = Zenith_SNR_hp_altAvgd[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , \
        np.where(np.min(np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range

    MISA_time_cutOut = MISA_time[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    MISA_SNR_hp_altAvgd_cutOut = MISA_SNR_hp_altAvgd[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    
    GRITI_TEC_avgPt_HP_timeMatch_plotWithISR_ZenithOnly_cutOut(avgPt_vTEC_timeMatch_HP_cutOut,avgPt_vTEC_timeMatch_time_cutOut,Zenith_time_cutOut,Zenith_height,Zenith_SNR_hp_cutOut,Zenith_SNR_hp_altAvgd_cutOut,MISA_time_cutOut,MISA_height,MISA_SNR_hp_altAvgd_cutOut,filter_cutoffPeriod,ISR_RTI_heightLimValues,ISR_plotLimValu,avgPt_coords[0,:],avgPt_ISRavgAlt,pointAltitude,time_cutout_range,dateRange,dateRange_dayNum,dateRange_dayNum_zeroHr,FONT_titleFM,FONT_axisTick,FONT_axisLabelFM,PLOT_lineWidth);  
    
#END IF
    

#==============Analysis: Plot the delta-vTEC point-averaged time series with the ISR POPL HP altitude-averaged time series, along with an ISR RTI plot, over a cut-out time period==============
if( FLG_avgPt_HP_timeMatch_POPL_plotWithISR_ZenithOnly_cutOut == 1 ):
    #ZENITH ONLY - NO MISA!!!
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (avgPt_vTEC_timeMatch_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (avgPt_vTEC_timeMatch_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , \
        np.where(np.min(np.abs( (avgPt_vTEC_timeMatch_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (avgPt_vTEC_timeMatch_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range
    
    avgPt_vTEC_timeMatch_HP_cutOut = avgPt_vTEC_timeMatch_HP[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    avgPt_vTEC_timeMatch_time_cutOut = avgPt_vTEC_timeMatch_time[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , \
        np.where(np.min(np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range
    
    Zenith_time_cutOut = Zenith_time[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    Zenith_POPL_hp_cutOut = Zenith_POPL_hp[:,time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    Zenith_POPL_hp_altAvgd_cutOut = Zenith_POPL_hp_altAvgd[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , \
        np.where(np.min(np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range

    MISA_time_cutOut = MISA_time[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    MISA_POPL_hp_altAvgd_cutOut = MISA_POPL_hp_altAvgd[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    
    GRITI_TEC_avgPt_HP_timeMatch_POPL_plotWithISR_ZenithOnly_cutOut(avgPt_vTEC_timeMatch_HP_cutOut,avgPt_vTEC_timeMatch_time_cutOut,Zenith_time_cutOut,Zenith_height,Zenith_POPL_hp_cutOut,Zenith_POPL_hp_altAvgd_cutOut,MISA_time_cutOut,MISA_height,MISA_POPL_hp_altAvgd_cutOut,filter_cutoffPeriod,ISR_RTI_heightLimValues,ISR_POPL_plotLimValu,avgPt_coords[0,:],avgPt_ISRavgAlt,pointAltitude,time_cutout_range,dateRange,dateRange_dayNum,dateRange_dayNum_zeroHr,FONT_titleFM,FONT_axisTick,FONT_axisLabelFM,PLOT_lineWidth);
    
#END IF
    
    
if( FLG_avgPt_HP_timeMatch_scargleWithISR_cutOut == 1 ):
    
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (avgPt_vTEC_timeMatch_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (avgPt_vTEC_timeMatch_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , \
        np.where(np.min(np.abs( (avgPt_vTEC_timeMatch_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (avgPt_vTEC_timeMatch_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range
    
    avgPt_vTEC_timeMatch_HP_cutOut = avgPt_vTEC_timeMatch_HP[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    avgPt_vTEC_timeMatch_time_cutOut = avgPt_vTEC_timeMatch_time[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , \
        np.where(np.min(np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range
    
    Zenith_time_cutOut = Zenith_time[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    Zenith_SNR_hp_cutOut = Zenith_SNR_hp[:,time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    Zenith_SNR_hp_altAvgd_cutOut = Zenith_SNR_hp_altAvgd[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , \
        np.where(np.min(np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range

    MISA_time_cutOut = MISA_time[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    MISA_SNR_hp_altAvgd_cutOut = MISA_SNR_hp_altAvgd[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    
    GRITI_TEC_avgPt_HP_timeMatch_scargleWithISR_cutOut(avgPt_vTEC_timeMatch_HP_cutOut,avgPt_vTEC_timeMatch_time_cutOut,Zenith_time_cutOut,Zenith_SNR_hp_altAvgd_cutOut,MISA_time_cutOut,MISA_SNR_hp_altAvgd_cutOut,pointAltitude,avgPt_ISRavgAlt,time_cutout_range,filter_cutoffPeriod,avgPt_pointRadius,plot_periodLim_max,dateRange,dateRange_dayNum,dateRange_dayNum_zeroHr,FONT_titleFM,FONT_axisTick,FONT_axisLabelFM,PLOT_lineWidth);
    
#END IF
    
if( FLG_avgPt_HP_timeMatch_POPL_scargleWithISR_cutOut == 1 ):
    
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (avgPt_vTEC_timeMatch_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (avgPt_vTEC_timeMatch_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , \
        np.where(np.min(np.abs( (avgPt_vTEC_timeMatch_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (avgPt_vTEC_timeMatch_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range
    
    avgPt_vTEC_timeMatch_HP_cutOut = avgPt_vTEC_timeMatch_HP[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    avgPt_vTEC_timeMatch_time_cutOut = avgPt_vTEC_timeMatch_time[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , \
        np.where(np.min(np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range
    
    Zenith_time_cutOut = Zenith_time[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    Zenith_POPL_hp_cutOut = Zenith_POPL_hp[:,time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    Zenith_POPL_hp_altAvgd_cutOut = Zenith_POPL_hp_altAvgd[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , \
        np.where(np.min(np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range

    MISA_time_cutOut = MISA_time[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    MISA_POPL_hp_altAvgd_cutOut = MISA_POPL_hp_altAvgd[time_cutout_indexes[0]:time_cutout_indexes[1]+1];

    GRITI_TEC_avgPt_HP_timeMatch_POPL_scargleWithISR_cutOut(avgPt_vTEC_timeMatch_HP_cutOut,avgPt_vTEC_timeMatch_time_cutOut,Zenith_time_cutOut,Zenith_POPL_hp_altAvgd_cutOut,MISA_time_cutOut,MISA_POPL_hp_altAvgd_cutOut,pointAltitude,avgPt_ISRavgAlt,time_cutout_range,filter_cutoffPeriod,avgPt_pointRadius,plot_periodLim_max,dateRange,dateRange_dayNum,dateRange_dayNum_zeroHr,FONT_titleFM,FONT_axisTick,FONT_axisLabelFM,PLOT_lineWidth);
#END IF

if( FLG_avgPt_HP_timeMatch_POPLnOMNI_scargleORfft_cutOut == 1 ):
    #Unpack line widths
    PLOT_lineWidthThicc = PLOT_lineWidth['thicc']; #get the line widths
    PLOT_lineWidthDoublePlus = PLOT_lineWidth['double plus']; #get the line widths
    PLOT_lineWidthPlus = PLOT_lineWidth['plus']; #get the line widths
    PLOT_lineWidthRegularPlus = PLOT_lineWidth['regular plus']; #get the line widths
    PLOT_lineWidthRegular = PLOT_lineWidth['regular']; #get the line widths
    PLOT_lineWidthSmol = PLOT_lineWidth['smol']; #get the line widths
    
    Zenith_time_delta = np.median(np.diff(Zenith_time)); #days, delta of time between readings
    MISA_time_delta = np.median(np.diff(MISA_time)); #days, delta of time between readings
    # Zenith_time_delta = np.median(np.diff(Zenith_time)); #days, delta of time between readings
    # MISA_time_delta = np.median(np.diff(MISA_time)); #days, delta of time between readings
#    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (avgPt_vTEC_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (avgPt_vTEC_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , \
#        np.where(np.min(np.abs( (avgPt_vTEC_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (avgPt_vTEC_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range
#    
#    avgPt_vTEC_HP_cutOut = avgPt_vTEC_HP[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
#    avgPt_vTEC_time_cutOut = avgPt_vTEC_time[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    
    #ZENITH NOW
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (avgPt_vTEC_timeMatch_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (avgPt_vTEC_timeMatch_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , \
        np.where(np.min(np.abs( (avgPt_vTEC_timeMatch_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (avgPt_vTEC_timeMatch_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range
    
    avgPt_vTEC_timeMatch_HP_cutOut = avgPt_vTEC_timeMatch_HP[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    avgPt_vTEC_timeMatch_time_cutOut = avgPt_vTEC_timeMatch_time[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , \
        np.where(np.min(np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range
    
    Zenith_time_cutOut = Zenith_time[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    Zenith_POPL_hp_cutOut = Zenith_POPL_hp[:,time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    Zenith_POPL_hp_altAvgd_cutOut = Zenith_POPL_hp_altAvgd[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    
    #MISA NOW
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (avgPt_vTEC_timeMatch_time_MISA-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (avgPt_vTEC_timeMatch_time_MISA-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , \
        np.where(np.min(np.abs( (avgPt_vTEC_timeMatch_time_MISA-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (avgPt_vTEC_timeMatch_time_MISA-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range
    
    avgPt_vTEC_timeMatch_HP_cutOut_MISA = avgPt_vTEC_timeMatch_HP_MISA[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    avgPt_vTEC_timeMatch_time_cutOut_MISA = avgPt_vTEC_timeMatch_time_MISA[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
            
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , 
        np.where(np.min(np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range
                             
    MISA_time_cutOut = MISA_time[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    MISA_POPL_hp_cutOut = MISA_POPL_hp[:,time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    MISA_POPL_hp_altAvgd_cutOut = MISA_POPL_hp_altAvgd[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    
    #OMNI plot prep
    OMNI_plot_label = OMNI_dictPlot[OMNI_dict[OMNI_plot_name]]; #get the label
    OMNI_plot_labelNoUnits = OMNI_plot_label[0:OMNI_plot_label.find('[')-1]; #remove the (units)
    
    #ZENITH NOW
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (OMNI_data_timeMatch_time_Zenith-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range_delayed_OMNI) )) == np.abs( (OMNI_data_timeMatch_time_Zenith-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range_delayed_OMNI) ) )[0][0] , \
        np.where(np.min(np.abs( (OMNI_data_timeMatch_time_Zenith-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range_delayed_OMNI) )) == np.abs( (OMNI_data_timeMatch_time_Zenith-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range_delayed_OMNI) ) )[0][0] ) ); #get the indexes for that time cutout range
    
    OMNI_data_timeMatch_HP_Zenith_cutOut = OMNI_data_timeMatch_HP_Zenith[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    OMNI_data_timeMatch_time_Zenith_cutOut = OMNI_data_timeMatch_time_Zenith[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    
    #NON-TIME MATCH!
#    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (OMNI_timeUnique-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range_delayed) )) == np.abs( (OMNI_timeUnique-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range_delayed) ) )[0][0] , \
#        np.where(np.min(np.abs( (OMNI_timeUnique-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range_delayed) )) == np.abs( (OMNI_timeUnique-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range_delayed) ) )[0][0] ) ); #get the indexes for that time cutout range
#    
#    OMNI_data_hp = subfun_highpass((OMNI_timeUnique - dateRange_dayNum_zeroHr[1]*86400),OMNI_data[:,OMNI_plot_index],filter_cutoffPeriod=filter_cutoffPeriod); #high-pass that data
#    
#    OMNI_data_hp_cutOut = OMNI_data_hp[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
#    OMNI_data_time_cutOut = OMNI_timeUnique[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    
    #MISA NOW
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (OMNI_data_timeMatch_time_MISA-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range_delayed_OMNI) )) == np.abs( (OMNI_data_timeMatch_time_MISA-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range_delayed_OMNI) ) )[0][0] , \
        np.where(np.min(np.abs( (OMNI_data_timeMatch_time_MISA-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range_delayed_OMNI) )) == np.abs( (OMNI_data_timeMatch_time_MISA-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range_delayed_OMNI) ) )[0][0] ) ); #get the indexes for that time cutout range
    
    OMNI_data_timeMatch_HP_MISA_cutOut = OMNI_data_timeMatch_HP_MISA[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    OMNI_data_timeMatch_time_MISA_cutOut = OMNI_data_timeMatch_time_MISA[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    
    window = np.hamming(110);
    nooverlap = 100
    nfft = 512
    Fs_Z = 1/(Zenith_time_delta*24*60); #min, zenith time delta in freq form
    Fs_M = 1/(MISA_time_delta*24*60); #min, MISA time delta in freq form
    Fs_OMNI = 1/(np.median(np.diff(OMNI_timeUnique))*24*60); #min, OMNI time delta in freq form
    
    from scipy import signal
    
    pwr_TEC_Z = np.sqrt(1/avgPt_vTEC_timeMatch_HP_cutOut.size*np.sum(avgPt_vTEC_timeMatch_HP_cutOut**2)); #estimate power of signal
    pwr_Z = np.sqrt(1/Zenith_POPL_hp_altAvgd_cutOut.size*np.sum(Zenith_POPL_hp_altAvgd_cutOut**2)); #estimate power of signal
    pwr_M = np.sqrt(1/MISA_POPL_hp_altAvgd_cutOut.size*np.sum(MISA_POPL_hp_altAvgd_cutOut**2)); #estimate power of signal
    pwr_OMNI_Z = np.sqrt(1/OMNI_data_timeMatch_HP_Zenith_cutOut.size*np.sum(OMNI_data_timeMatch_HP_Zenith_cutOut**2)); #estimate power of signal    
#    pwr_OMNI = np.sqrt(1/OMNI_data_hp_cutOut.size*np.sum(OMNI_data_hp_cutOut**2)); #estimate power of signal   
#    pwr_TEC_nomatch = np.sqrt(1/avgPt_vTEC_HP_cutOut.size*np.sum(avgPt_vTEC_HP_cutOut**2)); #estimate power of signal
    
    [freqs_TEC_Z,Cxx_TEC_Z] = signal.welch(1/pwr_TEC_Z*avgPt_vTEC_timeMatch_HP_cutOut ,window=window,noverlap=nooverlap,nfft=nfft,fs=Fs_Z);
#    window2 = np.hamming(np.int64(110*5.5));
#    nooverlap2 = np.int64(100*5.5);
#    nfft2 = 512*4;
#    [freqs_TEC_Z,Cxx_TEC_Z] = signal.welch(1/pwr_TEC_Z*avgPt_vTEC_timeMatch_HP_cutOut ,window=window,noverlap=nooverlap,nfft=nfft,fs=Fs_Z);
    [freqs_Z,Cxx_Z] = signal.welch(1/pwr_Z*Zenith_POPL_hp_altAvgd_cutOut ,window=window,noverlap=nooverlap,nfft=nfft,fs=Fs_Z);
    [freqs_M,Cxx_M] = signal.welch(1/pwr_M*MISA_POPL_hp_altAvgd_cutOut ,window=window,noverlap=nooverlap,nfft=nfft,fs=Fs_M);
    [freqs_OMNI_Z,Cxx_OMNI_Z] = signal.welch(1/pwr_OMNI_Z*OMNI_data_timeMatch_HP_Zenith_cutOut ,window=window,noverlap=nooverlap,nfft=nfft,fs=Fs_Z);
#    window2 = np.hamming(np.int64(110*5.5));
#    nooverlap2 = np.int64(100*5.5);
#    nfft2 = 512*4;
#    [freqs_OMNI_Z,Cxx_OMNI_Z] = signal.welch(1/pwr_OMNI*OMNI_data_hp_cutOut ,window=window2,noverlap=nooverlap2,nfft=nfft2,fs=Fs_OMNI);
    
    fig, ax = plt.subplots(nrows=1, ncols=1); #use instead of fig because it inits an axis too (I think I dunno)
    figManager = plt.get_current_fig_manager(); #req to maximize
    figManager.window.showMaximized(); #force maximized
    #Remove the aspect ratio from the basemap so it fills the screen better
    ax.set_aspect('auto');
    
    p1, = ax.plot(1/freqs_TEC_Z,Cxx_TEC_Z,color='xkcd:cerulean',linewidth=1.5, linestyle='-');
    p2, = ax.plot(1/freqs_Z,Cxx_Z,color='xkcd:deep red',linewidth=1.5, linestyle='--');
    p3, = ax.plot(1/freqs_M,Cxx_M,color='xkcd:goldenrod',linewidth=1.5, linestyle='-.');
    p4, = ax.plot(1/freqs_OMNI_Z,Cxx_OMNI_Z,color='xkcd:purple',linewidth=1.5, linestyle=':');
#    p4, = ax.plot(1/freqs_OMNI_Z,Cxx_OMNI_Z*OMNI_data_hp_cutOut.size/avgPt_vTEC_timeMatch_HP_cutOut.size,color='xkcd:purple',linewidth=1.5, linestyle=':');
    ax.set_xlim( (0, plot_periodLim_max) )
    ax.set_xlabel('Periods [min]',fontproperties=FONT_axisLabelFM);
    ax.set_ylabel('Arb. Power',fontproperties=FONT_axisLabelFM);
    ax.set_title('Power Spectra - (TEC HP\'d) Time Limited to '+str(str(np.round(time_cutout_range[0]/3600,2)).rstrip('0').rstrip('.'))+' to '+str(str(np.round(time_cutout_range[-1]/3600,2)).rstrip('0').rstrip('.'))+' hrs at Millstone '+str(np.round(latMillstone,2))+' degc lat/'+str(np.round(longMillstone,2))+' deg long on Day '+str(dateRange_dayNum_zeroHr[1])+', '+str(dateRange_dayNum_zeroHr[0]), \
        fontproperties=FONT_titleFM);
    ax.legend([p1,p2,p3,p4],['Point TEC AVG\'d to Zenith Times & HP', \
        'Zenith HP AVG\'d to '+str(pointAltitude)+' km +/-'+str(avgPt_ISRavgAlt)+' km',\
        'MISA HP AVG\'d to '+str(pointAltitude)+' km +/-'+str(avgPt_ISRavgAlt)+' km',\
        'OMNI '+OMNI_plot_labelNoUnits+' AVG\'d to Zenith Times & HP (Time Delayed '+str(time_cutout_range_delay_OMNI)+' hrs)'], \
        loc='upper left');
    
    xAxisTicks = np.arange( 0, plot_periodLim_max+10, 10); #sets the start hr, stop hr, and the step size between (in this case, 2 hr)
    ax.set_xticks(xAxisTicks); #set x axis ticks
    #final plot adjusting stuff
    fig.subplots_adjust(left = 0.065, right = 0.975, top = 0.96, bottom = 0.065 , hspace = 0.225); #sets padding to small numbers for minimal white space
    #fig.tight_layout(); #function for a tight layout, doesn't seem to do much here
    plt.show(); #req to make plot show up
    
    
    TEC_scargPeriod, TEC_scargPower, TEC_scarggf = subfun_lombscargle((avgPt_vTEC_timeMatch_time_cutOut - dateRange_dayNum_zeroHr[1]*86400)*60 , 1/pwr_TEC_Z*avgPt_vTEC_timeMatch_HP_cutOut); #scargle that data
#    TEC_scargPeriod, TEC_scargPower, TEC_scarggf = subfun_lombscargle((avgPt_vTEC_time_cutOut - dateRange_dayNum_zeroHr[1]*86400)*60 , 1/pwr_TEC_nomatch*avgPt_vTEC_HP_cutOut); #scargle that data
    Zenith_scargPeriod, Zenith_scargPower, Zenith_scarggf = subfun_lombscargle((Zenith_time_cutOut - dateRange_dayNum_zeroHr[1]*86400)*60 , 1/pwr_Z*Zenith_POPL_hp_altAvgd_cutOut); #scargle that data
    MISA_scargPeriod, MISA_scargPower, MISA_scarggf = subfun_lombscargle((MISA_time_cutOut - dateRange_dayNum_zeroHr[1]*86400)*60 , 1/pwr_M*MISA_POPL_hp_altAvgd_cutOut); #scargle that data
    OMNI_scargPeriod, OMNI_scargPower, OMNI_scarggf = subfun_lombscargle((OMNI_data_timeMatch_time_Zenith_cutOut - dateRange_dayNum_zeroHr[1]*86400)*60 , 1/pwr_OMNI_Z*OMNI_data_timeMatch_HP_Zenith_cutOut); #scargle that data
#    OMNI_scargPeriod, OMNI_scargPower, OMNI_scarggf = subfun_lombscargle((OMNI_data_time_cutOut - dateRange_dayNum_zeroHr[1]*86400)*60 , 1/pwr_OMNI*OMNI_data_hp_cutOut); #scargle that data
    
    fig, ax = plt.subplots(nrows=1, ncols=1); #use instead of fig because it inits an axis too (I think I dunno)
    figManager = plt.get_current_fig_manager(); #req to maximize
    figManager.window.showMaximized(); #force maximized
    #Remove the aspect ratio from the basemap so it fills the screen better
    ax.set_aspect('auto');
    
    p1, = ax.plot(TEC_scargPeriod,TEC_scargPower,color='xkcd:cerulean',linewidth=PLOT_lineWidthRegular, linestyle='-');
    ax.plot( TEC_scargPeriod, np.tile(TEC_scarggf,np.size(TEC_scargPeriod)) , color="xkcd:grey",linewidth=PLOT_lineWidthRegular, linestyle='-' ); #plot
    p2, = ax.plot(Zenith_scargPeriod,Zenith_scargPower,color='xkcd:deep red',linewidth=PLOT_lineWidthRegular, linestyle='--');
#    ax.plot( Zenith_scargPeriod, np.tile(Zenith_scarggf,np.size(Zenith_scargPeriod)) , color="xkcd:grey",linewidth=1.5, linestyle='--' ); #plot
    p3, = ax.plot(MISA_scargPeriod,MISA_scargPower,color='xkcd:goldenrod',linewidth=PLOT_lineWidthRegular, linestyle='-.');
#    ax.plot( MISA_scargPeriod, np.tile(MISA_scarggf,np.size(MISA_scargPeriod)) , color="xkcd:grey",linewidth=1.5, linestyle='-.' ); #plot
    p4, = ax.plot(OMNI_scargPeriod,OMNI_scargPower,color='xkcd:purple',linewidth=PLOT_lineWidthRegular, linestyle=':');
#    ax.plot( OMNI_scargPeriod, np.tile(OMNI_scarggf,np.size(OMNI_scargPeriod)) , color="xkcd:grey",linewidth=1.5, linestyle=':' ); #plot
    ax.set_xlim( (0, plot_periodLim_max) )
    ax.set_xlabel('Periods [min]',fontproperties=FONT_axisLabelFM);
    ax.set_ylabel('Normalized Power',fontproperties=FONT_axisLabelFM);
    ax.set_title('Lomb-Scargle Periodogram - (TEC HP\'d) Time Limited to '+str(str(np.round(time_cutout_range[0]/3600,2)).rstrip('0').rstrip('.'))+' to '+str(str(np.round(time_cutout_range[-1]/3600,2)).rstrip('0').rstrip('.'))+' hrs at Millstone '+str(np.round(latMillstone,2))+' degc lat/'+str(np.round(longMillstone,2))+' deg long on Day '+str(dateRange_dayNum_zeroHr[1])+', '+str(dateRange_dayNum_zeroHr[0]), \
        fontproperties=FONT_titleFM);
    ax.legend([p1,p2,p3,p4],['Point TEC AVG\'d to Zenith Times & HP', \
        'Zenith HP AVG\'d to '+str(pointAltitude)+' km +/-'+str(avgPt_ISRavgAlt)+' km',\
        'MISA HP AVG\'d to '+str(pointAltitude)+' km +/-'+str(avgPt_ISRavgAlt)+' km',\
        'OMNI '+OMNI_plot_label+' AVG\'d to Zenith Times & HP (Time Delayed '+str(time_cutout_range_delay_OMNI)+' hrs)'], \
        loc='upper left');
    
    xAxisTicks = np.arange( 0, plot_periodLim_max+10, 10); #sets the start hr, stop hr, and the step size between (in this case, 2 hr)
    ax.set_xticks(xAxisTicks); #set x axis ticks
    #final plot adjusting stuff
    fig.subplots_adjust(left = 0.065, right = 0.975, top = 0.96, bottom = 0.065 , hspace = 0.225); #sets padding to small numbers for minimal white space
    #fig.tight_layout(); #function for a tight layout, doesn't seem to do much here
    plt.show(); #req to make plot show up
#END IF

if( FLG_avgPt_HP_timeMatch_POPL_CPSD_cutOut == 1):
    #Unpack line widths
    PLOT_lineWidthThicc = PLOT_lineWidth['thicc']; #get the line widths
    PLOT_lineWidthDoublePlus = PLOT_lineWidth['double plus']; #get the line widths
    PLOT_lineWidthPlus = PLOT_lineWidth['plus']; #get the line widths
    PLOT_lineWidthRegularPlus = PLOT_lineWidth['regular plus']; #get the line widths
    PLOT_lineWidthRegular = PLOT_lineWidth['regular']; #get the line widths
    PLOT_lineWidthSmol = PLOT_lineWidth['smol']; #get the line widths
    
    Zenith_time_delta = np.median(np.diff(Zenith_time)); #days, delta of time between readings
    MISA_time_delta = np.median(np.diff(MISA_time)); #days, delta of time between readings
    #ZENITH NOW
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (avgPt_vTEC_timeMatch_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (avgPt_vTEC_timeMatch_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , \
        np.where(np.min(np.abs( (avgPt_vTEC_timeMatch_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (avgPt_vTEC_timeMatch_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range
    
    avgPt_vTEC_timeMatch_HP_cutOut = avgPt_vTEC_timeMatch_HP[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    avgPt_vTEC_timeMatch_time_cutOut = avgPt_vTEC_timeMatch_time[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , \
        np.where(np.min(np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range
    
    Zenith_time_cutOut = Zenith_time[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    Zenith_POPL_hp_cutOut = Zenith_POPL_hp[:,time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    Zenith_POPL_hp_altAvgd_cutOut = Zenith_POPL_hp_altAvgd[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    
    #MISA NOW
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (avgPt_vTEC_timeMatch_time_MISA-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (avgPt_vTEC_timeMatch_time_MISA-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , \
        np.where(np.min(np.abs( (avgPt_vTEC_timeMatch_time_MISA-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (avgPt_vTEC_timeMatch_time_MISA-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range
    
    avgPt_vTEC_timeMatch_HP_cutOut_MISA = avgPt_vTEC_timeMatch_HP_MISA[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    avgPt_vTEC_timeMatch_time_cutOut_MISA = avgPt_vTEC_timeMatch_time_MISA[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
            
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , 
        np.where(np.min(np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range
                             
    MISA_time_cutOut = MISA_time[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    MISA_POPL_hp_cutOut = MISA_POPL_hp[:,time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    MISA_POPL_hp_altAvgd_cutOut = MISA_POPL_hp_altAvgd[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    
    from scipy import signal
#    from matplotlib import mlab
    window = np.hamming(110);
#    window= np.pad(window,(0,512-110),mode='constant')
    Fs = 1/(Zenith_time_delta*24*60); #min, zenith time delta in freq form
    
    pwr_TECZ = np.sqrt(1/avgPt_vTEC_timeMatch_HP_cutOut.size*np.sum(avgPt_vTEC_timeMatch_HP_cutOut**2)); #estimate power of signal
    pwr_TECM = np.sqrt(1/avgPt_vTEC_timeMatch_HP_cutOut_MISA.size*np.sum(avgPt_vTEC_timeMatch_HP_cutOut_MISA**2)); #estimate power of signal
    pwr_Z = np.sqrt(1/Zenith_POPL_hp_altAvgd_cutOut.size*np.sum(Zenith_POPL_hp_altAvgd_cutOut**2)); #estimate power of signal
    pwr_M = np.sqrt(1/MISA_POPL_hp_altAvgd_cutOut.size*np.sum(MISA_POPL_hp_altAvgd_cutOut**2)); #estimate power of signal
    
    [freqs_TECvZ,Cxy_TECvZ] = signal.csd(1/pwr_TECZ*avgPt_vTEC_timeMatch_HP_cutOut,1/pwr_Z*Zenith_POPL_hp_altAvgd_cutOut,window=window,noverlap=100,nfft=512,fs=Fs);
#    [Cxy_TECvZ,freqs_TECvZ] = mlab.csd(avgPt_vTEC_timeMatch_HP_cutOut,Zenith_POPL_hp_altAvgd_cutOut,window=window,noverlap=100,NFFT=512,Fs=Fs);
    # [Cxy_TECvZ,freqs_TECvZ] = cpsd(vTEC_5minInterped_Zenith(tmin_Zenith:tmax_Zenith),Zenith_SNR_threeHun_AVGD(tmin_Zenith:tmax_Zenith),[],[],512,Fs);
    Axy_TECvZ = np.angle(Cxy_TECvZ)*180/np.pi; 
    Pxy_TECvZ = np.abs(Cxy_TECvZ);
#    Pxy_TECvZ = np.abs(Cxy_TECvZ)/np.max(np.abs(Cxy_TECvZ))*0.8659;
    
#    [_,Cxx_TEC] = signal.welch(avgPt_vTEC_timeMatch_HP_cutOut ,window=window,noverlap=100,nfft=512,fs=Fs);
#    [_,Cxx_Z] = signal.welch(Zenith_POPL_hp_altAvgd_cutOut ,window=window,noverlap=100,nfft=512,fs=Fs);
    
#    Pxy_TECvZ = Pxy_TECvZ / np.sqrt( np.abs(Cxx_TEC)*np.abs(Cxx_Z));
    
    #TEC (NO HIGH-PASS) VS MISA
    Fs = 1/(MISA_time_delta*24*60); #min, misa time delta in freq form
    [freqs_TECvM,Cxy_TECvM] = signal.csd(1/pwr_TECM*avgPt_vTEC_timeMatch_HP_cutOut_MISA,1/pwr_M*MISA_POPL_hp_altAvgd_cutOut,window=window,noverlap=100,nfft=512,fs=Fs);
#    [Cxy_TECvM,freqs_TECvM] = mlab.csd(avgPt_vTEC_timeMatch_HP_cutOut_MISA,MISA_POPL_hp_altAvgd_cutOut,window=window,noverlap=100,NFFT=512,Fs=Fs);
    # [Cxy_TECvM,freqs_TECvM] = cpsd(vTEC_5minInterped_MISA(tmin_MISA:tmax_MISA),MISA_SNR_threeHun_AVGD(tmin_MISA:tmax_MISA),[],[],512,Fs);
    Axy_TECvM = np.angle(Cxy_TECvM)*180/np.pi; 
    Pxy_TECvM = np.abs(Cxy_TECvM);
#    Pxy_TECvM = np.abs(Cxy_TECvM)/np.max(np.abs(Cxy_TECvM))*0.6646;
    
    #ZENITH VS MISA
    Fs = 1/(Zenith_time_delta*24*60); #min, zenith time delta in freq form
    [freqs_ZvM,Cxy_ZvM] = signal.csd(1/pwr_Z*Zenith_POPL_hp_altAvgd_cutOut,1/pwr_M*MISA_POPL_hp_altAvgd_cutOut,window=window,noverlap=100,nfft=512,fs=Fs);
#    [Cxy_ZvM,freqs_ZvM] = mlab.csd(Zenith_POPL_hp_altAvgd_cutOut,MISA_POPL_hp_altAvgd_cutOut,window=window,noverlap=100,NFFT=512,Fs=Fs);
    # [Cxy_ZvM,freqs_ZvM] = cpsd(Zenith_SNR_threeHun_AVGD(tmin_Zenith:tmax_Zenith),MISA_SNR_threeHun_AVGD(tmin_MISA:tmax_MISA),[],[],512,Fs);
    Axy_ZvM = np.angle(Cxy_ZvM)*180/np.pi; 
    Pxy_ZvM = np.abs(Cxy_ZvM);
#    Pxy_ZvM = np.abs(Cxy_ZvM)/np.max(np.abs(Cxy_ZvM))*1.0758;
    
    warnings.filterwarnings("ignore", category=RuntimeWarning); #silences warnings about NaNs used in a logical comparisons #yolo
    fig, ax = plt.subplots(nrows=1, ncols=1); #use instead of fig because it inits an axis too (I think I dunno)
    figManager = plt.get_current_fig_manager(); #req to maximize
    figManager.window.showMaximized(); #force maximized
    #Remove the aspect ratio from the basemap so it fills the screen better
    ax.set_aspect('auto');
    
    p1, = ax.plot(1/freqs_TECvZ,(Pxy_TECvZ),color='xkcd:cerulean',linewidth=PLOT_lineWidthRegular, linestyle='-');
    p2, = ax.plot(1/freqs_TECvM,(Pxy_TECvM),color='xkcd:deep red',linewidth=PLOT_lineWidthRegular, linestyle='--');
    p3, = ax.plot(1/freqs_ZvM,(Pxy_ZvM),color='xkcd:goldenrod',linewidth=PLOT_lineWidthRegular, linestyle='-.');
    ax.set_xlim( (0, plot_periodLim_max) )
    ax.set_xlabel('Periods [min]',fontproperties=FONT_axisLabelFM);
    ax.set_ylabel('Arb. Power',fontproperties=FONT_axisLabelFM);
    ax.set_title('Cross-Spectral Density - (TEC HP\'d) Time Limited to '+str(str(np.round(time_cutout_range[0]/3600,2)).rstrip('0').rstrip('.'))+' to '+str(str(np.round(time_cutout_range[-1]/3600,2)).rstrip('0').rstrip('.'))+' hrs at Millstone '+str(np.round(latMillstone,2))+' degc lat/'+str(np.round(longMillstone,2))+' deg long on Day '+str(dateRange_dayNum_zeroHr[1])+', '+str(dateRange_dayNum_zeroHr[0]), \
        fontproperties=FONT_titleFM);
    ax.legend([p1,p2,p3],['Point TEC AVG''d to Zenith Times & HP vs Zenith HP AVG''d '+str(pointAltitude)+' km +/-'+str(avgPt_ISRavgAlt)+' km', \
        'Point TEC AVG''d to MISA Times & HP vs MISA HP AVG''d '+str(pointAltitude)+' km +/-'+str(avgPt_ISRavgAlt)+' km', \
        ' Zenith & MISA HP AVG''d to '+str(pointAltitude)+' km +/-'+str(avgPt_ISRavgAlt)+' km'], \
        loc='upper left');
    
    xAxisTicks = np.arange( 0, plot_periodLim_max+10, 10); #sets the start hr, stop hr, and the step size between (in this case, 2 hr)
    ax.set_xticks(xAxisTicks); #set x axis ticks
    #final plot adjusting stuff
    fig.subplots_adjust(left = 0.065, right = 0.975, top = 0.96, bottom = 0.065 , hspace = 0.225); #sets padding to small numbers for minimal white space
    #fig.tight_layout(); #function for a tight layout, doesn't seem to do much here
    plt.show(); #req to make plot show up
    warnings.filterwarnings("default", category=RuntimeWarning); #silences warnings about NaNs used in a logical comparisons #yolo
#END IF
 
if( FLG_avgPt_HP_timeMatch_POPLnOMNI_FFT_cutOut == 1):
    #Unpack line widths
    PLOT_lineWidthThicc = PLOT_lineWidth['thicc']; #get the line widths
    PLOT_lineWidthDoublePlus = PLOT_lineWidth['double plus']; #get the line widths
    PLOT_lineWidthPlus = PLOT_lineWidth['plus']; #get the line widths
    PLOT_lineWidthRegularPlus = PLOT_lineWidth['regular plus']; #get the line widths
    PLOT_lineWidthRegular = PLOT_lineWidth['regular']; #get the line widths
    PLOT_lineWidthSmol = PLOT_lineWidth['smol']; #get the line widths
    
    Zenith_time_delta = np.median(np.diff(Zenith_time)); #days, delta of time between readings
    MISA_time_delta = np.median(np.diff(MISA_time)); #days, delta of time between readings

    #ZENITH NOW
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (avgPt_vTEC_timeMatch_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (avgPt_vTEC_timeMatch_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , \
        np.where(np.min(np.abs( (avgPt_vTEC_timeMatch_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (avgPt_vTEC_timeMatch_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range
    
    avgPt_vTEC_timeMatch_HP_cutOut = avgPt_vTEC_timeMatch_HP[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    avgPt_vTEC_timeMatch_time_cutOut = avgPt_vTEC_timeMatch_time[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , \
        np.where(np.min(np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range
    
    Zenith_time_cutOut = Zenith_time[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    # Zenith_POPL_hp_cutOut = Zenith_POPL_hp[:,time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    Zenith_POPL_hp_altAvgd_cutOut = Zenith_POPL_hp_altAvgd[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    
    #MISA NOW
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (avgPt_vTEC_timeMatch_time_MISA-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (avgPt_vTEC_timeMatch_time_MISA-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , \
        np.where(np.min(np.abs( (avgPt_vTEC_timeMatch_time_MISA-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (avgPt_vTEC_timeMatch_time_MISA-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range
    
    avgPt_vTEC_timeMatch_HP_cutOut_MISA = avgPt_vTEC_timeMatch_HP_MISA[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    avgPt_vTEC_timeMatch_time_cutOut_MISA = avgPt_vTEC_timeMatch_time_MISA[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
            
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , 
        np.where(np.min(np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range
                             
    MISA_time_cutOut = MISA_time[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    # MISA_POPL_hp_cutOut = MISA_POPL_hp[:,time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    MISA_POPL_hp_altAvgd_cutOut = MISA_POPL_hp_altAvgd[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    
    #OMNI plot prep
    OMNI_plot_label = OMNI_dictPlot[OMNI_dict[OMNI_plot_name]]; #get the label
    OMNI_plot_labelNoUnits = OMNI_plot_label[0:OMNI_plot_label.find('[')-1]; #remove the (units)
    
    #ZENITH NOW
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (OMNI_data_timeMatch_time_Zenith-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range_delayed_OMNI) )) == np.abs( (OMNI_data_timeMatch_time_Zenith-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range_delayed_OMNI) ) )[0][0] , \
        np.where(np.min(np.abs( (OMNI_data_timeMatch_time_Zenith-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range_delayed_OMNI) )) == np.abs( (OMNI_data_timeMatch_time_Zenith-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range_delayed_OMNI) ) )[0][0] ) ); #get the indexes for that time cutout range
    
    OMNI_data_timeMatch_HP_Zenith_cutOut = OMNI_data_timeMatch_HP_Zenith[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    OMNI_data_timeMatch_time_Zenith_cutOut = OMNI_data_timeMatch_time_Zenith[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    
    #MISA NOW
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (OMNI_data_timeMatch_time_MISA-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range_delayed_OMNI) )) == np.abs( (OMNI_data_timeMatch_time_MISA-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range_delayed_OMNI) ) )[0][0] , \
        np.where(np.min(np.abs( (OMNI_data_timeMatch_time_MISA-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range_delayed_OMNI) )) == np.abs( (OMNI_data_timeMatch_time_MISA-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range_delayed_OMNI) ) )[0][0] ) ); #get the indexes for that time cutout range
    
    OMNI_data_timeMatch_HP_MISA_cutOut = OMNI_data_timeMatch_HP_MISA[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    OMNI_data_timeMatch_time_MISA_cutOut = OMNI_data_timeMatch_time_MISA[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    
    from scipy import signal
#    from matplotlib import mlab
    window = np.hamming(110);
#    window= np.pad(window,(0,512-110),mode='constant')
    
    pwr_TEC_Z = np.sqrt(1/avgPt_vTEC_timeMatch_HP_cutOut.size*np.sum(avgPt_vTEC_timeMatch_HP_cutOut**2)); #estimate power of signal
    pwr_TEC_M = np.sqrt(1/avgPt_vTEC_timeMatch_HP_cutOut_MISA.size*np.sum(avgPt_vTEC_timeMatch_HP_cutOut_MISA**2)); #estimate power of signal
    pwr_Z = np.sqrt(1/Zenith_POPL_hp_altAvgd_cutOut.size*np.sum(Zenith_POPL_hp_altAvgd_cutOut**2)); #estimate power of signal
    pwr_M = np.sqrt(1/MISA_POPL_hp_altAvgd_cutOut.size*np.sum(MISA_POPL_hp_altAvgd_cutOut**2)); #estimate power of signal
    pwr_OMNI_Z = np.sqrt(1/OMNI_data_timeMatch_HP_Zenith_cutOut.size*np.sum(OMNI_data_timeMatch_HP_Zenith_cutOut**2)); #estimate power of signal
    pwr_OMNI_M = np.sqrt(1/OMNI_data_timeMatch_HP_MISA_cutOut.size*np.sum(OMNI_data_timeMatch_HP_MISA_cutOut**2)); #estimate power of signal
    
    Fs = 1/(Zenith_time_delta*24*60); #min, zenith time delta in freq form
    [freqs_TECZ,Cxx_TECZ] = signal.welch(1/pwr_TEC_Z*avgPt_vTEC_timeMatch_HP_cutOut ,window=window,noverlap=100,nfft=512,fs=Fs);
    [freqs_Z,Cxx_Z] = signal.welch(1/pwr_Z*Zenith_POPL_hp_altAvgd_cutOut ,window=window,noverlap=100,nfft=512,fs=Fs);
    [freqs_OMNIZ,Cxx_OMNIZ] = signal.welch(1/pwr_OMNI_Z*OMNI_data_timeMatch_HP_Zenith_cutOut ,window=window,noverlap=100,nfft=512,fs=Fs);
    
    Fs = 1/(MISA_time_delta*24*60); #min, MISA time delta in freq form
    [freqs_TECM,Cxx_TECM] = signal.welch(1/pwr_TEC_M*avgPt_vTEC_timeMatch_HP_cutOut_MISA ,window=window,noverlap=100,nfft=512,fs=Fs);
    [freqs_M,Cxx_M] = signal.welch(1/pwr_M*MISA_POPL_hp_altAvgd_cutOut ,window=window,noverlap=100,nfft=512,fs=Fs);
    [freqs_OMNIM,Cxx_OMNIM] = signal.welch(1/pwr_OMNI_M*OMNI_data_timeMatch_HP_MISA_cutOut ,window=window,noverlap=100,nfft=512,fs=Fs);
    
    warnings.filterwarnings("ignore", category=RuntimeWarning); #silences warnings about NaNs used in a logical comparisons #yolo
    fig, ax = plt.subplots(nrows=1, ncols=1); #use instead of fig because it inits an axis too (I think I dunno)
    figManager = plt.get_current_fig_manager(); #req to maximize
    figManager.window.showMaximized(); #force maximized
    #Remove the aspect ratio from the basemap so it fills the screen better
    ax.set_aspect('auto');
    
    p1, = ax.plot(1/freqs_TECZ,(Cxx_TECZ),color='xkcd:cerulean',linewidth=PLOT_lineWidthRegular, linestyle='-');
    p2, = ax.plot(1/freqs_TECM,(Cxx_TECM),color='xkcd:deep red',linewidth=PLOT_lineWidthRegular, linestyle='--');
    p3, = ax.plot(1/freqs_Z,(Cxx_Z),color='xkcd:goldenrod',linewidth=PLOT_lineWidthRegular, linestyle='-.');
    p4, = ax.plot(1/freqs_M,(Cxx_M),color='xkcd:purple',linewidth=PLOT_lineWidthRegular, linestyle='-.');
    p5, = ax.plot(1/freqs_OMNIZ,(Cxx_OMNIZ),color='xkcd:forest green',linewidth=PLOT_lineWidthRegular, linestyle='-.');
    p6, = ax.plot(1/freqs_OMNIM,(Cxx_OMNIM),color='xkcd:dark gray',linewidth=PLOT_lineWidthRegular, linestyle='-.');
    ax.set_xlim( (0, plot_periodLim_max) )
    ax.set_xlabel('Periods [min]',fontproperties=FONT_axisLabelFM);
    ax.set_ylabel('Arb. Power',fontproperties=FONT_axisLabelFM);
    ax.set_title('Spectral Comparison - (TEC HP\'d) Time Limited to '+str(str(np.round(time_cutout_range[0]/3600,2)).rstrip('0').rstrip('.'))+' to '+str(str(np.round(time_cutout_range[-1]/3600,2)).rstrip('0').rstrip('.'))+' hrs at Millstone '+str(np.round(latMillstone,2))+' degc lat/'+str(np.round(longMillstone,2))+' deg long on Day '+str(dateRange_dayNum_zeroHr[1])+', '+str(dateRange_dayNum_zeroHr[0]), \
        fontproperties=FONT_titleFM);
    ax.legend([p1,p2,p3,p4,p5,p6],['Point TEC AVG''d to Zenith Times & HP', \
        'Point TEC AVG''d to MISA Times & HP', \
        'Zenith HP AVG''d to '+str(pointAltitude)+' km +/-'+str(avgPt_ISRavgAlt)+' km',\
        'MISA HP AVG''d to '+str(pointAltitude)+' km +/-'+str(avgPt_ISRavgAlt)+' km',\
        'OMNI '+OMNI_plot_labelNoUnits+' AVG''d to Zenith Times & HP (Time Delayed '+str(time_cutout_range_delay_OMNI)+' hrs)', \
        'OMNI '+OMNI_plot_labelNoUnits+' AVG''d to MISA Times & HP (Time Delayed '+str(time_cutout_range_delay_OMNI)+' hrs)'], \
        loc='upper left');
    
    xAxisTicks = np.arange( 0, plot_periodLim_max+10, 10); #sets the start hr, stop hr, and the step size between (in this case, 2 hr)
    ax.set_xticks(xAxisTicks); #set x axis ticks
    #final plot adjusting stuff
    fig.subplots_adjust(left = 0.065, right = 0.975, top = 0.96, bottom = 0.065 , hspace = 0.225); #sets padding to small numbers for minimal white space
    #fig.tight_layout(); #function for a tight layout, doesn't seem to do much here
    plt.show(); #req to make plot show up
    warnings.filterwarnings("default", category=RuntimeWarning); #silences warnings about NaNs used in a logical comparisons #yolo
#END IF
   
if( FLG_avgPt_HP_timeMatch_POPLnOMNI_CPSD_cutOut == 1):
    #Unpack line widths
    PLOT_lineWidthThicc = PLOT_lineWidth['thicc']; #get the line widths
    PLOT_lineWidthDoublePlus = PLOT_lineWidth['double plus']; #get the line widths
    PLOT_lineWidthPlus = PLOT_lineWidth['plus']; #get the line widths
    PLOT_lineWidthRegularPlus = PLOT_lineWidth['regular plus']; #get the line widths
    PLOT_lineWidthRegular = PLOT_lineWidth['regular']; #get the line widths
    PLOT_lineWidthSmol = PLOT_lineWidth['smol']; #get the line widths
    
    Zenith_time_delta = np.median(np.diff(Zenith_time)); #days, delta of time between readings
    MISA_time_delta = np.median(np.diff(MISA_time)); #days, delta of time between readings

    #ZENITH NOW
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (avgPt_vTEC_timeMatch_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (avgPt_vTEC_timeMatch_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , \
        np.where(np.min(np.abs( (avgPt_vTEC_timeMatch_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (avgPt_vTEC_timeMatch_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range
    
    avgPt_vTEC_timeMatch_HP_cutOut = avgPt_vTEC_timeMatch_HP[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    avgPt_vTEC_timeMatch_time_cutOut = avgPt_vTEC_timeMatch_time[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , \
        np.where(np.min(np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range
    
    Zenith_time_cutOut = Zenith_time[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    # Zenith_POPL_hp_cutOut = Zenith_POPL_hp[:,time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    Zenith_POPL_hp_altAvgd_cutOut = Zenith_POPL_hp_altAvgd[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    
    #MISA NOW
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (avgPt_vTEC_timeMatch_time_MISA-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (avgPt_vTEC_timeMatch_time_MISA-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , \
        np.where(np.min(np.abs( (avgPt_vTEC_timeMatch_time_MISA-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (avgPt_vTEC_timeMatch_time_MISA-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range
    
    avgPt_vTEC_timeMatch_HP_cutOut_MISA = avgPt_vTEC_timeMatch_HP_MISA[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    avgPt_vTEC_timeMatch_time_cutOut_MISA = avgPt_vTEC_timeMatch_time_MISA[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
            
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , 
        np.where(np.min(np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range
                             
    MISA_time_cutOut = MISA_time[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    # MISA_POPL_hp_cutOut = MISA_POPL_hp[:,time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    MISA_POPL_hp_altAvgd_cutOut = MISA_POPL_hp_altAvgd[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    
    #OMNI plot prep
    OMNI_plot_label = OMNI_dictPlot[OMNI_dict[OMNI_plot_name]]; #get the label
    OMNI_plot_labelNoUnits = OMNI_plot_label[0:OMNI_plot_label.find('[')-1]; #remove the (units)
    
    #ZENITH NOW
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (OMNI_data_timeMatch_time_Zenith-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range_delayed_OMNI) )) == np.abs( (OMNI_data_timeMatch_time_Zenith-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range_delayed_OMNI) ) )[0][0] , \
        np.where(np.min(np.abs( (OMNI_data_timeMatch_time_Zenith-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range_delayed_OMNI) )) == np.abs( (OMNI_data_timeMatch_time_Zenith-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range_delayed_OMNI) ) )[0][0] ) ); #get the indexes for that time cutout range
    
    OMNI_data_timeMatch_HP_Zenith_cutOut = OMNI_data_timeMatch_HP_Zenith[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    OMNI_data_timeMatch_time_Zenith_cutOut = OMNI_data_timeMatch_time_Zenith[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    
    #MISA NOW
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (OMNI_data_timeMatch_time_MISA-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range_delayed_OMNI) )) == np.abs( (OMNI_data_timeMatch_time_MISA-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range_delayed_OMNI) ) )[0][0] , \
        np.where(np.min(np.abs( (OMNI_data_timeMatch_time_MISA-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range_delayed_OMNI) )) == np.abs( (OMNI_data_timeMatch_time_MISA-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range_delayed_OMNI) ) )[0][0] ) ); #get the indexes for that time cutout range
    
    OMNI_data_timeMatch_HP_MISA_cutOut = OMNI_data_timeMatch_HP_MISA[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    OMNI_data_timeMatch_time_MISA_cutOut = OMNI_data_timeMatch_time_MISA[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
        
    #align disparate timings
    if( Zenith_time_cutOut.size > MISA_time_cutOut.size ):
        #need to snip Zenith stuff
        Zenith_time_cutOut = Zenith_time_cutOut[:-1]; #snip
        Zenith_POPL_hp_altAvgd_cutOut = Zenith_POPL_hp_altAvgd_cutOut[:-1]; #snip
        avgPt_vTEC_timeMatch_time_cutOut = avgPt_vTEC_timeMatch_time_cutOut[:-1]; #snip
        avgPt_vTEC_timeMatch_HP_cutOut = avgPt_vTEC_timeMatch_HP_cutOut[:-1]; #snip
        OMNI_data_timeMatch_time_Zenith_cutOut = OMNI_data_timeMatch_time_Zenith_cutOut[:-1]; #snip
        OMNI_data_timeMatch_HP_Zenith_cutOut = OMNI_data_timeMatch_HP_Zenith_cutOut[:-1]; #snip
        if( OMNI_data_timeMatch_time_Zenith_cutOut.size > Zenith_time_cutOut.size ):
            #OMNI can have a time offset that could get extra off
            OMNI_data_timeMatch_time_Zenith_cutOut = OMNI_data_timeMatch_time_Zenith_cutOut[1:]; #snip from front this time
            OMNI_data_timeMatch_HP_Zenith_cutOut = OMNI_data_timeMatch_HP_Zenith_cutOut[1:]; #snip from front this time
        #END IF
    elif( Zenith_time_cutOut.size < MISA_time_cutOut.size ):
        #need to snip MISA stuff
        MISA_time_cutOut = MISA_time_cutOut[:-1]; #snip
        MISA_POPL_hp_altAvgd_cutOut = MISA_POPL_hp_altAvgd_cutOut[:-1]; #snip
        avgPt_vTEC_timeMatch_time_cutOut_MISA = avgPt_vTEC_timeMatch_time_cutOut_MISA[:-1]; #snip
        avgPt_vTEC_timeMatch_HP_cutOut_MISA = avgPt_vTEC_timeMatch_HP_cutOut_MISA[:-1]; #snip
        OMNI_data_timeMatch_time_MISA_cutOut = OMNI_data_timeMatch_time_MISA_cutOut[:-1]; #snip
        OMNI_data_timeMatch_HP_MISA_cutOut = OMNI_data_timeMatch_HP_MISA_cutOut[:-1]; #snip
        if( OMNI_data_timeMatch_time_MISA_cutOut.size > MISA_time_cutOut.size ):
            #OMNI can have a time offset that could get extra off
            OMNI_data_timeMatch_time_MISA_cutOut = OMNI_data_timeMatch_time_MISA_cutOut[1:]; #snip from front this time
            OMNI_data_timeMatch_HP_MISA_cutOut = OMNI_data_timeMatch_HP_MISA_cutOut[1:]; #snip from front this time
        #END IF
    #END IF
    
    from scipy import signal
#    from matplotlib import mlab
    window = np.hamming(110);
#    window= np.pad(window,(0,512-110),mode='constant')
    Fs = 1/(Zenith_time_delta*24*60); #min, zenith time delta in freq form
    
    pwr_TEC_Z = np.sqrt(1/avgPt_vTEC_timeMatch_HP_cutOut.size*np.sum(avgPt_vTEC_timeMatch_HP_cutOut**2)); #estimate power of signal
    pwr_TEC_M = np.sqrt(1/avgPt_vTEC_timeMatch_HP_cutOut_MISA.size*np.sum(avgPt_vTEC_timeMatch_HP_cutOut_MISA**2)); #estimate power of signal
    pwr_Z = np.sqrt(1/Zenith_POPL_hp_altAvgd_cutOut.size*np.sum(Zenith_POPL_hp_altAvgd_cutOut**2)); #estimate power of signal
    pwr_M = np.sqrt(1/MISA_POPL_hp_altAvgd_cutOut.size*np.sum(MISA_POPL_hp_altAvgd_cutOut**2)); #estimate power of signal
    pwr_OMNI_Z = np.sqrt(1/OMNI_data_timeMatch_HP_Zenith_cutOut.size*np.sum(OMNI_data_timeMatch_HP_Zenith_cutOut**2)); #estimate power of signal
    pwr_OMNI_M = np.sqrt(1/OMNI_data_timeMatch_HP_MISA_cutOut.size*np.sum(OMNI_data_timeMatch_HP_MISA_cutOut**2)); #estimate power of signal
    
    [freqs_TECvZ,Cxy_TECvZ] = signal.csd(1/pwr_TEC_Z*avgPt_vTEC_timeMatch_HP_cutOut,1/pwr_Z*Zenith_POPL_hp_altAvgd_cutOut,window=window,noverlap=100,nfft=512,fs=Fs);
#    [Cxy_TECvZ,freqs_TECvZ] = mlab.csd(avgPt_vTEC_timeMatch_HP_cutOut,Zenith_POPL_hp_altAvgd_cutOut,window=window,noverlap=100,NFFT=512,Fs=Fs);
    # [Cxy_TECvZ,freqs_TECvZ] = cpsd(vTEC_5minInterped_Zenith(tmin_Zenith:tmax_Zenith),Zenith_SNR_threeHun_AVGD(tmin_Zenith:tmax_Zenith),[],[],512,Fs);
    Axy_TECvZ = np.angle(Cxy_TECvZ)*180/np.pi; 
    Pxy_TECvZ = np.abs(Cxy_TECvZ);
#    Pxy_TECvZ = np.abs(Cxy_TECvZ)/np.max(np.abs(Cxy_TECvZ))*0.8659;
    
#    [_,Cxx_TEC] = signal.welch(avgPt_vTEC_timeMatch_HP_cutOut ,window=window,noverlap=100,nfft=512,fs=Fs);
#    [_,Cxx_Z] = signal.welch(Zenith_POPL_hp_altAvgd_cutOut ,window=window,noverlap=100,nfft=512,fs=Fs);
    
#    Pxy_TECvZ = Pxy_TECvZ / np.sqrt( np.abs(Cxx_TEC)*np.abs(Cxx_Z));
    
    #TEC (NO HIGH-PASS) VS MISA
    Fs = 1/(MISA_time_delta*24*60); #min, misa time delta in freq form
    [freqs_TECvM,Cxy_TECvM] = signal.csd(1/pwr_TEC_M*avgPt_vTEC_timeMatch_HP_cutOut_MISA,1/pwr_M*MISA_POPL_hp_altAvgd_cutOut,window=window,noverlap=100,nfft=512,fs=Fs);
#    [Cxy_TECvM,freqs_TECvM] = mlab.csd(avgPt_vTEC_timeMatch_HP_cutOut_MISA,MISA_POPL_hp_altAvgd_cutOut,window=window,noverlap=100,NFFT=512,Fs=Fs);
    # [Cxy_TECvM,freqs_TECvM] = cpsd(vTEC_5minInterped_MISA(tmin_MISA:tmax_MISA),MISA_SNR_threeHun_AVGD(tmin_MISA:tmax_MISA),[],[],512,Fs);
    Axy_TECvM = np.angle(Cxy_TECvM)*180/np.pi; 
    Pxy_TECvM = np.abs(Cxy_TECvM);
#    Pxy_TECvM = np.abs(Cxy_TECvM)/np.max(np.abs(Cxy_TECvM))*0.6646;
    
    #ZENITH VS MISA
    Fs = 1/(Zenith_time_delta*24*60); #min, zenith time delta in freq form
    [freqs_ZvM,Cxy_ZvM] = signal.csd(1/pwr_Z*Zenith_POPL_hp_altAvgd_cutOut,1/pwr_M*MISA_POPL_hp_altAvgd_cutOut,window=window,noverlap=100,nfft=512,fs=Fs);
#    [Cxy_ZvM,freqs_ZvM] = mlab.csd(Zenith_POPL_hp_altAvgd_cutOut,MISA_POPL_hp_altAvgd_cutOut,window=window,noverlap=100,NFFT=512,Fs=Fs);
    # [Cxy_ZvM,freqs_ZvM] = cpsd(Zenith_SNR_threeHun_AVGD(tmin_Zenith:tmax_Zenith),MISA_SNR_threeHun_AVGD(tmin_MISA:tmax_MISA),[],[],512,Fs);
    Axy_ZvM = np.angle(Cxy_ZvM)*180/np.pi; 
    Pxy_ZvM = np.abs(Cxy_ZvM);
#    Pxy_ZvM = np.abs(Cxy_ZvM)/np.max(np.abs(Cxy_ZvM))*1.0758;
    
    #OMNI VS ZENITH
    Fs = 1/(Zenith_time_delta*24*60); #min, zenith time delta in freq form
    [freqs_OMNIvZ,Cxy_OMNIvZ] = signal.csd(1/pwr_OMNI_Z*OMNI_data_timeMatch_HP_Zenith_cutOut,1/pwr_Z*Zenith_POPL_hp_altAvgd_cutOut,window=window,noverlap=100,nfft=512,fs=Fs);
    Axy_OMNIvZ = np.angle(Cxy_OMNIvZ)*180/np.pi; 
    Pxy_OMNIvZ = np.abs(Cxy_OMNIvZ);\
    
#    #OMNI VS TEC (both aligned to Zenith)
#    Fs = 1/(Zenith_time_delta*24*60); #min, zenith time delta in freq form
#    [freqs_OMNIvTEC_Z,Cxy_OMNIvTEC_Z] = signal.csd(1/pwr_OMNI_Z*OMNI_data_timeMatch_HP_Zenith_cutOut,1/pwr_TEC_Z*avgPt_vTEC_timeMatch_HP_cutOut,window=window,noverlap=100,nfft=512,fs=Fs);
#    Axy_OMNIvTEC_Z = np.angle(Cxy_OMNIvTEC_Z)*180/np.pi; 
#    Pxy_OMNIvTEC_Z = np.abs(Cxy_OMNIvTEC_Z);
    
    #OMNI VS MISA
    Fs = 1/(MISA_time_delta*24*60); #min, zenith time delta in freq form
    [freqs_OMNIvM,Cxy_OMNIvM] = signal.csd(1/pwr_OMNI_M*OMNI_data_timeMatch_HP_MISA_cutOut,1/pwr_M*MISA_POPL_hp_altAvgd_cutOut,window=window,noverlap=100,nfft=512,fs=Fs);
    Axy_OMNIvM = np.angle(Cxy_OMNIvM)*180/np.pi; 
    Pxy_OMNIvM = np.abs(Cxy_OMNIvM);\
    
#    #OMNI VS TEC (both aligned to MISA)
#    Fs = 1/(MISA_time_delta*24*60); #min, zenith time delta in freq form
#    [freqs_OMNIvTEC_M,Cxy_OMNIvTEC_M] = signal.csd(1/pwr_OMNI_M*OMNI_data_timeMatch_HP_MISA_cutOut,1/pwr_TEC_M*avgPt_vTEC_timeMatch_HP_cutOut_MISA,window=window,noverlap=100,nfft=512,fs=Fs);
#    Axy_OMNIvTEC_M = np.angle(Cxy_OMNIvTEC_M)*180/np.pi; 
#    Pxy_OMNIvTEC_M = np.abs(Cxy_OMNIvTEC_M);


    #Real quick side move to calc correlation coefficients
    R_TECZvZ = np.corrcoef(1/pwr_TEC_Z*avgPt_vTEC_timeMatch_HP_cutOut,1/pwr_Z*Zenith_POPL_hp_altAvgd_cutOut)[0,1];
    R_TECMvM = np.corrcoef(1/pwr_TEC_M*avgPt_vTEC_timeMatch_HP_cutOut_MISA,1/pwr_M*MISA_POPL_hp_altAvgd_cutOut)[0,1];
    R_ZvM = np.corrcoef(1/pwr_Z*Zenith_POPL_hp_altAvgd_cutOut,1/pwr_M*MISA_POPL_hp_altAvgd_cutOut)[0,1];
    # Z_pos = Zenith_POPL_hp_altAvgd_cutOut+np.abs(np.min(Zenith_POPL_hp_altAvgd_cutOut)); #make it positive
    # Z_posPwr = np.sqrt(1/Z_pos.size*np.sum(Z_pos**2)); #estimate power of signal
    # M_pos = MISA_POPL_hp_altAvgd_cutOut+np.abs(np.min(MISA_POPL_hp_altAvgd_cutOut)); #make it positive
    # M_posPwr = np.sqrt(1/M_pos.size*np.sum(M_pos**2)); #estimate power of signal
    # TECZ_pos = avgPt_vTEC_timeMatch_HP_cutOut+np.abs(np.min(avgPt_vTEC_timeMatch_HP_cutOut)); #make it positive
    # TECZ_posPwr = np.sqrt(1/TECZ_pos.size*np.sum(TECZ_pos**2)); #estimate power of signal
    # TECM_pos = avgPt_vTEC_timeMatch_HP_cutOut_MISA+np.abs(np.min(avgPt_vTEC_timeMatch_HP_cutOut_MISA)); #make it positive
    # TECM_posPwr = np.sqrt(1/TECM_pos.size*np.sum(TECM_pos**2)); #estimate power of signal
    # R_OMNIvZ = np.corrcoef(1/pwr_OMNI_Z*OMNI_data_timeMatch_HP_Zenith_cutOut,1/Z_posPwr*Z_pos)[0,1];
    # R_OMNIvTECZ = np.corrcoef(1/pwr_OMNI_Z*OMNI_data_timeMatch_HP_Zenith_cutOut,1/TECZ_posPwr*TECZ_pos)[0,1];
    # R_OMNIvM = np.corrcoef(1/pwr_OMNI_M*OMNI_data_timeMatch_HP_MISA_cutOut,1/M_posPwr*M_pos)[0,1];
    # R_OMNIvTECM = np.corrcoef(1/pwr_OMNI_M*OMNI_data_timeMatch_HP_MISA_cutOut,1/TECM_posPwr*TECM_pos)[0,1];
    R_OMNIvZ = np.corrcoef(1/pwr_OMNI_Z*OMNI_data_timeMatch_HP_Zenith_cutOut,1/pwr_Z*Zenith_POPL_hp_altAvgd_cutOut)[0,1];
    R_OMNIvTECZ = np.corrcoef(1/pwr_OMNI_Z*OMNI_data_timeMatch_HP_Zenith_cutOut,1/pwr_TEC_Z*avgPt_vTEC_timeMatch_HP_cutOut)[0,1];
    R_OMNIvM = np.corrcoef(1/pwr_OMNI_M*OMNI_data_timeMatch_HP_MISA_cutOut,1/pwr_M*MISA_POPL_hp_altAvgd_cutOut)[0,1];
    R_OMNIvTECM = np.corrcoef(1/pwr_OMNI_M*OMNI_data_timeMatch_HP_MISA_cutOut,1/pwr_TEC_M*avgPt_vTEC_timeMatch_HP_cutOut_MISA)[0,1];
    print('TECZvZ: '+str(np.round(R_TECZvZ,2))+' | TECMvM: '+str(np.round(R_TECMvM,2))+' | ZvM: '+str(np.round(R_ZvM,2))+' | OMNIvZ: '+str(np.round(R_OMNIvZ,2))+ \
          '\nOMNIvTECZ: '+str(np.round(R_OMNIvTECZ,2))+' | OMNIvM: '+str(np.round(R_OMNIvM,2))+' | OMNIvTECM: '+str(np.round(R_OMNIvTECM,2)));
    
    warnings.filterwarnings("ignore", category=RuntimeWarning); #silences warnings about NaNs used in a logical comparisons #yolo
    fig, ax = plt.subplots(nrows=1, ncols=1); #use instead of fig because it inits an axis too (I think I dunno)
    figManager = plt.get_current_fig_manager(); #req to maximize
    figManager.window.showMaximized(); #force maximized
    #Remove the aspect ratio from the basemap so it fills the screen better
    ax.set_aspect('auto');
    
    p1, = ax.plot(1/freqs_TECvZ,(Pxy_TECvZ),color='xkcd:cerulean',linewidth=PLOT_lineWidthRegular, linestyle='-');
    p2, = ax.plot(1/freqs_TECvM,(Pxy_TECvM),color='xkcd:deep red',linewidth=PLOT_lineWidthRegular, linestyle='--');
    p3, = ax.plot(1/freqs_ZvM,(Pxy_ZvM),color='xkcd:goldenrod',linewidth=PLOT_lineWidthRegular, linestyle='-.');
    p4, = ax.plot(1/freqs_OMNIvZ,(Pxy_OMNIvZ),color='xkcd:purple',linewidth=PLOT_lineWidthRegular, linestyle='-.');
#    p6, = ax.plot(1/freqs_OMNIvTEC_Z,(Pxy_OMNIvTEC_Z),color='xkcd:forest green',linewidth=PLOT_lineWidthRegular, linestyle='-.');
    p5, = ax.plot(1/freqs_OMNIvM,(Pxy_OMNIvM),color='xkcd:dark gray',linewidth=PLOT_lineWidthRegular, linestyle='-.');
#    p7, = ax.plot(1/freqs_OMNIvTEC_M,(Pxy_OMNIvTEC_M),color='xkcd:orange',linewidth=PLOT_lineWidthRegular, linestyle='-.');
    ax.set_xlim( (0, plot_periodLim_max) )
    ax.set_xlabel('Periods [min]',fontproperties=FONT_axisLabelFM);
    ax.set_ylabel('Arb. Power',fontproperties=FONT_axisLabelFM);
    ax.set_title('Cross-Spectral Density - (TEC HP\'d) Time Limited to '+str(str(np.round(time_cutout_range[0]/3600,2)).rstrip('0').rstrip('.'))+' to '+str(str(np.round(time_cutout_range[-1]/3600,2)).rstrip('0').rstrip('.'))+' hrs at Millstone '+str(np.round(latMillstone,2))+' degc lat/'+str(np.round(longMillstone,2))+' deg long on Day '+str(dateRange_dayNum_zeroHr[1])+', '+str(dateRange_dayNum_zeroHr[0]), \
        fontproperties=FONT_titleFM);
    ax.legend([p1,p2,p3,p4,p5],['Point TEC AVG''d to Zenith Times & HP vs Zenith HP AVG''d '+str(pointAltitude)+' km +/-'+str(avgPt_ISRavgAlt)+' km', \
        'Point TEC AVG''d to MISA Times & HP vs MISA HP AVG''d '+str(pointAltitude)+' km +/-'+str(avgPt_ISRavgAlt)+' km', \
        'Zenith & MISA HP AVG''d to '+str(pointAltitude)+' km +/-'+str(avgPt_ISRavgAlt)+' km',\
        'OMNI '+OMNI_plot_labelNoUnits+' AVG''d to Zenith Times & HP (Time Delayed '+str(time_cutout_range_delay_OMNI)+' hrs) vs Zenith HP AVG''d '+str(pointAltitude)+' km +/-'+str(avgPt_ISRavgAlt)+' km', \
#        'OMNI '+OMNI_plot_labelNoUnits+' AVG''d to Zenith Times & HP (Time Delayed '+str(time_cutout_range_delay)+' hrs) vs Point TEC AVG''d to Zenith Times & HP', \
        'OMNI '+OMNI_plot_labelNoUnits+' AVG''d to MISA Times & HP (Time Delayed '+str(time_cutout_range_delay_OMNI)+' hrs) vs MISA HP AVG''d '+str(pointAltitude)+' km +/-'+str(avgPt_ISRavgAlt)+' km'], \
#        'OMNI '+OMNI_plot_labelNoUnits+' AVG''d to MISA Times & HP (Time Delayed '+str(time_cutout_range_delay)+' hrs) vs Point TEC AVG''d to MISA Times & HP'], \
        loc='upper left');
    
    xAxisTicks = np.arange( 0, plot_periodLim_max+10, 10); #sets the start hr, stop hr, and the step size between (in this case, 2 hr)
    ax.set_xticks(xAxisTicks); #set x axis ticks
    #final plot adjusting stuff
    fig.subplots_adjust(left = 0.065, right = 0.975, top = 0.96, bottom = 0.065 , hspace = 0.225); #sets padding to small numbers for minimal white space
    #fig.tight_layout(); #function for a tight layout, doesn't seem to do much here
    plt.show(); #req to make plot show up
    warnings.filterwarnings("default", category=RuntimeWarning); #silences warnings about NaNs used in a logical comparisons #yolo
#END IF

if( FLG_avgPt_HP_timeMatch_POPLnOMNInTECNOISE_CPSD_cutOut == 1):
    if( FLG_TEC_noise >= 1 ):
        print('***WARNING***: FLG_TEC_noise is '+str(FLG_TEC_noise)+' which means that the TEC comparisons are meaningless (the TEC data has been replaced with noise). Fix that and re-run for this plot to be useful!'); #report issue
    #END IF
    
    #Unpack line widths
    PLOT_lineWidthThicc = PLOT_lineWidth['thicc']; #get the line widths
    PLOT_lineWidthDoublePlus = PLOT_lineWidth['double plus']; #get the line widths
    PLOT_lineWidthPlus = PLOT_lineWidth['plus']; #get the line widths
    PLOT_lineWidthRegularPlus = PLOT_lineWidth['regular plus']; #get the line widths
    PLOT_lineWidthRegular = PLOT_lineWidth['regular']; #get the line widths
    PLOT_lineWidthSmol = PLOT_lineWidth['smol']; #get the line widths
    
    Zenith_time_delta = np.median(np.diff(Zenith_time)); #days, delta of time between readings
    MISA_time_delta = np.median(np.diff(MISA_time)); #days, delta of time between readings
    
    #ZENITH NOW
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (avgPt_vTEC_timeMatch_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (avgPt_vTEC_timeMatch_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , \
        np.where(np.min(np.abs( (avgPt_vTEC_timeMatch_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (avgPt_vTEC_timeMatch_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range
    
    avgPt_vTEC_timeMatch_HP_cutOut = avgPt_vTEC_timeMatch_HP[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    avgPt_vTEC_timeMatch_time_cutOut = avgPt_vTEC_timeMatch_time[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    
    time_cutout_indexesZ = np.array( ( np.where(np.min(np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , \
        np.where(np.min(np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range
    
    Zenith_time_cutOut = Zenith_time[time_cutout_indexesZ[0]:time_cutout_indexesZ[1]+1];
    Zenith_POPL_hp_cutOut = Zenith_POPL_hp[:,time_cutout_indexesZ[0]:time_cutout_indexesZ[1]+1];
    Zenith_POPL_hp_altAvgd_cutOut = Zenith_POPL_hp_altAvgd[time_cutout_indexesZ[0]:time_cutout_indexesZ[1]+1];
    
    #MISA NOW
    time_cutout_indexesM = np.array( ( np.where(np.min(np.abs( (avgPt_vTEC_timeMatch_time_MISA-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (avgPt_vTEC_timeMatch_time_MISA-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , \
        np.where(np.min(np.abs( (avgPt_vTEC_timeMatch_time_MISA-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (avgPt_vTEC_timeMatch_time_MISA-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range
    
    avgPt_vTEC_timeMatch_HP_cutOut_MISA = avgPt_vTEC_timeMatch_HP_MISA[time_cutout_indexesM[0]:time_cutout_indexesM[1]+1];
    avgPt_vTEC_timeMatch_time_cutOut_MISA = avgPt_vTEC_timeMatch_time_MISA[time_cutout_indexesM[0]:time_cutout_indexesM[1]+1];
            
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , 
        np.where(np.min(np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range
                             
    MISA_time_cutOut = MISA_time[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    MISA_POPL_hp_cutOut = MISA_POPL_hp[:,time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    MISA_POPL_hp_altAvgd_cutOut = MISA_POPL_hp_altAvgd[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    
    #OMNI plot prep
    OMNI_plot_label = OMNI_dictPlot[OMNI_dict[OMNI_plot_name]]; #get the label
    OMNI_plot_labelNoUnits = OMNI_plot_label[0:OMNI_plot_label.find('[')-1]; #remove the (units)
    
    #ZENITH NOW
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (OMNI_data_timeMatch_time_Zenith-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range_delayed_OMNI) )) == np.abs( (OMNI_data_timeMatch_time_Zenith-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range_delayed_OMNI) ) )[0][0] , \
        np.where(np.min(np.abs( (OMNI_data_timeMatch_time_Zenith-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range_delayed_OMNI) )) == np.abs( (OMNI_data_timeMatch_time_Zenith-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range_delayed_OMNI) ) )[0][0] ) ); #get the indexes for that time cutout range
    
    OMNI_data_timeMatch_HP_Zenith_cutOut = OMNI_data_timeMatch_HP_Zenith[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    OMNI_data_timeMatch_time_Zenith_cutOut = OMNI_data_timeMatch_time_Zenith[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    
    #MISA NOW
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (OMNI_data_timeMatch_time_MISA-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range_delayed_OMNI) )) == np.abs( (OMNI_data_timeMatch_time_MISA-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range_delayed_OMNI) ) )[0][0] , \
        np.where(np.min(np.abs( (OMNI_data_timeMatch_time_MISA-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range_delayed_OMNI) )) == np.abs( (OMNI_data_timeMatch_time_MISA-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range_delayed_OMNI) ) )[0][0] ) ); #get the indexes for that time cutout range
    
    OMNI_data_timeMatch_HP_MISA_cutOut = OMNI_data_timeMatch_HP_MISA[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    OMNI_data_timeMatch_time_MISA_cutOut = OMNI_data_timeMatch_time_MISA[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    
    from scipy import signal
#    from matplotlib import mlab
    window = np.hamming(110);
#    window= np.pad(window,(0,512-110),mode='constant')
    Fs = 1/(Zenith_time_delta*24*60); #min, zenith time delta in freq form
    
    pwr_TEC_Z = np.sqrt(1/avgPt_vTEC_timeMatch_HP_cutOut.size*np.sum(avgPt_vTEC_timeMatch_HP_cutOut**2)); #estimate power of signal
    pwr_TEC_M = np.sqrt(1/avgPt_vTEC_timeMatch_HP_cutOut_MISA.size*np.sum(avgPt_vTEC_timeMatch_HP_cutOut_MISA**2)); #estimate power of signal
    pwr_Z = np.sqrt(1/Zenith_POPL_hp_altAvgd_cutOut.size*np.sum(Zenith_POPL_hp_altAvgd_cutOut**2)); #estimate power of signal
    pwr_M = np.sqrt(1/MISA_POPL_hp_altAvgd_cutOut.size*np.sum(MISA_POPL_hp_altAvgd_cutOut**2)); #estimate power of signal
    pwr_OMNI_Z = np.sqrt(1/OMNI_data_timeMatch_HP_Zenith_cutOut.size*np.sum(OMNI_data_timeMatch_HP_Zenith_cutOut**2)); #estimate power of signal
    pwr_OMNI_M = np.sqrt(1/OMNI_data_timeMatch_HP_MISA_cutOut.size*np.sum(OMNI_data_timeMatch_HP_MISA_cutOut**2)); #estimate power of signal
    
    [freqs_TECvZ,Cxy_TECvZ] = signal.csd(1/pwr_TEC_Z*avgPt_vTEC_timeMatch_HP_cutOut,1/pwr_Z*Zenith_POPL_hp_altAvgd_cutOut,window=window,noverlap=100,nfft=512,fs=Fs);
#    [Cxy_TECvZ,freqs_TECvZ] = mlab.csd(avgPt_vTEC_timeMatch_HP_cutOut,Zenith_POPL_hp_altAvgd_cutOut,window=window,noverlap=100,NFFT=512,Fs=Fs);
    # [Cxy_TECvZ,freqs_TECvZ] = cpsd(vTEC_5minInterped_Zenith(tmin_Zenith:tmax_Zenith),Zenith_SNR_threeHun_AVGD(tmin_Zenith:tmax_Zenith),[],[],512,Fs);
    Axy_TECvZ = np.angle(Cxy_TECvZ)*180/np.pi; 
    Pxy_TECvZ = np.abs(Cxy_TECvZ);
#    Pxy_TECvZ = np.abs(Cxy_TECvZ)/np.max(np.abs(Cxy_TECvZ))*0.8659;
    
#    [_,Cxx_TEC] = signal.welch(avgPt_vTEC_timeMatch_HP_cutOut ,window=window,noverlap=100,nfft=512,fs=Fs);
#    [_,Cxx_Z] = signal.welch(Zenith_POPL_hp_altAvgd_cutOut ,window=window,noverlap=100,nfft=512,fs=Fs);
    
#    Pxy_TECvZ = Pxy_TECvZ / np.sqrt( np.abs(Cxx_TEC)*np.abs(Cxx_Z));
    
    #TEC (NO HIGH-PASS) VS MISA
    Fs = 1/(MISA_time_delta*24*60); #min, misa time delta in freq form
    [freqs_TECvM,Cxy_TECvM] = signal.csd(1/pwr_TEC_M*avgPt_vTEC_timeMatch_HP_cutOut_MISA,1/pwr_M*MISA_POPL_hp_altAvgd_cutOut,window=window,noverlap=100,nfft=512,fs=Fs);
#    [Cxy_TECvM,freqs_TECvM] = mlab.csd(avgPt_vTEC_timeMatch_HP_cutOut_MISA,MISA_POPL_hp_altAvgd_cutOut,window=window,noverlap=100,NFFT=512,Fs=Fs);
    # [Cxy_TECvM,freqs_TECvM] = cpsd(vTEC_5minInterped_MISA(tmin_MISA:tmax_MISA),MISA_SNR_threeHun_AVGD(tmin_MISA:tmax_MISA),[],[],512,Fs);
    Axy_TECvM = np.angle(Cxy_TECvM)*180/np.pi; 
    Pxy_TECvM = np.abs(Cxy_TECvM);
#    Pxy_TECvM = np.abs(Cxy_TECvM)/np.max(np.abs(Cxy_TECvM))*0.6646;
    
    #ZENITH VS MISA
    Fs = 1/(Zenith_time_delta*24*60); #min, zenith time delta in freq form
    [freqs_ZvM,Cxy_ZvM] = signal.csd(1/pwr_Z*Zenith_POPL_hp_altAvgd_cutOut,1/pwr_M*MISA_POPL_hp_altAvgd_cutOut,window=window,noverlap=100,nfft=512,fs=Fs);
#    [Cxy_ZvM,freqs_ZvM] = mlab.csd(Zenith_POPL_hp_altAvgd_cutOut,MISA_POPL_hp_altAvgd_cutOut,window=window,noverlap=100,NFFT=512,Fs=Fs);
    # [Cxy_ZvM,freqs_ZvM] = cpsd(Zenith_SNR_threeHun_AVGD(tmin_Zenith:tmax_Zenith),MISA_SNR_threeHun_AVGD(tmin_MISA:tmax_MISA),[],[],512,Fs);
    Axy_ZvM = np.angle(Cxy_ZvM)*180/np.pi; 
    Pxy_ZvM = np.abs(Cxy_ZvM);
#    Pxy_ZvM = np.abs(Cxy_ZvM)/np.max(np.abs(Cxy_ZvM))*1.0758;
    
    #OMNI VS ZENITH
    Fs = 1/(Zenith_time_delta*24*60); #min, zenith time delta in freq form
    [freqs_OMNIvZ,Cxy_OMNIvZ] = signal.csd(1/pwr_OMNI_Z*OMNI_data_timeMatch_HP_Zenith_cutOut,1/pwr_Z*Zenith_POPL_hp_altAvgd_cutOut,window=window,noverlap=100,nfft=512,fs=Fs);
    Axy_OMNIvZ = np.angle(Cxy_OMNIvZ)*180/np.pi; 
    Pxy_OMNIvZ = np.abs(Cxy_OMNIvZ);\
    
#    #OMNI VS TEC (both aligned to Zenith)
    Fs = 1/(Zenith_time_delta*24*60); #min, zenith time delta in freq form
    [freqs_OMNIvTEC_Z,Cxy_OMNIvTEC_Z] = signal.csd(1/pwr_OMNI_Z*OMNI_data_timeMatch_HP_Zenith_cutOut,1/pwr_TEC_Z*avgPt_vTEC_timeMatch_HP_cutOut,window=window,noverlap=100,nfft=512,fs=Fs);
    Axy_OMNIvTEC_Z = np.angle(Cxy_OMNIvTEC_Z)*180/np.pi; 
    Pxy_OMNIvTEC_Z = np.abs(Cxy_OMNIvTEC_Z);
    
    #OMNI VS MISA
    Fs = 1/(MISA_time_delta*24*60); #min, zenith time delta in freq form
    [freqs_OMNIvM,Cxy_OMNIvM] = signal.csd(1/pwr_OMNI_M*OMNI_data_timeMatch_HP_MISA_cutOut,1/pwr_M*MISA_POPL_hp_altAvgd_cutOut,window=window,noverlap=100,nfft=512,fs=Fs);
    Axy_OMNIvM = np.angle(Cxy_OMNIvM)*180/np.pi; 
    Pxy_OMNIvM = np.abs(Cxy_OMNIvM);\
    
#    #OMNI VS TEC (both aligned to MISA)
    Fs = 1/(MISA_time_delta*24*60); #min, zenith time delta in freq form
    [freqs_OMNIvTEC_M,Cxy_OMNIvTEC_M] = signal.csd(1/pwr_OMNI_M*OMNI_data_timeMatch_HP_MISA_cutOut,1/pwr_TEC_M*avgPt_vTEC_timeMatch_HP_cutOut_MISA,window=window,noverlap=100,nfft=512,fs=Fs);
    Axy_OMNIvTEC_M = np.angle(Cxy_OMNIvTEC_M)*180/np.pi; 
    Pxy_OMNIvTEC_M = np.abs(Cxy_OMNIvTEC_M);
# 
    #now, noise comparisons
    TECZvTECZN_mat = np.zeros([np.int64(512/2+1),avgPt_TECnoise_iterations]);
    TECMvTECMN_mat = np.zeros([np.int64(512/2+1),avgPt_TECnoise_iterations]);
    ZvTECZN_mat = np.zeros([np.int64(512/2+1),avgPt_TECnoise_iterations]);
    MvTECMN_mat = np.zeros([np.int64(512/2+1),avgPt_TECnoise_iterations]);
    OMNIZvTECZN_mat = np.zeros([np.int64(512/2+1),avgPt_TECnoise_iterations]);
    OMNIMvTECMN_mat = np.zeros([np.int64(512/2+1),avgPt_TECnoise_iterations]);
    R_TECZvTECZN_mat = np.zeros([4,avgPt_TECnoise_iterations]);
    R_ZvTECZN_mat = np.zeros([4,avgPt_TECnoise_iterations]);
    R_OMNIZvTECZN_mat = np.zeros([4,avgPt_TECnoise_iterations]);
    R_TECMvTECMN_mat = np.zeros([4,avgPt_TECnoise_iterations]);
    R_MvTECMN_mat = np.zeros([4,avgPt_TECnoise_iterations]);
    R_OMNIMvTECMN_mat = np.zeros([4,avgPt_TECnoise_iterations]);
    pointRadiusAngular = (avgPt_pointRadius/Re)*180/np.pi; #get the angular radius to get a small subset of points to deal with
    k = ((avgPt_coords[0,0]-pointRadiusAngular <= data['TEC']['lat']) & (avgPt_coords[0,0]+pointRadiusAngular >= data['TEC']['lat'])) & \
        ((avgPt_coords[0,1]-pointRadiusAngular <= data['TEC']['long']) & (avgPt_coords[0,1]+pointRadiusAngular >= data['TEC']['long'])); #get only east coast to lower calcs needed
    kM = ((avgPt_coords[1,0]-pointRadiusAngular <= data['TEC']['lat']) & (avgPt_coords[1,0]+pointRadiusAngular >= data['TEC']['lat'])) & \
        ((avgPt_coords[1,1]-pointRadiusAngular <= data['TEC']['long']) & (avgPt_coords[1,1]+pointRadiusAngular >= data['TEC']['long'])); #get only east coast to lower calcs needed
    for i in range(0,avgPt_TECnoise_iterations):
        TEC_noise = GRITI_TEC_randomSynth(k.sum(),data['TEC']['lat'][k],data['TEC']['long'][k],data['TEC']['time'][k], \
            noise_background_mean,noise_background_stdev,Re,dateRange_zeroHr, \
            plotLatRange,plotLongRange,plotLatRange_autoTick,plotLongRange_autoTick, \
            wave_latRange,wave_longRange,wave_N,wave_angle,wave_phase,wave_waveLength,wave_period,wave_amp, \
            FONT_titleFM,FONT_axisTick,FONT_axisLabelFM,TEC_plotLimValu,1,FLG_plotStuff=0); #replace the delta-vTEC data with random data 
        
        TEC_noiseM = GRITI_TEC_randomSynth(kM.sum(),data['TEC']['lat'][kM],data['TEC']['long'][kM],data['TEC']['time'][kM], \
            noise_background_mean,noise_background_stdev,Re,dateRange_zeroHr, \
            plotLatRange,plotLongRange,plotLatRange_autoTick,plotLongRange_autoTick, \
            wave_latRange,wave_longRange,wave_N,wave_angle,wave_phase,wave_waveLength,wave_period,wave_amp, \
            FONT_titleFM,FONT_axisTick,FONT_axisLabelFM,TEC_plotLimValu,1,FLG_plotStuff=0); #replace the delta-vTEC data with random data 
        
        avgPt_TECnoise, _, avgPt_TECnoise_time, _, _, _  = \
            GRITI_TEC_avgPt(TEC_timeUnique,data['TEC']['lat'][k],data['TEC']['long'][k],data['TEC']['time'][k],TEC_noise, \
            avgPt_coords[0,:],avgPt_pointRadius,Re,dateRange_dayNum_zeroHr, \
            dataReject,dataRejectOrig,dataRejectLimit,dataRejectLimitOrig,dataRejectMax,FLG_report=0); #average points in a radius
            
        _, avgPt_TECnoise_timeMatch_HP, _ = GRITI_TEC_avgPt_timeMatch(avgPt_TECnoise,avgPt_TECnoise_time,Zenith_time,dateRange_dayNum_zeroHr,filter_cutoffPeriod=filter_cutoffPeriod);

        avgPt_TECnoise_timeMatch_HP_cutOut = avgPt_TECnoise_timeMatch_HP[time_cutout_indexesZ[0]:time_cutout_indexesZ[1]+1];

        avgPt_TECnoise_M, _, avgPt_TECnoise_time_M, _, _, _  = \
            GRITI_TEC_avgPt(TEC_timeUnique,data['TEC']['lat'][kM],data['TEC']['long'][kM],data['TEC']['time'][kM],TEC_noiseM, \
            avgPt_coords[1,:],avgPt_pointRadius,Re,dateRange_dayNum_zeroHr, \
            dataReject,dataRejectOrig,dataRejectLimit,dataRejectLimitOrig,dataRejectMax,FLG_report=0); #average points in a radius
        
        _, avgPt_TECnoise_timeMatch_HP_M, _ = GRITI_TEC_avgPt_timeMatch(avgPt_TECnoise_M,avgPt_TECnoise_time_M,MISA_time,dateRange_dayNum_zeroHr,filter_cutoffPeriod=filter_cutoffPeriod);
        
        avgPt_TECnoise_timeMatch_HP_cutOut_M = avgPt_TECnoise_timeMatch_HP_M[time_cutout_indexesM[0]:time_cutout_indexesM[1]+1];
        
        pwr_TECZN = np.sqrt(1/avgPt_TECnoise_timeMatch_HP_cutOut.size*np.sum(avgPt_TECnoise_timeMatch_HP_cutOut**2)); #estimate power of signal
        pwr_TECMN = np.sqrt(1/avgPt_TECnoise_timeMatch_HP_cutOut_M.size*np.sum(avgPt_TECnoise_timeMatch_HP_cutOut_M**2)); #estimate power of signal
        
        #ZENITH RELATED STUFF
        Fs = 1/(Zenith_time_delta*24*60); #min, zenith time delta in freq form
        #TECZ VS TECZNOISE
        [freqs_TECZvTECZN,Cxy_TECZvTECZN] = signal.csd(1/pwr_TEC_Z*avgPt_vTEC_timeMatch_HP_cutOut,1/pwr_TECZN*avgPt_TECnoise_timeMatch_HP_cutOut,window=window,noverlap=100,nfft=512,fs=Fs);
        Pxy_TECZvTECZN = np.abs(Cxy_TECZvTECZN);
        #Z VS TECZNOISE
        [freqs_ZvTECZN,Cxy_ZvTECZN] = signal.csd(1/pwr_Z*Zenith_POPL_hp_altAvgd_cutOut,1/pwr_TECZN*avgPt_TECnoise_timeMatch_HP_cutOut,window=window,noverlap=100,nfft=512,fs=Fs);
        Pxy_ZvTECZN = np.abs(Cxy_ZvTECZN);
        #OMNI VS TECZNOISE
        [freqs_OMNIZvTECZN,Cxy_OMNIZvTECZN] = signal.csd(1/pwr_OMNI_Z*OMNI_data_timeMatch_HP_Zenith_cutOut,1/pwr_TECZN*avgPt_TECnoise_timeMatch_HP_cutOut,window=window,noverlap=100,nfft=512,fs=Fs);
        Pxy_OMNIZvTECZN = np.abs(Cxy_OMNIZvTECZN);
        #MISA RELATED STUFF
        Fs = 1/(MISA_time_delta*24*60); #min, misa time delta in freq form
        #TECM VS TECMNOISE
        [freqs_TECMvTECMN,Cxy_TECMvTECMN] = signal.csd(1/pwr_TEC_M*avgPt_vTEC_timeMatch_HP_cutOut_MISA,1/pwr_TECMN*avgPt_TECnoise_timeMatch_HP_cutOut_M,window=window,noverlap=100,nfft=512,fs=Fs);
        Pxy_TECMvTECMN = np.abs(Cxy_TECMvTECMN);
        #M VS TECMNOISE
        [freqs_MvTECMN,Cxy_MvTECMN] = signal.csd(1/pwr_M*MISA_POPL_hp_altAvgd_cutOut,1/pwr_TECMN*avgPt_TECnoise_timeMatch_HP_cutOut_M,window=window,noverlap=100,nfft=512,fs=Fs);
        Pxy_MvTECMN = np.abs(Cxy_MvTECMN);
        #OMNI VS TECMNOISE
        [freqs_OMNIMvTECMN,Cxy_OMNIMvTECMN] = signal.csd(1/pwr_OMNI_M*OMNI_data_timeMatch_HP_MISA_cutOut,1/pwr_TECMN*avgPt_TECnoise_timeMatch_HP_cutOut_M,window=window,noverlap=100,nfft=512,fs=Fs);
        Pxy_OMNIMvTECMN = np.abs(Cxy_OMNIMvTECMN);
        
        #Real quick side move to calc correlation coefficients
        R_TECZvTECZN = np.corrcoef(1/pwr_TEC_Z*avgPt_vTEC_timeMatch_HP_cutOut,1/pwr_TECZN*avgPt_TECnoise_timeMatch_HP_cutOut);
        R_ZvTECZN = np.corrcoef(1/pwr_Z*Zenith_POPL_hp_altAvgd_cutOut,1/pwr_TECZN*avgPt_TECnoise_timeMatch_HP_cutOut);
        R_OMNIZvTECZN = np.corrcoef(1/pwr_OMNI_Z*OMNI_data_timeMatch_HP_Zenith_cutOut,1/pwr_TECZN*avgPt_TECnoise_timeMatch_HP_cutOut);
        R_TECMvTECMN = np.corrcoef(1/pwr_TEC_M*avgPt_vTEC_timeMatch_HP_cutOut_MISA,1/pwr_TECMN*avgPt_TECnoise_timeMatch_HP_cutOut_M);
        R_MvTECMN = np.corrcoef(1/pwr_M*MISA_POPL_hp_altAvgd_cutOut,1/pwr_TECMN*avgPt_TECnoise_timeMatch_HP_cutOut_M);
        R_OMNIMvTECMN = np.corrcoef(1/pwr_OMNI_M*np.concatenate( (OMNI_data_timeMatch_HP_MISA_cutOut,np.array((0,))) ),1/pwr_TECMN*avgPt_TECnoise_timeMatch_HP_cutOut_M);
        
        #RECORD FOR POSTERITY
        TECZvTECZN_mat[:,i] = Pxy_TECZvTECZN;
        TECMvTECMN_mat[:,i] = Pxy_TECMvTECMN;
        ZvTECZN_mat[:,i] = Pxy_ZvTECZN;
        MvTECMN_mat[:,i] = Pxy_MvTECMN;
        OMNIZvTECZN_mat[:,i] = Pxy_OMNIZvTECZN;
        OMNIMvTECMN_mat[:,i] = Pxy_OMNIMvTECMN;
        R_TECZvTECZN_mat[:,i] = R_TECZvTECZN.flatten();
        R_ZvTECZN_mat[:,i] = R_ZvTECZN.flatten();
        R_OMNIZvTECZN_mat[:,i] = R_OMNIZvTECZN.flatten();
        R_TECMvTECMN_mat[:,i] = R_TECMvTECMN.flatten();
        R_MvTECMN_mat[:,i] = R_MvTECMN.flatten();
        R_OMNIMvTECMN_mat[:,i] = R_OMNIMvTECMN.flatten();
    #END FOR i
    Pxy_TECZvTECZN = np.mean(TECZvTECZN_mat,axis=1);
    Pxy_TECMvTECMN = np.mean(TECMvTECMN_mat,axis=1);
    Pxy_ZvTECZN = np.mean(ZvTECZN_mat,axis=1);
    Pxy_MvTECMN = np.mean(MvTECMN_mat,axis=1);
    Pxy_OMNIZvTECZN = np.mean(OMNIZvTECZN_mat,axis=1);
    Pxy_OMNIMvTECMN = np.mean(OMNIMvTECMN_mat,axis=1);
    #Real quick side move to calc correlation coefficients
    R_TECZvTECZN = np.mean(R_TECZvTECZN_mat,axis=1)[1];
    R_ZvTECZN = np.mean(R_ZvTECZN_mat,axis=1)[1];
    R_OMNIZvTECZN = np.mean(R_OMNIZvTECZN_mat,axis=1)[1];
    R_TECMvTECMN = np.mean(R_TECMvTECMN_mat,axis=1)[1];
    R_MvTECMN = np.mean(R_MvTECMN_mat,axis=1)[1];
    R_OMNIMvTECMN = np.mean(R_OMNIMvTECMN_mat,axis=1)[1];
    
    #Real quick side move to calc correlation coefficients
    R_TECZvZ = np.corrcoef(1/pwr_TEC_Z*avgPt_vTEC_timeMatch_HP_cutOut,1/pwr_Z*Zenith_POPL_hp_altAvgd_cutOut)[0,1];
    R_TECMvM = np.corrcoef(1/pwr_TEC_M*avgPt_vTEC_timeMatch_HP_cutOut_MISA,1/pwr_M*MISA_POPL_hp_altAvgd_cutOut)[0,1];
    R_ZvM = np.corrcoef(1/pwr_Z*Zenith_POPL_hp_altAvgd_cutOut,1/pwr_M*MISA_POPL_hp_altAvgd_cutOut)[0,1];
    R_OMNIvZ = np.corrcoef(1/pwr_OMNI_Z*OMNI_data_timeMatch_HP_Zenith_cutOut,1/pwr_Z*Zenith_POPL_hp_altAvgd_cutOut)[0,1];
    R_OMNIvTECZ = np.corrcoef(1/pwr_OMNI_Z*OMNI_data_timeMatch_HP_Zenith_cutOut,1/pwr_TEC_Z*avgPt_vTEC_timeMatch_HP_cutOut)[0,1];
    R_OMNIvM = np.corrcoef(1/pwr_OMNI_M*np.concatenate( (OMNI_data_timeMatch_HP_MISA_cutOut,np.array((0,))) ),1/pwr_M*MISA_POPL_hp_altAvgd_cutOut)[0,1];
    R_OMNIvTECM = np.corrcoef(1/pwr_OMNI_M*np.concatenate( (OMNI_data_timeMatch_HP_MISA_cutOut,np.array((0,))) ),1/pwr_TEC_M*avgPt_vTEC_timeMatch_HP_cutOut_MISA)[0,1];
    print('TECZvZ: '+str(np.round(R_TECZvZ,2))+' | TECMvM: '+str(np.round(R_TECMvM,2))+' | ZvM: '+str(np.round(R_ZvM,2))+' | OMNIvZ: '+str(np.round(R_OMNIvZ,2))+ \
          '\nOMNIvTECZ: '+str(np.round(R_OMNIvTECZ,2))+' | OMNIvM: '+str(np.round(R_OMNIvM,2))+' | OMNIvTECM: '+str(np.round(R_OMNIvTECM,2))+
          ' | TECZvTECZN: '+str(np.round(R_TECZvTECZN,2))+'\nZvTECZN: '+str(np.round(R_ZvTECZN,2))+' | OMNIZvTECZN: '+str(np.round(R_OMNIZvTECZN,2))+ \
          ' | TECMvTECMN: '+str(np.round(R_TECMvTECMN,2))+' | MvTECMN: '+str(np.round(R_MvTECMN,2))+' | OMNIMvTECMN: '+str(np.round(R_OMNIMvTECMN,2)));
    
    
    warnings.filterwarnings("ignore", category=RuntimeWarning); #silences warnings about NaNs used in a logical comparisons #yolo
    fig, ax = plt.subplots(nrows=1, ncols=1); #use instead of fig because it inits an axis too (I think I dunno)
    figManager = plt.get_current_fig_manager(); #req to maximize
    figManager.window.showMaximized(); #force maximized
    #Remove the aspect ratio from the basemap so it fills the screen better
    ax.set_aspect('auto');
    
    p1, = ax.plot(1/freqs_TECvZ,(Pxy_TECvZ),color='xkcd:cerulean',linewidth=PLOT_lineWidthRegular, linestyle='-');
    p2, = ax.plot(1/freqs_TECvM,(Pxy_TECvM),color='xkcd:deep red',linewidth=PLOT_lineWidthRegular, linestyle='--');
    p3, = ax.plot(1/freqs_ZvM,(Pxy_ZvM),color='xkcd:goldenrod',linewidth=PLOT_lineWidthRegular, linestyle='-.');
    p4, = ax.plot(1/freqs_OMNIvZ,(Pxy_OMNIvZ),color='xkcd:purple',linewidth=PLOT_lineWidthRegular, linestyle='-.');
    p5, = ax.plot(1/freqs_OMNIvM,(Pxy_OMNIvM),color='xkcd:dark gray',linewidth=PLOT_lineWidthRegular, linestyle='-.');
    p6, = ax.plot(1/freqs_OMNIvTEC_Z,(Pxy_OMNIvTEC_Z),color='xkcd:forest green',linewidth=PLOT_lineWidthRegular, linestyle='-.');
    p7, = ax.plot(1/freqs_OMNIvTEC_M,(Pxy_OMNIvTEC_M),color='xkcd:orange',linewidth=PLOT_lineWidthRegular, linestyle='-.');
    p8, = ax.plot(1/freqs_TECZvTECZN,(Pxy_TECZvTECZN),color='xkcd:lavender',linewidth=PLOT_lineWidthRegular, linestyle='--');
    p9, = ax.plot(1/freqs_TECMvTECMN,(Pxy_TECMvTECMN),color='xkcd:lime green',linewidth=PLOT_lineWidthRegular, linestyle='--');
    p10, = ax.plot(1/freqs_ZvTECZN,(Pxy_ZvTECZN),color='xkcd:brown',linewidth=PLOT_lineWidthRegular, linestyle='--');
    p11, = ax.plot(1/freqs_MvTECMN,(Pxy_MvTECMN),color='xkcd:magenta',linewidth=PLOT_lineWidthRegular, linestyle='--');
    p12, = ax.plot(1/freqs_OMNIZvTECZN,(Pxy_OMNIZvTECZN),color='xkcd:teal',linewidth=PLOT_lineWidthRegular, linestyle='--');
    p13, = ax.plot(1/freqs_OMNIMvTECMN,(Pxy_OMNIMvTECMN),color='xkcd:green',linewidth=PLOT_lineWidthRegular, linestyle='--');
    errorMax = np.max([Pxy_TECZvTECZN.max(),Pxy_TECMvTECMN.max(),Pxy_ZvTECZN.max(),Pxy_MvTECMN.max(),
                       Pxy_OMNIZvTECZN.max(),Pxy_OMNIMvTECMN.max()]);
    pLine = ax.hlines(errorMax,np.min(1/freqs_TECvZ),plot_periodLim_max,color='xkcd:fire engine red',linewidth=PLOT_lineWidthRegular, linestyle='--');
    ax.set_xlabel('Periods [min]',fontproperties=FONT_axisLabelFM);
    ax.set_ylabel('Arb. Power',fontproperties=FONT_axisLabelFM);
    ax.set_title('Cross-Spectral Density - Noise '+str(avgPt_TECnoise_iterations)+' Iteration Average Time Limited to '+str(str(np.round(time_cutout_range[0]/3600,2)).rstrip('0').rstrip('.'))+' to '+str(str(np.round(time_cutout_range[-1]/3600,2)).rstrip('0').rstrip('.'))+' hrs w/ OMNI time delayed by'+str(time_cutout_range_delay_OMNI)+' hrs on Day '+str(dateRange_dayNum_zeroHr[1])+', '+str(dateRange_dayNum_zeroHr[0]), \
        fontproperties=FONT_titleFM);
    ax.legend([p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13],
        # ['Point TEC AVG''d to Zenith Times & HP vs Zenith HP AVG''d '+str(pointAltitude)+' km +/-'+str(avgPt_ISRavgAlt)+' km', \
        # 'Point TEC AVG''d to MISA Times & HP vs MISA HP AVG''d '+str(pointAltitude)+' km +/-'+str(avgPt_ISRavgAlt)+' km', \
        # 'Zenith & MISA HP AVG''d to '+str(pointAltitude)+' km +/-'+str(avgPt_ISRavgAlt)+' km',\
        # 'OMNI '+OMNI_plot_labelNoUnits+' AVG''d to Zenith Times & HP (Time Delayed '+str(time_cutout_range_delay)+' hrs) vs Zenith HP AVG''d '+str(pointAltitude)+' km +/-'+str(avgPt_ISRavgAlt)+' km', \
        # 'OMNI '+OMNI_plot_labelNoUnits+' AVG''d to MISA Times & HP (Time Delayed '+str(time_cutout_range_delay)+' hrs) vs MISA HP AVG''d '+str(pointAltitude)+' km +/-'+str(avgPt_ISRavgAlt)+' km', \
        # 'OMNI '+OMNI_plot_labelNoUnits+' AVG''d to Zenith Times & HP (Time Delayed '+str(time_cutout_range_delay)+' hrs) vs Point TEC AVG''d to Zenith Times & HP', \
        # 'OMNI '+OMNI_plot_labelNoUnits+' AVG''d to MISA Times & HP (Time Delayed '+str(time_cutout_range_delay)+' hrs) vs Point TEC AVG''d to MISA Times & HP', \
        ['TEC@Z vs Z ISR', \
        'TEC@M vs M ISR', \
        'Z ISR vs M ISR', \
        'OMNI ON Z vs Z ISR', \
        'OMNI ON M  vs M ISR', \
        'OMNI ON Z vs TEC@Z', \
        'OMNI ON M vs TEC@M', \
        'TEC@Z vs TECnoise@Z',\
        'TEC@M vs TECnoise@M',\
        'Z ISR vs TECnoise@Z',\
        'M ISR vs TECnoise@M',\
        'OMNI ON Z vs TECnoise@Z',\
        'OMNI ON M vs TECnoise@Z'], \
        loc='upper left');
    
    xAxisTicks = np.arange( 0, plot_periodLim_max+10, 10); #sets the start hr, stop hr, and the step size between (in this case, 2 hr)
    ax.set_xticks(xAxisTicks); #set x axis ticks
    ax.set_xlim( (np.min(1/freqs_TECvZ), plot_periodLim_max) )
    #final plot adjusting stuff
    fig.subplots_adjust(left = 0.065, right = 0.975, top = 0.96, bottom = 0.065 , hspace = 0.225); #sets padding to small numbers for minimal white space
    #fig.tight_layout(); #function for a tight layout, doesn't seem to do much here
    plt.show(); #req to make plot show up
    warnings.filterwarnings("default", category=RuntimeWarning); #silences warnings about NaNs used in a logical comparisons #yolo
#END IF

if( (FLG_avgPt_HP_timeMatch_POPLnTECNOISE_CPSD_cutOut == 1) & (FLG_fancyPlot == 1) ):
    print('MAKING FANCY PLOT: TEC_avgPt_HP_timeMatch_POPLnTECNOISE_CPSD_cutOut IN fancyPlot FOLDER'); #report since you won't see anything
    from mpl_toolkits.axes_grid1 import make_axes_locatable
    if( FLG_TEC_noise >= 1 ):
        print('***ERROR***: FLG_TEC_noise is '+str(FLG_TEC_noise)+' which means that the TEC comparisons are meaningless (the TEC data has been replaced with noise). Fix that and re-run for this plot to be useful!'); #report issue
        sys.exit();
    #END IF
    Zenith_time_delta = np.median(np.diff(Zenith_time)); #days, delta of time between readings
    MISA_time_delta = np.median(np.diff(MISA_time)); #days, delta of time between readings
    
    #ZENITH NOW
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (avgPt_vTEC_timeMatch_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (avgPt_vTEC_timeMatch_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , \
        np.where(np.min(np.abs( (avgPt_vTEC_timeMatch_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (avgPt_vTEC_timeMatch_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range
    
    avgPt_vTEC_timeMatch_HP_cutOut = avgPt_vTEC_timeMatch_HP[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    avgPt_vTEC_timeMatch_time_cutOut = avgPt_vTEC_timeMatch_time[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    
    time_cutout_indexesZ = np.array( ( np.where(np.min(np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , \
        np.where(np.min(np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range
    
    Zenith_time_cutOut = Zenith_time[time_cutout_indexesZ[0]:time_cutout_indexesZ[1]+1];
    Zenith_POPL_hp_cutOut = Zenith_POPL_hp[:,time_cutout_indexesZ[0]:time_cutout_indexesZ[1]+1];
    Zenith_POPL_hp_altAvgd_cutOut = Zenith_POPL_hp_altAvgd[time_cutout_indexesZ[0]:time_cutout_indexesZ[1]+1];
    
    #MISA NOW
    time_cutout_indexesM = np.array( ( np.where(np.min(np.abs( (avgPt_vTEC_timeMatch_time_MISA-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (avgPt_vTEC_timeMatch_time_MISA-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , \
        np.where(np.min(np.abs( (avgPt_vTEC_timeMatch_time_MISA-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (avgPt_vTEC_timeMatch_time_MISA-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range
    
    avgPt_vTEC_timeMatch_HP_cutOut_MISA = avgPt_vTEC_timeMatch_HP_MISA[time_cutout_indexesM[0]:time_cutout_indexesM[1]+1];
    avgPt_vTEC_timeMatch_time_cutOut_MISA = avgPt_vTEC_timeMatch_time_MISA[time_cutout_indexesM[0]:time_cutout_indexesM[1]+1];
            
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , 
        np.where(np.min(np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range
                             
    MISA_time_cutOut = MISA_time[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    MISA_POPL_hp_cutOut = MISA_POPL_hp[:,time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    MISA_POPL_hp_altAvgd_cutOut = MISA_POPL_hp_altAvgd[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    
    from scipy import signal
#    from matplotlib import mlab
    window = np.hamming(110);
#    window= np.pad(window,(0,512-110),mode='constant')
    Fs = 1/(Zenith_time_delta*24*60); #min, zenith time delta in freq form
    
    pwr_TEC_Z = np.sqrt(1/avgPt_vTEC_timeMatch_HP_cutOut.size*np.sum(avgPt_vTEC_timeMatch_HP_cutOut**2)); #estimate power of signal
    pwr_TEC_M = np.sqrt(1/avgPt_vTEC_timeMatch_HP_cutOut_MISA.size*np.sum(avgPt_vTEC_timeMatch_HP_cutOut_MISA**2)); #estimate power of signal
    pwr_Z = np.sqrt(1/Zenith_POPL_hp_altAvgd_cutOut.size*np.sum(Zenith_POPL_hp_altAvgd_cutOut**2)); #estimate power of signal
    pwr_M = np.sqrt(1/MISA_POPL_hp_altAvgd_cutOut.size*np.sum(MISA_POPL_hp_altAvgd_cutOut**2)); #estimate power of signal

    [freqs_TECvZ,Cxy_TECvZ] = signal.csd(1/pwr_TEC_Z*avgPt_vTEC_timeMatch_HP_cutOut,1/pwr_Z*Zenith_POPL_hp_altAvgd_cutOut,window=window,noverlap=100,nfft=512,fs=Fs);
#    [Cxy_TECvZ,freqs_TECvZ] = mlab.csd(avgPt_vTEC_timeMatch_HP_cutOut,Zenith_POPL_hp_altAvgd_cutOut,window=window,noverlap=100,NFFT=512,Fs=Fs);
    # [Cxy_TECvZ,freqs_TECvZ] = cpsd(vTEC_5minInterped_Zenith(tmin_Zenith:tmax_Zenith),Zenith_SNR_threeHun_AVGD(tmin_Zenith:tmax_Zenith),[],[],512,Fs);
    Axy_TECvZ = np.angle(Cxy_TECvZ)*180/np.pi; 
    Pxy_TECvZ = np.abs(Cxy_TECvZ);
#    Pxy_TECvZ = np.abs(Cxy_TECvZ)/np.max(np.abs(Cxy_TECvZ))*0.8659;
    
#    [_,Cxx_TEC] = signal.welch(avgPt_vTEC_timeMatch_HP_cutOut ,window=window,noverlap=100,nfft=512,fs=Fs);
#    [_,Cxx_Z] = signal.welch(Zenith_POPL_hp_altAvgd_cutOut ,window=window,noverlap=100,nfft=512,fs=Fs);
    
#    Pxy_TECvZ = Pxy_TECvZ / np.sqrt( np.abs(Cxx_TEC)*np.abs(Cxx_Z));
    
    #TEC (NO HIGH-PASS) VS MISA
    Fs = 1/(MISA_time_delta*24*60); #min, misa time delta in freq form
    [freqs_TECvM,Cxy_TECvM] = signal.csd(1/pwr_TEC_M*avgPt_vTEC_timeMatch_HP_cutOut_MISA,1/pwr_M*MISA_POPL_hp_altAvgd_cutOut,window=window,noverlap=100,nfft=512,fs=Fs);
#    [Cxy_TECvM,freqs_TECvM] = mlab.csd(avgPt_vTEC_timeMatch_HP_cutOut_MISA,MISA_POPL_hp_altAvgd_cutOut,window=window,noverlap=100,NFFT=512,Fs=Fs);
    # [Cxy_TECvM,freqs_TECvM] = cpsd(vTEC_5minInterped_MISA(tmin_MISA:tmax_MISA),MISA_SNR_threeHun_AVGD(tmin_MISA:tmax_MISA),[],[],512,Fs);
    Axy_TECvM = np.angle(Cxy_TECvM)*180/np.pi; 
    Pxy_TECvM = np.abs(Cxy_TECvM);
#    Pxy_TECvM = np.abs(Cxy_TECvM)/np.max(np.abs(Cxy_TECvM))*0.6646;
    
    #ZENITH VS MISA
    Fs = 1/(Zenith_time_delta*24*60); #min, zenith time delta in freq form
    [freqs_ZvM,Cxy_ZvM] = signal.csd(1/pwr_Z*Zenith_POPL_hp_altAvgd_cutOut,1/pwr_M*MISA_POPL_hp_altAvgd_cutOut,window=window,noverlap=100,nfft=512,fs=Fs);
#    [Cxy_ZvM,freqs_ZvM] = mlab.csd(Zenith_POPL_hp_altAvgd_cutOut,MISA_POPL_hp_altAvgd_cutOut,window=window,noverlap=100,NFFT=512,Fs=Fs);
    # [Cxy_ZvM,freqs_ZvM] = cpsd(Zenith_SNR_threeHun_AVGD(tmin_Zenith:tmax_Zenith),MISA_SNR_threeHun_AVGD(tmin_MISA:tmax_MISA),[],[],512,Fs);
    Axy_ZvM = np.angle(Cxy_ZvM)*180/np.pi; 
    Pxy_ZvM = np.abs(Cxy_ZvM);
#    Pxy_ZvM = np.abs(Cxy_ZvM)/np.max(np.abs(Cxy_ZvM))*1.0758;
    
# 
    #now, noise comparisons
    TECZvTECZN_mat = np.zeros([np.int64(512/2+1),avgPt_TECnoise_iterations]);
    TECMvTECMN_mat = np.zeros([np.int64(512/2+1),avgPt_TECnoise_iterations]);
    ZvTECZN_mat = np.zeros([np.int64(512/2+1),avgPt_TECnoise_iterations]);
    MvTECMN_mat = np.zeros([np.int64(512/2+1),avgPt_TECnoise_iterations]);
    R_TECZvTECZN_mat = np.zeros([4,avgPt_TECnoise_iterations]);
    R_ZvTECZN_mat = np.zeros([4,avgPt_TECnoise_iterations]);
    R_TECMvTECMN_mat = np.zeros([4,avgPt_TECnoise_iterations]);
    R_MvTECMN_mat = np.zeros([4,avgPt_TECnoise_iterations]);
    #compare noises
    TECZNvTECMN_mat = np.zeros([np.int64(512/2+1),avgPt_TECnoise_iterations]);
    R_TECZNvTECMN_mat = np.zeros([4,avgPt_TECnoise_iterations]);
    pointRadiusAngular = (avgPt_pointRadius/Re)*180/np.pi; #get the angular radius to get a small subset of points to deal with
    k = ((avgPt_coords[0,0]-pointRadiusAngular <= data['TEC']['lat']) & (avgPt_coords[0,0]+pointRadiusAngular >= data['TEC']['lat'])) & \
        ((avgPt_coords[0,1]-pointRadiusAngular <= data['TEC']['long']) & (avgPt_coords[0,1]+pointRadiusAngular >= data['TEC']['long'])); #get only east coast to lower calcs needed
    kM = ((avgPt_coords[1,0]-pointRadiusAngular <= data['TEC']['lat']) & (avgPt_coords[1,0]+pointRadiusAngular >= data['TEC']['lat'])) & \
        ((avgPt_coords[1,1]-pointRadiusAngular <= data['TEC']['long']) & (avgPt_coords[1,1]+pointRadiusAngular >= data['TEC']['long'])); #get only east coast to lower calcs needed
    for i in range(0,avgPt_TECnoise_iterations):
        TEC_noise = GRITI_TEC_randomSynth(data['TEC']['lat'][k].size,data['TEC']['lat'][k],data['TEC']['long'][k],data['TEC']['time'][k], \
            noise_background_mean,noise_background_stdev,Re,dateRange_zeroHr, \
            plotLatRange,plotLongRange,plotLatRange_autoTick,plotLongRange_autoTick, \
            wave_latRange,wave_longRange,wave_N,wave_angle,wave_phase,wave_waveLength,wave_period,wave_amp, \
            FONT_titleFM,FONT_axisTick,FONT_axisLabelFM,TEC_plotLimValu,1,FLG_plotStuff=0); #replace the delta-vTEC data with random data 
            
        TEC_noiseM = GRITI_TEC_randomSynth(data['TEC']['lat'][kM].size,data['TEC']['lat'][kM],data['TEC']['long'][kM],data['TEC']['time'][kM], \
            noise_background_mean,noise_background_stdev,Re,dateRange_zeroHr, \
            plotLatRange,plotLongRange,plotLatRange_autoTick,plotLongRange_autoTick, \
            wave_latRange,wave_longRange,wave_N,wave_angle,wave_phase,wave_waveLength,wave_period,wave_amp, \
            FONT_titleFM,FONT_axisTick,FONT_axisLabelFM,TEC_plotLimValu,1,FLG_plotStuff=0); #replace the delta-vTEC data with random data 
        
        avgPt_TECnoise, _, avgPt_TECnoise_time, _, _, _  = \
            GRITI_TEC_avgPt(TEC_timeUnique,data['TEC']['lat'][k],data['TEC']['long'][k],data['TEC']['time'][k],TEC_noise, \
            avgPt_coords[0,:],avgPt_pointRadius,Re,dateRange_dayNum_zeroHr, \
            dataReject,dataRejectOrig,dataRejectLimit,dataRejectLimitOrig,dataRejectMax,FLG_report=0); #average points in a radius
            
        _, avgPt_TECnoise_timeMatch_HP, _ = GRITI_TEC_avgPt_timeMatch(avgPt_TECnoise,avgPt_TECnoise_time,Zenith_time,dateRange_dayNum_zeroHr,filter_cutoffPeriod=filter_cutoffPeriod);

        avgPt_TECnoise_timeMatch_HP_cutOut = avgPt_TECnoise_timeMatch_HP[time_cutout_indexesZ[0]:time_cutout_indexesZ[1]+1];

        avgPt_TECnoise_M, _, avgPt_TECnoise_time_M, _, _, _  = \
            GRITI_TEC_avgPt(TEC_timeUnique,data['TEC']['lat'][kM],data['TEC']['long'][kM],data['TEC']['time'][kM],TEC_noiseM, \
            avgPt_coords[1,:],avgPt_pointRadius,Re,dateRange_dayNum_zeroHr, \
            dataReject,dataRejectOrig,dataRejectLimit,dataRejectLimitOrig,dataRejectMax,FLG_report=0); #average points in a radius
        
        _, avgPt_TECnoise_timeMatch_HP_M, _ = GRITI_TEC_avgPt_timeMatch(avgPt_TECnoise_M,avgPt_TECnoise_time_M,MISA_time,dateRange_dayNum_zeroHr,filter_cutoffPeriod=filter_cutoffPeriod);
        
        avgPt_TECnoise_timeMatch_HP_cutOut_M = avgPt_TECnoise_timeMatch_HP_M[time_cutout_indexesM[0]:time_cutout_indexesM[1]+1];
        
        pwr_TECZN = np.sqrt(1/avgPt_TECnoise_timeMatch_HP_cutOut.size*np.sum(avgPt_TECnoise_timeMatch_HP_cutOut**2)); #estimate power of signal
        pwr_TECMN = np.sqrt(1/avgPt_TECnoise_timeMatch_HP_cutOut_M.size*np.sum(avgPt_TECnoise_timeMatch_HP_cutOut_M**2)); #estimate power of signal
        
        #ZENITH RELATED STUFF
        Fs = 1/(Zenith_time_delta*24*60); #min, zenith time delta in freq form
        #TECZ VS TECZNOISE
        [freqs_TECZvTECZN,Cxy_TECZvTECZN] = signal.csd(1/pwr_TEC_Z*avgPt_vTEC_timeMatch_HP_cutOut,1/pwr_TECZN*avgPt_TECnoise_timeMatch_HP_cutOut,window=window,noverlap=100,nfft=512,fs=Fs);
        Pxy_TECZvTECZN = np.abs(Cxy_TECZvTECZN);
        #Z VS TECZNOISE
        [freqs_ZvTECZN,Cxy_ZvTECZN] = signal.csd(1/pwr_Z*Zenith_POPL_hp_altAvgd_cutOut,1/pwr_TECZN*avgPt_TECnoise_timeMatch_HP_cutOut,window=window,noverlap=100,nfft=512,fs=Fs);
        Pxy_ZvTECZN = np.abs(Cxy_ZvTECZN);
        #MISA RELATED STUFF
        Fs = 1/(MISA_time_delta*24*60); #min, misa time delta in freq form
        #TECM VS TECMNOISE
        [freqs_TECMvTECMN,Cxy_TECMvTECMN] = signal.csd(1/pwr_TEC_M*avgPt_vTEC_timeMatch_HP_cutOut_MISA,1/pwr_TECMN*avgPt_TECnoise_timeMatch_HP_cutOut_M,window=window,noverlap=100,nfft=512,fs=Fs);
        Pxy_TECMvTECMN = np.abs(Cxy_TECMvTECMN);
        #M VS TECMNOISE
        [freqs_MvTECMN,Cxy_MvTECMN] = signal.csd(1/pwr_M*MISA_POPL_hp_altAvgd_cutOut,1/pwr_TECMN*avgPt_TECnoise_timeMatch_HP_cutOut_M,window=window,noverlap=100,nfft=512,fs=Fs);
        Pxy_MvTECMN = np.abs(Cxy_MvTECMN);
        
        #Real quick side move to calc correlation coefficients
        R_TECZvTECZN = np.corrcoef(1/pwr_TEC_Z*avgPt_vTEC_timeMatch_HP_cutOut,1/pwr_TECZN*avgPt_TECnoise_timeMatch_HP_cutOut);
        R_ZvTECZN = np.corrcoef(1/pwr_Z*Zenith_POPL_hp_altAvgd_cutOut,1/pwr_TECZN*avgPt_TECnoise_timeMatch_HP_cutOut);
        R_TECMvTECMN = np.corrcoef(1/pwr_TEC_M*avgPt_vTEC_timeMatch_HP_cutOut_MISA,1/pwr_TECMN*avgPt_TECnoise_timeMatch_HP_cutOut_M);
        R_MvTECMN = np.corrcoef(1/pwr_M*MISA_POPL_hp_altAvgd_cutOut,1/pwr_TECMN*avgPt_TECnoise_timeMatch_HP_cutOut_M);
        
        #compare noises together, need to extrapolate probably
        #TECZNOISE VS TECMNOISE
        [freqs_TECZNvTECMN,Cxy_TECZNvTECMN] = signal.csd(1/pwr_TECZN*avgPt_TECnoise_timeMatch_HP_cutOut,1/pwr_TECMN*avgPt_TECnoise_timeMatch_HP_cutOut_M,window=window,noverlap=100,nfft=512,fs=Fs);
        Pxy_TECZNvTECMN = np.abs(Cxy_TECZNvTECMN);
        R_TECZNvTECMN = np.corrcoef(1/pwr_TECZN*avgPt_TECnoise_timeMatch_HP_cutOut,1/pwr_TECMN*avgPt_TECnoise_timeMatch_HP_cutOut_M);
        
        #RECORD FOR POSTERITY
        TECZvTECZN_mat[:,i] = Pxy_TECZvTECZN;
        TECMvTECMN_mat[:,i] = Pxy_TECMvTECMN;
        ZvTECZN_mat[:,i] = Pxy_ZvTECZN;
        MvTECMN_mat[:,i] = Pxy_MvTECMN;
        R_TECZvTECZN_mat[:,i] = R_TECZvTECZN.flatten();
        R_ZvTECZN_mat[:,i] = R_ZvTECZN.flatten();
        R_TECMvTECMN_mat[:,i] = R_TECMvTECMN.flatten();
        R_MvTECMN_mat[:,i] = R_MvTECMN.flatten();
        #compare noises
        TECZNvTECMN_mat[:,i] = Pxy_TECZNvTECMN;
        R_TECZNvTECMN_mat[:,i] = R_TECZNvTECMN.flatten();
    #END FOR i
    Pxy_TECZvTECZN = np.mean(TECZvTECZN_mat,axis=1);
    Pxy_TECMvTECMN = np.mean(TECMvTECMN_mat,axis=1);
    Pxy_ZvTECZN = np.mean(ZvTECZN_mat,axis=1);
    Pxy_MvTECMN = np.mean(MvTECMN_mat,axis=1);
    #Real quick side move to calc correlation coefficients
    R_TECZvTECZN = np.mean(R_TECZvTECZN_mat,axis=1)[1];
    R_ZvTECZN = np.mean(R_ZvTECZN_mat,axis=1)[1];
    R_TECMvTECMN = np.mean(R_TECMvTECMN_mat,axis=1)[1];
    R_MvTECMN = np.mean(R_MvTECMN_mat,axis=1)[1];
    #compare noises
    Pxy_TECZNvTECMN = np.mean(TECZNvTECMN_mat,axis=1);
    R_TECZNvTECMN = np.mean(R_TECZNvTECMN_mat,axis=1)[1];
    
    #Real quick side move to calc correlation coefficients
    R_TECZvZ = np.corrcoef(1/pwr_TEC_Z*avgPt_vTEC_timeMatch_HP_cutOut,1/pwr_Z*Zenith_POPL_hp_altAvgd_cutOut)[0,1];
    R_TECMvM = np.corrcoef(1/pwr_TEC_M*avgPt_vTEC_timeMatch_HP_cutOut_MISA,1/pwr_M*MISA_POPL_hp_altAvgd_cutOut)[0,1];
    R_ZvM = np.corrcoef(1/pwr_Z*Zenith_POPL_hp_altAvgd_cutOut,1/pwr_M*MISA_POPL_hp_altAvgd_cutOut)[0,1];
    print('TECZvZ: '+str(np.round(R_TECZvZ,3))+' | TECMvM: '+str(np.round(R_TECMvM,3))+' | ZvM: '+str(np.round(R_ZvM,3))+ \
          ' | TECZvTECZN: '+str(np.round(R_TECZvTECZN,3))+'\nZvTECZN: '+str(np.round(R_ZvTECZN,3))+ \
          ' | TECMvTECMN: '+str(np.round(R_TECMvTECMN,3))+' | MvTECMN: '+str(np.round(R_MvTECMN,3))+' |TECZNvTECMN: '+str(np.round(R_TECZNvTECMN,3)));
    
    #----PREP TO PRINT----
    warnings.filterwarnings("ignore", category=RuntimeWarning); #silences warnings about NaNs used in a logical comparisons #yolo
    #Unpack line widths
    PLOT_lineWidthThicc = PLOT_lineWidth['thicc']; #get the line widths
    PLOT_lineWidthDoublePlus = PLOT_lineWidth['double plus']; #get the line widths
    PLOT_lineWidthPlus = PLOT_lineWidth['plus']; #get the line widths
    PLOT_lineWidthRegularPlus = PLOT_lineWidth['regular plus']; #get the line widths
    PLOT_lineWidthRegular = PLOT_lineWidth['regular']; #get the line widths
    PLOT_lineWidthSmol = PLOT_lineWidth['smol']; #get the line widths
    
    plt.ioff() #disable showing the plot as its size will be larger than the screen, which cannot happen if the plot is shown
    fig, ax = plt.subplots(nrows=1, ncols=1,figsize=(14,8.5),dpi=journal_dpi); #use instead of fig because it inits an axis too (I think I dunno)
    #Remove the aspect ratio from the basemap so it fills the screen better
    ax.set_aspect('auto');
    
    #----PLOT THE DATA-----
    p1, = ax.plot(1/freqs_TECvZ,(Pxy_TECvZ),color='xkcd:purple',linewidth=PLOT_lineWidthRegularPlus, linestyle='--',zorder=3);
    p2, = ax.plot(1/freqs_TECvM,(Pxy_TECvM),color='xkcd:goldenrod',linewidth=PLOT_lineWidthRegularPlus, linestyle='-', marker='o',zorder=4);
    p3, = ax.plot(1/freqs_ZvM,(Pxy_ZvM),color='xkcd:cyan',linewidth=PLOT_lineWidthRegularPlus, linestyle='-',zorder=5);
    # p4, = ax.plot(1/freqs_ZvTECZN,(Pxy_ZvTECZN),color='xkcd:forest green',linewidth=PLOT_lineWidthRegularPlus, linestyle='-.',zorder=2);
    # p5, = ax.plot(1/freqs_MvTECMN,(Pxy_MvTECMN),color='xkcd:magenta',linewidth=PLOT_lineWidthRegularPlus, linestyle='-.',zorder=1);
    p6, = ax.plot(1/freqs_TECZNvTECMN,(Pxy_TECZNvTECMN),color='xkcd:magenta',linewidth=PLOT_lineWidthRegularPlus, linestyle='-.',zorder=8);
    # errorMax = np.max([Pxy_TECZvTECZN.max(),Pxy_TECMvTECMN.max(),Pxy_ZvTECZN.max(),Pxy_MvTECMN.max()]);
    errorMax = np.max(Pxy_TECZNvTECMN);
    pLine = ax.hlines(errorMax,np.min(1/freqs_TECvZ),plot_periodLim_max,color='xkcd:fire engine red',linewidth=PLOT_lineWidthDoublePlus, linestyle='-.',zorder=6);
    ax.set_xlabel('Periods [min]',fontproperties=FONT_axisLabelFM);
    ax.set_ylabel('Arb. Power',fontproperties=FONT_axisLabelFM);
    # ax.set_title('Cross-Spectral Density - Noise '+str(avgPt_TECnoise_iterations)+' Iteration Average Time Limited to '+str(str(np.round(time_cutout_range[0]/3600,2)).rstrip('0').rstrip('.'))+' to '+str(str(np.round(time_cutout_range[-1]/3600,2)).rstrip('0').rstrip('.'))+' hrs w/ OMNI time delayed by'+str(time_cutout_range_delay)+' hrs on Day '+str(dateRange_dayNum_zeroHr[1])+', '+str(dateRange_dayNum_zeroHr[0]), \
    #     fontproperties=FONT_titleFM);
    ax.legend([p1,p2,p3,p6,pLine],
        # ['Point TEC AVG''d to Zenith Times & HP vs Zenith HP AVG''d '+str(pointAltitude)+' km +/-'+str(avgPt_ISRavgAlt)+' km', \
        # 'Point TEC AVG''d to MISA Times & HP vs MISA HP AVG''d '+str(pointAltitude)+' km +/-'+str(avgPt_ISRavgAlt)+' km', \
        # 'Zenith & MISA HP AVG''d to '+str(pointAltitude)+' km +/-'+str(avgPt_ISRavgAlt)+' km',\
        # 'OMNI '+OMNI_plot_label+' AVG''d to Zenith Times & HP (Time Delayed '+str(time_cutout_range_delay)+' hrs) vs Zenith HP AVG''d '+str(pointAltitude)+' km +/-'+str(avgPt_ISRavgAlt)+' km', \
        # 'OMNI '+OMNI_plot_label+' AVG''d to MISA Times & HP (Time Delayed '+str(time_cutout_range_delay)+' hrs) vs MISA HP AVG''d '+str(pointAltitude)+' km +/-'+str(avgPt_ISRavgAlt)+' km', \
        # 'OMNI '+OMNI_plot_label+' AVG''d to Zenith Times & HP (Time Delayed '+str(time_cutout_range_delay)+' hrs) vs Point TEC AVG''d to Zenith Times & HP', \
        # 'OMNI '+OMNI_plot_label+' AVG''d to MISA Times & HP (Time Delayed '+str(time_cutout_range_delay)+' hrs) vs Point TEC AVG''d to MISA Times & HP', \
        ['Delta-vTEC at Zenith & Zenith N$_{e^-}$', \
        'Delta-vTEC at MISA & MISA N$_{e^-}$', \
        'Zenith N$_e$ & MISA N$_{e^-}$', \
        # 'Noise delta-vTEC at Zenith & Zenith N$_e$',\
        # 'Noise delta-vTEC at MISA & MISA N$_e$', \
        'Noise delta-vTEC at Zenith &\n Noise delta-vTEC at MISA', \
        'Effective noise floor'], \
        loc='upper left', prop=FONT_axisLabelFM);
    
    xAxisTicks = np.arange( 0, plot_periodLim_max+10, 10); #sets the start hr, stop hr, and the step size between (in this case, 2 hr)
    ax.set_xticks(xAxisTicks); #set x axis ticks
    ax.set_xlim( (0, plot_periodLim_max) )
    ax.spines['right'].set_visible(False); #turn off box lines
    ax.spines['top'].set_visible(False); #turn off box lines
    #final plot adjusting stuff
    fig.subplots_adjust(left = 0.075, right = 0.977, top = 0.990, bottom = 0.085); #sets padding to small numbers for minimal white space
    #fig.tight_layout(); #function for a tight layout, doesn't seem to do much here
    fig.savefig(folder[3]+'\\avgPt_HP_timeMatch&POPL&TECNOISE_CPSD_cutOut.png'); #save the figure
    plt.close(); #close figure b/c it lurks apparently
    plt.ion(); #re-enable it for later stuff
    warnings.filterwarnings("default", category=RuntimeWarning); #silences warnings about NaNs used in a logical comparisons #yolo
#END IF

if( (FLG_avgPt_HP_timeMatch_POPLnTECNOISE_FFT_cutOut == 1) & (FLG_fancyPlot == 1) ):
    print('MAKING FANCY PLOT: TEC_avgPt_HP_timeMatch_POPLnTECNOISE_FFT_cutOut IN fancyPlot FOLDER'); #report since you won't see anything
    from mpl_toolkits.axes_grid1 import make_axes_locatable
    if( FLG_TEC_noise >= 1 ):
        print('***ERROR***: FLG_TEC_noise is '+str(FLG_TEC_noise)+' which means that the TEC comparisons are meaningless (the TEC data has been replaced with noise). Fix that and re-run for this plot to be useful!'); #report issue
        sys.exit();
    #END IF
    Zenith_time_delta = np.median(np.diff(Zenith_time)); #days, delta of time between readings
    MISA_time_delta = np.median(np.diff(MISA_time)); #days, delta of time between readings
    
    #ZENITH NOW
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (avgPt_vTEC_timeMatch_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (avgPt_vTEC_timeMatch_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , \
        np.where(np.min(np.abs( (avgPt_vTEC_timeMatch_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (avgPt_vTEC_timeMatch_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range
    
    avgPt_vTEC_timeMatch_HP_cutOut = avgPt_vTEC_timeMatch_HP[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    avgPt_vTEC_timeMatch_time_cutOut = avgPt_vTEC_timeMatch_time[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    
    time_cutout_indexesZ = np.array( ( np.where(np.min(np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , \
        np.where(np.min(np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range
    
    Zenith_time_cutOut = Zenith_time[time_cutout_indexesZ[0]:time_cutout_indexesZ[1]+1];
    Zenith_POPL_hp_cutOut = Zenith_POPL_hp[:,time_cutout_indexesZ[0]:time_cutout_indexesZ[1]+1];
    Zenith_POPL_hp_altAvgd_cutOut = Zenith_POPL_hp_altAvgd[time_cutout_indexesZ[0]:time_cutout_indexesZ[1]+1];
    
    #MISA NOW
    time_cutout_indexesM = np.array( ( np.where(np.min(np.abs( (avgPt_vTEC_timeMatch_time_MISA-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (avgPt_vTEC_timeMatch_time_MISA-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , \
        np.where(np.min(np.abs( (avgPt_vTEC_timeMatch_time_MISA-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (avgPt_vTEC_timeMatch_time_MISA-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range
    
    avgPt_vTEC_timeMatch_HP_cutOut_MISA = avgPt_vTEC_timeMatch_HP_MISA[time_cutout_indexesM[0]:time_cutout_indexesM[1]+1];
    avgPt_vTEC_timeMatch_time_cutOut_MISA = avgPt_vTEC_timeMatch_time_MISA[time_cutout_indexesM[0]:time_cutout_indexesM[1]+1];
            
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , 
        np.where(np.min(np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range
                             
    MISA_time_cutOut = MISA_time[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    MISA_POPL_hp_cutOut = MISA_POPL_hp[:,time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    MISA_POPL_hp_altAvgd_cutOut = MISA_POPL_hp_altAvgd[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    
    from scipy import signal
#    from matplotlib import mlab
    window = np.hamming(110);
#    window= np.pad(window,(0,512-110),mode='constant')
    Fs = 1/(Zenith_time_delta*24*60); #min, zenith time delta in freq form
    
    pwr_TEC_Z = np.sqrt(1/avgPt_vTEC_timeMatch_HP_cutOut.size*np.sum(avgPt_vTEC_timeMatch_HP_cutOut**2)); #estimate power of signal
    pwr_TEC_M = np.sqrt(1/avgPt_vTEC_timeMatch_HP_cutOut_MISA.size*np.sum(avgPt_vTEC_timeMatch_HP_cutOut_MISA**2)); #estimate power of signal
    pwr_Z = np.sqrt(1/Zenith_POPL_hp_altAvgd_cutOut.size*np.sum(Zenith_POPL_hp_altAvgd_cutOut**2)); #estimate power of signal
    pwr_M = np.sqrt(1/MISA_POPL_hp_altAvgd_cutOut.size*np.sum(MISA_POPL_hp_altAvgd_cutOut**2)); #estimate power of signal
    
    #ZENITH STUFF
    Fs = 1/(Zenith_time_delta*24*60); #min, zenith time delta in freq form
    [freqs_TECZ,Cxx_TECZ] = signal.welch(1/pwr_TEC_Z*avgPt_vTEC_timeMatch_HP_cutOut ,window=window,noverlap=100,nfft=512,fs=Fs);
    [freqs_Z,Cxx_Z] = signal.welch(1/pwr_Z*Zenith_POPL_hp_altAvgd_cutOut ,window=window,noverlap=100,nfft=512,fs=Fs);
    
    #MISA STUFF
    Fs = 1/(MISA_time_delta*24*60); #min, misa time delta in freq form
    [freqs_TECM,Cxx_TECM] = signal.welch(1/pwr_TEC_M*avgPt_vTEC_timeMatch_HP_cutOut_MISA ,window=window,noverlap=100,nfft=512,fs=Fs);
    [freqs_M,Cxx_M] = signal.welch(1/pwr_M*MISA_POPL_hp_altAvgd_cutOut ,window=window,noverlap=100,nfft=512,fs=Fs);
    
    #now, noise comparisons
    TECZN_mat = np.zeros([np.int64(512/2+1),avgPt_TECnoise_iterations]);
    TECMN_mat = np.zeros([np.int64(512/2+1),avgPt_TECnoise_iterations]);
    pointRadiusAngular = (avgPt_pointRadius/Re)*180/np.pi; #get the angular radius to get a small subset of points to deal with
    k = ((avgPt_coords[0,0]-pointRadiusAngular <= data['TEC']['lat']) & (avgPt_coords[0,0]+pointRadiusAngular >= data['TEC']['lat'])) & \
        ((avgPt_coords[0,1]-pointRadiusAngular <= data['TEC']['long']) & (avgPt_coords[0,1]+pointRadiusAngular >= data['TEC']['long'])); #get only east coast to lower calcs needed
    kM = ((avgPt_coords[1,0]-pointRadiusAngular <= data['TEC']['lat']) & (avgPt_coords[1,0]+pointRadiusAngular >= data['TEC']['lat'])) & \
        ((avgPt_coords[1,1]-pointRadiusAngular <= data['TEC']['long']) & (avgPt_coords[1,1]+pointRadiusAngular >= data['TEC']['long'])); #get only east coast to lower calcs needed
    for i in range(0,avgPt_TECnoise_iterations):
        TEC_noise = GRITI_TEC_randomSynth(data['TEC']['lat'][k].size,data['TEC']['lat'][k],data['TEC']['long'][k],data['TEC']['time'][k], \
            noise_background_mean,noise_background_stdev,Re,dateRange_zeroHr, \
            plotLatRange,plotLongRange,plotLatRange_autoTick,plotLongRange_autoTick, \
            wave_latRange,wave_longRange,wave_N,wave_angle,wave_phase,wave_waveLength,wave_period,wave_amp, \
            FONT_titleFM,FONT_axisTick,FONT_axisLabelFM,TEC_plotLimValu,1,FLG_plotStuff=0); #replace the delta-vTEC data with random data 
        
        TEC_noiseM = GRITI_TEC_randomSynth(data['TEC']['lat'][kM].size,data['TEC']['lat'][kM],data['TEC']['long'][kM],data['TEC']['time'][kM], \
            noise_background_mean,noise_background_stdev,Re,dateRange_zeroHr, \
            plotLatRange,plotLongRange,plotLatRange_autoTick,plotLongRange_autoTick, \
            wave_latRange,wave_longRange,wave_N,wave_angle,wave_phase,wave_waveLength,wave_period,wave_amp, \
            FONT_titleFM,FONT_axisTick,FONT_axisLabelFM,TEC_plotLimValu,1,FLG_plotStuff=0); #replace the delta-vTEC data with random data 
        
        avgPt_TECnoise, _, avgPt_TECnoise_time, _, _, _  = \
            GRITI_TEC_avgPt(TEC_timeUnique,data['TEC']['lat'][k],data['TEC']['long'][k],data['TEC']['time'][k],TEC_noise, \
            avgPt_coords[0,:],avgPt_pointRadius,Re,dateRange_dayNum_zeroHr, \
            dataReject,dataRejectOrig,dataRejectLimit,dataRejectLimitOrig,dataRejectMax,FLG_report=0); #average points in a radius
            
        _, avgPt_TECnoise_timeMatch_HP, _ = GRITI_TEC_avgPt_timeMatch(avgPt_TECnoise,avgPt_TECnoise_time,Zenith_time,dateRange_dayNum_zeroHr,filter_cutoffPeriod=filter_cutoffPeriod);

        avgPt_TECnoise_timeMatch_HP_cutOut = avgPt_TECnoise_timeMatch_HP[time_cutout_indexesZ[0]:time_cutout_indexesZ[1]+1];

        avgPt_TECnoise_M, _, avgPt_TECnoise_time_M, _, _, _  = \
            GRITI_TEC_avgPt(TEC_timeUnique,data['TEC']['lat'][kM],data['TEC']['long'][kM],data['TEC']['time'][kM],TEC_noiseM, \
            avgPt_coords[1,:],avgPt_pointRadius,Re,dateRange_dayNum_zeroHr, \
            dataReject,dataRejectOrig,dataRejectLimit,dataRejectLimitOrig,dataRejectMax,FLG_report=0); #average points in a radius
        
        _, avgPt_TECnoise_timeMatch_HP_M, _ = GRITI_TEC_avgPt_timeMatch(avgPt_TECnoise_M,avgPt_TECnoise_time_M,MISA_time,dateRange_dayNum_zeroHr,filter_cutoffPeriod=filter_cutoffPeriod);
        
        avgPt_TECnoise_timeMatch_HP_cutOut_M = avgPt_TECnoise_timeMatch_HP_M[time_cutout_indexesM[0]:time_cutout_indexesM[1]+1];
        
        pwr_TECZN = np.sqrt(1/avgPt_TECnoise_timeMatch_HP_cutOut.size*np.sum(avgPt_TECnoise_timeMatch_HP_cutOut**2)); #estimate power of signal
        pwr_TECMN = np.sqrt(1/avgPt_TECnoise_timeMatch_HP_cutOut_M.size*np.sum(avgPt_TECnoise_timeMatch_HP_cutOut_M**2)); #estimate power of signal
        
        #ZENITH RELATED STUFF
        Fs = 1/(Zenith_time_delta*24*60); #min, zenith time delta in freq form
        #TECZNOISE
        [freqs_TECZN,Cxx_TECZN] = signal.welch(1/pwr_TECZN*avgPt_TECnoise_timeMatch_HP_cutOut ,window=window,noverlap=100,nfft=512,fs=Fs);
        #MISA RELATED STUFF
        Fs = 1/(MISA_time_delta*24*60); #min, misa time delta in freq form
        #TECMNOISE
        [freqs_TECMN,Cxx_TECMN] = signal.welch(1/pwr_TECMN*avgPt_TECnoise_timeMatch_HP_cutOut_M ,window=window,noverlap=100,nfft=512,fs=Fs);
        
        #RECORD FOR POSTERITY
        TECZN_mat[:,i] = Cxx_TECZN;
        TECMN_mat[:,i] = Cxx_TECMN;
    #END FOR i
    Cxx_TECZN = np.mean(TECZN_mat,axis=1);
    Cxx_TECMN = np.mean(TECMN_mat,axis=1);
    
    #----PREP TO PRINT----
    warnings.filterwarnings("ignore", category=RuntimeWarning); #silences warnings about NaNs used in a logical comparisons #yolo
    #Unpack line widths
    PLOT_lineWidthThicc = PLOT_lineWidth['thicc']; #get the line widths
    PLOT_lineWidthDoublePlus = PLOT_lineWidth['double plus']; #get the line widths
    PLOT_lineWidthPlus = PLOT_lineWidth['plus']; #get the line widths
    PLOT_lineWidthRegularPlus = PLOT_lineWidth['regular plus']; #get the line widths
    PLOT_lineWidthRegular = PLOT_lineWidth['regular']; #get the line widths
    PLOT_lineWidthSmol = PLOT_lineWidth['smol']; #get the line widths
    
    plt.ioff() #disable showing the plot as its size will be larger than the screen, which cannot happen if the plot is shown
    fig, ax = plt.subplots(nrows=1, ncols=1,figsize=(14,8.5),dpi=journal_dpi); #use instead of fig because it inits an axis too (I think I dunno)
    #Remove the aspect ratio from the basemap so it fills the screen better
    ax.set_aspect('auto');
    
    #----PLOT THE DATA-----
    p1, = ax.plot(1/freqs_TECZ,(Cxx_TECZ),color='xkcd:red',linewidth=PLOT_lineWidthRegularPlus, linestyle='-', marker='o');
    p2, = ax.plot(1/freqs_TECM,(Cxx_TECM),color='xkcd:periwinkle',linewidth=PLOT_lineWidthRegularPlus, linestyle='-');
    p3, = ax.plot(1/freqs_Z,(Cxx_Z),color='xkcd:electric blue',linewidth=PLOT_lineWidthRegularPlus, linestyle='--');
    p4, = ax.plot(1/freqs_M,(Cxx_M),color='xkcd:neon green',linewidth=PLOT_lineWidthRegularPlus, linestyle='-.');
    p5, = ax.plot(1/freqs_TECZN,(Cxx_TECZN),color='xkcd:salmon',linewidth=PLOT_lineWidthRegularPlus, linestyle=':');
    p6, = ax.plot(1/freqs_TECMN,(Cxx_TECMN),color='xkcd:mauve',linewidth=PLOT_lineWidthRegularPlus, linestyle=':');
    errorMax = np.max([Cxx_TECZN.max(),Cxx_TECMN.max()]);
    pLine = ax.hlines(errorMax,np.min(1/freqs_TECZ),plot_periodLim_max,color='xkcd:fire engine red',linewidth=PLOT_lineWidthDoublePlus, linestyle='-.');
    ax.set_xlabel('Periods [min]',fontproperties=FONT_axisLabelFM);
    ax.set_ylabel('Arb. Power',fontproperties=FONT_axisLabelFM);
    # ax.set_title('Power Spectra - Noise '+str(avgPt_TECnoise_iterations)+' Iteration Average Time Limited to '+str(str(np.round(time_cutout_range[0]/3600,2)).rstrip('0').rstrip('.'))+' to '+str(str(np.round(time_cutout_range[-1]/3600,2)).rstrip('0').rstrip('.'))+' hrs at Millstone '+str(np.round(latMillstone,2))+' degc lat/'+str(np.round(longMillstone,2))+' deg long on Day '+str(dateRange_dayNum_zeroHr[1])+', '+str(dateRange_dayNum_zeroHr[0]), \
    #     fontproperties=FONT_titleFM);
    # ax.set_title('Cross-Spectral Density - Noise '+str(avgPt_TECnoise_iterations)+' Iteration Average Time Limited to '+str(str(np.round(time_cutout_range[0]/3600,2)).rstrip('0').rstrip('.'))+' to '+str(str(np.round(time_cutout_range[-1]/3600,2)).rstrip('0').rstrip('.'))+' hrs w/ OMNI time delayed by'+str(time_cutout_range_delay)+' hrs on Day '+str(dateRange_dayNum_zeroHr[1])+', '+str(dateRange_dayNum_zeroHr[0]), \
    #     fontproperties=FONT_titleFM);
    ax.legend([p1,p2,p3,p4,p5,p6,pLine],
        # ['Point TEC AVG''d to Zenith Times & HP vs Zenith HP AVG''d '+str(pointAltitude)+' km +/-'+str(avgPt_ISRavgAlt)+' km', \
        # 'Point TEC AVG''d to MISA Times & HP vs MISA HP AVG''d '+str(pointAltitude)+' km +/-'+str(avgPt_ISRavgAlt)+' km', \
        # 'Zenith & MISA HP AVG''d to '+str(pointAltitude)+' km +/-'+str(avgPt_ISRavgAlt)+' km',\
        # 'OMNI '+OMNI_plot_label+' AVG''d to Zenith Times & HP (Time Delayed '+str(time_cutout_range_delay)+' hrs) vs Zenith HP AVG''d '+str(pointAltitude)+' km +/-'+str(avgPt_ISRavgAlt)+' km', \
        # 'OMNI '+OMNI_plot_label+' AVG''d to MISA Times & HP (Time Delayed '+str(time_cutout_range_delay)+' hrs) vs MISA HP AVG''d '+str(pointAltitude)+' km +/-'+str(avgPt_ISRavgAlt)+' km', \
        # 'OMNI '+OMNI_plot_label+' AVG''d to Zenith Times & HP (Time Delayed '+str(time_cutout_range_delay)+' hrs) vs Point TEC AVG''d to Zenith Times & HP', \
        # 'OMNI '+OMNI_plot_label+' AVG''d to MISA Times & HP (Time Delayed '+str(time_cutout_range_delay)+' hrs) vs Point TEC AVG''d to MISA Times & HP', \
        ['Delta-vTEC at Zenith', \
        'Delta-vTEC at MISA', \
        'Zenith N$_e$', \
        'MISA N$_e$', \
        'Noise delta-vTEC at Zenith',\
        'Noise delta-vTEC at MISA', \
        'Effective noise floor'], \
        loc='upper left', prop=FONT_axisLabelFM);
    
    xAxisTicks = np.arange( 0, plot_periodLim_max+10, 10); #sets the start hr, stop hr, and the step size between (in this case, 2 hr)
    ax.set_xticks(xAxisTicks); #set x axis ticks
    ax.set_xlim( (0, plot_periodLim_max) )
    ax.spines['right'].set_visible(False); #turn off box lines
    ax.spines['top'].set_visible(False); #turn off box lines
    #final plot adjusting stuff
    fig.subplots_adjust(left = 0.075, right = 0.977, top = 0.990, bottom = 0.085); #sets padding to small numbers for minimal white space
    #fig.tight_layout(); #function for a tight layout, doesn't seem to do much here
    fig.savefig(folder[3]+'\\avgPt_HP_timeMatch&POPL&TECNOISE_FFT_cutOut.png'); #save the figure
    plt.close(); #close figure b/c it lurks apparently
    plt.ion(); #re-enable it for later stuff
    warnings.filterwarnings("default", category=RuntimeWarning); #silences warnings about NaNs used in a logical comparisons #yolo
#END IF
    
if( FLG_avgPt_HP_timeMatch_POPLnOMNInTECNOISE_FFT_cutOut == 1 ):
    if( FLG_TEC_noise >= 1 ):
        print('***WARNING***: FLG_TEC_noise is '+str(FLG_TEC_noise)+' which means that the TEC comparisons are meaningless (the TEC data has been replaced with noise). Fix that and re-run for this plot to be useful!'); #report issue
    #END IF
    #Unpack line widths
    PLOT_lineWidthThicc = PLOT_lineWidth['thicc']; #get the line widths
    PLOT_lineWidthDoublePlus = PLOT_lineWidth['double plus']; #get the line widths
    PLOT_lineWidthPlus = PLOT_lineWidth['plus']; #get the line widths
    PLOT_lineWidthRegularPlus = PLOT_lineWidth['regular plus']; #get the line widths
    PLOT_lineWidthRegular = PLOT_lineWidth['regular']; #get the line widths
    PLOT_lineWidthSmol = PLOT_lineWidth['smol']; #get the line widths
    
    Zenith_time_delta = np.median(np.diff(Zenith_time)); #days, delta of time between readings
    MISA_time_delta = np.median(np.diff(MISA_time)); #days, delta of time between readings
    
    #ZENITH NOW
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (avgPt_vTEC_timeMatch_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (avgPt_vTEC_timeMatch_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , \
        np.where(np.min(np.abs( (avgPt_vTEC_timeMatch_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (avgPt_vTEC_timeMatch_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range
    
    avgPt_vTEC_timeMatch_HP_cutOut = avgPt_vTEC_timeMatch_HP[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    avgPt_vTEC_timeMatch_time_cutOut = avgPt_vTEC_timeMatch_time[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    
    time_cutout_indexesZ = np.array( ( np.where(np.min(np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , \
        np.where(np.min(np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range
    
    Zenith_time_cutOut = Zenith_time[time_cutout_indexesZ[0]:time_cutout_indexesZ[1]+1];
    Zenith_POPL_hp_cutOut = Zenith_POPL_hp[:,time_cutout_indexesZ[0]:time_cutout_indexesZ[1]+1];
    Zenith_POPL_hp_altAvgd_cutOut = Zenith_POPL_hp_altAvgd[time_cutout_indexesZ[0]:time_cutout_indexesZ[1]+1];
    
    #MISA NOW
    time_cutout_indexesM = np.array( ( np.where(np.min(np.abs( (avgPt_vTEC_timeMatch_time_MISA-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (avgPt_vTEC_timeMatch_time_MISA-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , \
        np.where(np.min(np.abs( (avgPt_vTEC_timeMatch_time_MISA-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (avgPt_vTEC_timeMatch_time_MISA-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range
    
    avgPt_vTEC_timeMatch_HP_cutOut_MISA = avgPt_vTEC_timeMatch_HP_MISA[time_cutout_indexesM[0]:time_cutout_indexesM[1]+1];
    avgPt_vTEC_timeMatch_time_cutOut_MISA = avgPt_vTEC_timeMatch_time_MISA[time_cutout_indexesM[0]:time_cutout_indexesM[1]+1];
            
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , 
        np.where(np.min(np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range
                             
    MISA_time_cutOut = MISA_time[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    MISA_POPL_hp_cutOut = MISA_POPL_hp[:,time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    MISA_POPL_hp_altAvgd_cutOut = MISA_POPL_hp_altAvgd[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    
    #OMNI plot prep
    OMNI_plot_label = OMNI_dictPlot[OMNI_dict[OMNI_plot_name]]; #get the label
    OMNI_plot_labelNoUnits = OMNI_plot_label[0:OMNI_plot_label.find('[')-1]; #remove the (units)
    
    #ZENITH NOW
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (OMNI_data_timeMatch_time_Zenith-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range_delayed_OMNI) )) == np.abs( (OMNI_data_timeMatch_time_Zenith-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range_delayed_OMNI) ) )[0][0] , \
        np.where(np.min(np.abs( (OMNI_data_timeMatch_time_Zenith-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range_delayed_OMNI) )) == np.abs( (OMNI_data_timeMatch_time_Zenith-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range_delayed_OMNI) ) )[0][0] ) ); #get the indexes for that time cutout range
    
    OMNI_data_timeMatch_HP_Zenith_cutOut = OMNI_data_timeMatch_HP_Zenith[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    OMNI_data_timeMatch_time_Zenith_cutOut = OMNI_data_timeMatch_time_Zenith[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    
    #MISA NOW
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (OMNI_data_timeMatch_time_MISA-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range_delayed_OMNI) )) == np.abs( (OMNI_data_timeMatch_time_MISA-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range_delayed_OMNI) ) )[0][0] , \
        np.where(np.min(np.abs( (OMNI_data_timeMatch_time_MISA-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range_delayed_OMNI) )) == np.abs( (OMNI_data_timeMatch_time_MISA-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range_delayed_OMNI) ) )[0][0] ) ); #get the indexes for that time cutout range
    
    OMNI_data_timeMatch_HP_MISA_cutOut = OMNI_data_timeMatch_HP_MISA[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    OMNI_data_timeMatch_time_MISA_cutOut = OMNI_data_timeMatch_time_MISA[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    
    from scipy import signal
#    from matplotlib import mlab
    window = np.hamming(110);
#    window= np.pad(window,(0,512-110),mode='constant')
    
    pwr_TEC_Z = np.sqrt(1/avgPt_vTEC_timeMatch_HP_cutOut.size*np.sum(avgPt_vTEC_timeMatch_HP_cutOut**2)); #estimate power of signal
    pwr_TEC_M = np.sqrt(1/avgPt_vTEC_timeMatch_HP_cutOut_MISA.size*np.sum(avgPt_vTEC_timeMatch_HP_cutOut_MISA**2)); #estimate power of signal
    pwr_Z = np.sqrt(1/Zenith_POPL_hp_altAvgd_cutOut.size*np.sum(Zenith_POPL_hp_altAvgd_cutOut**2)); #estimate power of signal
    pwr_M = np.sqrt(1/MISA_POPL_hp_altAvgd_cutOut.size*np.sum(MISA_POPL_hp_altAvgd_cutOut**2)); #estimate power of signal
    pwr_OMNI_Z = np.sqrt(1/OMNI_data_timeMatch_HP_Zenith_cutOut.size*np.sum(OMNI_data_timeMatch_HP_Zenith_cutOut**2)); #estimate power of signal
    pwr_OMNI_M = np.sqrt(1/OMNI_data_timeMatch_HP_MISA_cutOut.size*np.sum(OMNI_data_timeMatch_HP_MISA_cutOut**2)); #estimate power of signal
    
    #ZENITH STUFF
    Fs = 1/(Zenith_time_delta*24*60); #min, zenith time delta in freq form
    [freqs_TECZ,Cxx_TECZ] = signal.welch(1/pwr_TEC_Z*avgPt_vTEC_timeMatch_HP_cutOut ,window=window,noverlap=100,nfft=512,fs=Fs);
    [freqs_Z,Cxx_Z] = signal.welch(1/pwr_Z*Zenith_POPL_hp_altAvgd_cutOut ,window=window,noverlap=100,nfft=512,fs=Fs);
    [freqs_OMNIZ,Cxx_OMNIZ] = signal.welch(1/pwr_OMNI_Z*OMNI_data_timeMatch_HP_Zenith_cutOut ,window=window,noverlap=100,nfft=512,fs=Fs);
    
    #MISA STUFF
    Fs = 1/(MISA_time_delta*24*60); #min, misa time delta in freq form
    [freqs_TECM,Cxx_TECM] = signal.welch(1/pwr_TEC_M*avgPt_vTEC_timeMatch_HP_cutOut_MISA ,window=window,noverlap=100,nfft=512,fs=Fs);
    [freqs_M,Cxx_M] = signal.welch(1/pwr_M*MISA_POPL_hp_altAvgd_cutOut ,window=window,noverlap=100,nfft=512,fs=Fs);
    [freqs_OMNIM,Cxx_OMNIM] = signal.welch(1/pwr_OMNI_M*OMNI_data_timeMatch_HP_MISA_cutOut ,window=window,noverlap=100,nfft=512,fs=Fs);

    #now, noise comparisons
    TECZN_mat = np.zeros([np.int64(512/2+1),avgPt_TECnoise_iterations]);
    TECMN_mat = np.zeros([np.int64(512/2+1),avgPt_TECnoise_iterations]);
    pointRadiusAngular = (avgPt_pointRadius/Re)*180/np.pi; #get the angular radius to get a small subset of points to deal with
    k = ((avgPt_coords[0,0]-pointRadiusAngular <= data['TEC']['lat']) & (avgPt_coords[0,0]+pointRadiusAngular >= data['TEC']['lat'])) & \
        ((avgPt_coords[0,1]-pointRadiusAngular <= data['TEC']['long']) & (avgPt_coords[0,1]+pointRadiusAngular >= data['TEC']['long'])); #get only east coast to lower calcs needed
    kM = ((avgPt_coords[1,0]-pointRadiusAngular <= data['TEC']['lat']) & (avgPt_coords[1,0]+pointRadiusAngular >= data['TEC']['lat'])) & \
        ((avgPt_coords[1,1]-pointRadiusAngular <= data['TEC']['long']) & (avgPt_coords[1,1]+pointRadiusAngular >= data['TEC']['long'])); #get only east coast to lower calcs needed
    for i in range(0,avgPt_TECnoise_iterations):
        TEC_noise = GRITI_TEC_randomSynth(data['TEC']['lat'][k].size,data['TEC']['lat'][k],data['TEC']['long'][k],data['TEC']['time'][k], \
            noise_background_mean,noise_background_stdev,Re,dateRange_zeroHr, \
            plotLatRange,plotLongRange,plotLatRange_autoTick,plotLongRange_autoTick, \
            wave_latRange,wave_longRange,wave_N,wave_angle,wave_phase,wave_waveLength,wave_period,wave_amp, \
            FONT_titleFM,FONT_axisTick,FONT_axisLabelFM,TEC_plotLimValu,1,FLG_plotStuff=0); #replace the delta-vTEC data with random data 
            
        TEC_noiseM = GRITI_TEC_randomSynth(data['TEC']['lat'][kM].size,data['TEC']['lat'][kM],data['TEC']['long'][kM],data['TEC']['time'][kM], \
            noise_background_mean,noise_background_stdev,Re,dateRange_zeroHr, \
            plotLatRange,plotLongRange,plotLatRange_autoTick,plotLongRange_autoTick, \
            wave_latRange,wave_longRange,wave_N,wave_angle,wave_phase,wave_waveLength,wave_period,wave_amp, \
            FONT_titleFM,FONT_axisTick,FONT_axisLabelFM,TEC_plotLimValu,1,FLG_plotStuff=0); #replace the delta-vTEC data with random data 
        
        avgPt_TECnoise, _, avgPt_TECnoise_time, _, _, _  = \
            GRITI_TEC_avgPt(TEC_timeUnique,data['TEC']['lat'][k],data['TEC']['long'][k],data['TEC']['time'][k],TEC_noise, \
            avgPt_coords[0,:],avgPt_pointRadius,Re,dateRange_dayNum_zeroHr, \
            dataReject,dataRejectOrig,dataRejectLimit,dataRejectLimitOrig,dataRejectMax,FLG_report=0); #average points in a radius
            
        _, avgPt_TECnoise_timeMatch_HP, _ = GRITI_TEC_avgPt_timeMatch(avgPt_TECnoise,avgPt_TECnoise_time,Zenith_time,dateRange_dayNum_zeroHr,filter_cutoffPeriod=filter_cutoffPeriod);

        avgPt_TECnoise_timeMatch_HP_cutOut = avgPt_TECnoise_timeMatch_HP[time_cutout_indexesZ[0]:time_cutout_indexesZ[1]+1];

        avgPt_TECnoise_M, _, avgPt_TECnoise_time_M, _, _, _  = \
            GRITI_TEC_avgPt(TEC_timeUnique,data['TEC']['lat'][kM],data['TEC']['long'][kM],data['TEC']['time'][kM],TEC_noiseM, \
            avgPt_coords[1,:],avgPt_pointRadius,Re,dateRange_dayNum_zeroHr, \
            dataReject,dataRejectOrig,dataRejectLimit,dataRejectLimitOrig,dataRejectMax,FLG_report=0); #average points in a radius
        
        _, avgPt_TECnoise_timeMatch_HP_M, _ = GRITI_TEC_avgPt_timeMatch(avgPt_TECnoise_M,avgPt_TECnoise_time_M,MISA_time,dateRange_dayNum_zeroHr,filter_cutoffPeriod=filter_cutoffPeriod);
        
        avgPt_TECnoise_timeMatch_HP_cutOut_M = avgPt_TECnoise_timeMatch_HP_M[time_cutout_indexesM[0]:time_cutout_indexesM[1]+1];
        
        pwr_TECZN = np.sqrt(1/avgPt_TECnoise_timeMatch_HP_cutOut.size*np.sum(avgPt_TECnoise_timeMatch_HP_cutOut**2)); #estimate power of signal
        pwr_TECMN = np.sqrt(1/avgPt_TECnoise_timeMatch_HP_cutOut_M.size*np.sum(avgPt_TECnoise_timeMatch_HP_cutOut_M**2)); #estimate power of signal
        
        #ZENITH RELATED STUFF
        Fs = 1/(Zenith_time_delta*24*60); #min, zenith time delta in freq form
        #TECZNOISE
        [freqs_TECZN,Cxx_TECZN] = signal.welch(1/pwr_TECZN*avgPt_TECnoise_timeMatch_HP_cutOut ,window=window,noverlap=100,nfft=512,fs=Fs);
        #MISA RELATED STUFF
        Fs = 1/(MISA_time_delta*24*60); #min, misa time delta in freq form
        #TECMNOISE
        [freqs_TECMN,Cxx_TECMN] = signal.welch(1/pwr_TECMN*avgPt_TECnoise_timeMatch_HP_cutOut_M ,window=window,noverlap=100,nfft=512,fs=Fs);
        
        #RECORD FOR POSTERITY
        TECZN_mat[:,i] = Cxx_TECZN;
        TECMN_mat[:,i] = Cxx_TECMN;
    #END FOR i
    Cxx_TECZN = np.mean(TECZN_mat,axis=1);
    Cxx_TECMN = np.mean(TECMN_mat,axis=1);
    
    warnings.filterwarnings("ignore", category=RuntimeWarning); #silences warnings about NaNs used in a logical comparisons #yolo
    fig, ax = plt.subplots(nrows=1, ncols=1); #use instead of fig because it inits an axis too (I think I dunno)
    figManager = plt.get_current_fig_manager(); #req to maximize
    figManager.window.showMaximized(); #force maximized
    #Remove the aspect ratio from the basemap so it fills the screen better
    ax.set_aspect('auto');
    
    p1, = ax.plot(1/freqs_TECZ,(Cxx_TECZ),color='xkcd:cerulean',linewidth=PLOT_lineWidthRegular, linestyle='-');
    p2, = ax.plot(1/freqs_TECM,(Cxx_TECM),color='xkcd:deep red',linewidth=PLOT_lineWidthRegular, linestyle='--');
    p3, = ax.plot(1/freqs_Z,(Cxx_Z),color='xkcd:goldenrod',linewidth=PLOT_lineWidthRegular, linestyle='-.');
    p4, = ax.plot(1/freqs_M,(Cxx_M),color='xkcd:purple',linewidth=PLOT_lineWidthRegular, linestyle='-.');
    p5, = ax.plot(1/freqs_OMNIZ,(Cxx_OMNIZ),color='xkcd:dark gray',linewidth=PLOT_lineWidthRegular, linestyle='-.');
    p6, = ax.plot(1/freqs_OMNIM,(Cxx_OMNIM),color='xkcd:forest green',linewidth=PLOT_lineWidthRegular, linestyle='-.');
    p7, = ax.plot(1/freqs_TECZN,(Cxx_TECZN),color='xkcd:orange',linewidth=PLOT_lineWidthRegular, linestyle='-.');
    p8, = ax.plot(1/freqs_TECMN,(Cxx_TECMN),color='xkcd:lavender',linewidth=PLOT_lineWidthRegular, linestyle='--');
    errorMax = np.max([Cxx_TECZN.max(),Cxx_TECMN.max()]);
    pLine = ax.hlines(errorMax,np.min(1/freqs_TECZ),plot_periodLim_max,color='xkcd:fire engine red',linewidth=PLOT_lineWidthRegular, linestyle='--');
    ax.set_xlabel('Periods [min]',fontproperties=FONT_axisLabelFM);
    ax.set_ylabel('Arb. Power',fontproperties=FONT_axisLabelFM);
    ax.set_title('Power Spectra - Noise '+str(avgPt_TECnoise_iterations)+' Iteration Average Time Limited to '+str(str(np.round(time_cutout_range[0]/3600,2)).rstrip('0').rstrip('.'))+' to '+str(str(np.round(time_cutout_range[-1]/3600,2)).rstrip('0').rstrip('.'))+' hrs at Millstone '+str(np.round(latMillstone,2))+' degc lat/'+str(np.round(longMillstone,2))+' deg long on Day '+str(dateRange_dayNum_zeroHr[1])+', '+str(dateRange_dayNum_zeroHr[0]), \
        fontproperties=FONT_titleFM);
    ax.legend([p1,p2,p3,p4,p5,p6,p7,p8],
        # ['Point TEC AVG''d to Zenith Times & HP vs Zenith HP AVG''d '+str(pointAltitude)+' km +/-'+str(avgPt_ISRavgAlt)+' km', \
        # 'Point TEC AVG''d to MISA Times & HP vs MISA HP AVG''d '+str(pointAltitude)+' km +/-'+str(avgPt_ISRavgAlt)+' km', \
        # 'Zenith & MISA HP AVG''d to '+str(pointAltitude)+' km +/-'+str(avgPt_ISRavgAlt)+' km',\
        # 'OMNI '+OMNI_plot_labelNoUnits+' AVG''d to Zenith Times & HP (Time Delayed '+str(time_cutout_range_delay)+' hrs) vs Zenith HP AVG''d '+str(pointAltitude)+' km +/-'+str(avgPt_ISRavgAlt)+' km', \
        # 'OMNI '+OMNI_plot_labelNoUnits+' AVG''d to MISA Times & HP (Time Delayed '+str(time_cutout_range_delay)+' hrs) vs MISA HP AVG''d '+str(pointAltitude)+' km +/-'+str(avgPt_ISRavgAlt)+' km', \
        # 'OMNI '+OMNI_plot_labelNoUnits+' AVG''d to Zenith Times & HP (Time Delayed '+str(time_cutout_range_delay)+' hrs) vs Point TEC AVG''d to Zenith Times & HP', \
        # 'OMNI '+OMNI_plot_labelNoUnits+' AVG''d to MISA Times & HP (Time Delayed '+str(time_cutout_range_delay)+' hrs) vs Point TEC AVG''d to MISA Times & HP', \
        ['TEC@Z', \
        'TEC@M', \
        'Z ISR', \
        'M ISR', \
        'OMNI@Z'+' '+str(time_cutout_range_delay_OMNI)+' hr', \
        'OMNI@M'+' '+str(time_cutout_range_delay_OMNI)+' hr', \
        'TECnoise@Z',\
        'TECnoise@M'],\
        loc='upper left');
    
    xAxisTicks = np.arange( 0, plot_periodLim_max+10, 10); #sets the start hr, stop hr, and the step size between (in this case, 2 hr)
    ax.set_xticks(xAxisTicks); #set x axis ticks
    ax.set_xlim( (np.min(1/freqs_TECvZ), plot_periodLim_max) )
    #final plot adjusting stuff
    fig.subplots_adjust(left = 0.065, right = 0.975, top = 0.96, bottom = 0.065 , hspace = 0.225); #sets padding to small numbers for minimal white space
    #fig.tight_layout(); #function for a tight layout, doesn't seem to do much here
    plt.show(); #req to make plot show up
    warnings.filterwarnings("default", category=RuntimeWarning); #silences warnings about NaNs used in a logical comparisons #yolo
#END IF

if( FLG_avgPt_HP_timeMatch_POPLnAMPERE_FFT_cutOut == 1 ):
    #Unpack line widths
    PLOT_lineWidthThicc = PLOT_lineWidth['thicc']; #get the line widths
    PLOT_lineWidthDoublePlus = PLOT_lineWidth['double plus']; #get the line widths
    PLOT_lineWidthPlus = PLOT_lineWidth['plus']; #get the line widths
    PLOT_lineWidthRegularPlus = PLOT_lineWidth['regular plus']; #get the line widths
    PLOT_lineWidthRegular = PLOT_lineWidth['regular']; #get the line widths
    PLOT_lineWidthSmol = PLOT_lineWidth['smol']; #get the line widths
    
    Zenith_time_delta = np.median(np.diff(Zenith_time)); #days, delta of time between readings
    MISA_time_delta = np.median(np.diff(MISA_time)); #days, delta of time between readings

    #ZENITH NOW
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (avgPt_vTEC_timeMatch_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (avgPt_vTEC_timeMatch_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , \
        np.where(np.min(np.abs( (avgPt_vTEC_timeMatch_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (avgPt_vTEC_timeMatch_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range
    
    avgPt_vTEC_timeMatch_HP_cutOut = avgPt_vTEC_timeMatch_HP[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    avgPt_vTEC_timeMatch_time_cutOut = avgPt_vTEC_timeMatch_time[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , \
        np.where(np.min(np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range
    
    Zenith_time_cutOut = Zenith_time[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    # Zenith_POPL_hp_cutOut = Zenith_POPL_hp[:,time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    Zenith_POPL_hp_altAvgd_cutOut = Zenith_POPL_hp_altAvgd[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    
    #MISA NOW
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (avgPt_vTEC_timeMatch_time_MISA-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (avgPt_vTEC_timeMatch_time_MISA-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , \
        np.where(np.min(np.abs( (avgPt_vTEC_timeMatch_time_MISA-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (avgPt_vTEC_timeMatch_time_MISA-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range
    
    avgPt_vTEC_timeMatch_HP_cutOut_MISA = avgPt_vTEC_timeMatch_HP_MISA[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    avgPt_vTEC_timeMatch_time_cutOut_MISA = avgPt_vTEC_timeMatch_time_MISA[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
            
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , 
        np.where(np.min(np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range
                             
    MISA_time_cutOut = MISA_time[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    # MISA_POPL_hp_cutOut = MISA_POPL_hp[:,time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    MISA_POPL_hp_altAvgd_cutOut = MISA_POPL_hp_altAvgd[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    
    #AMPERE plot prep
    AMPERE_timeUnique_hr = (AMPERE_timeUnique - dateRange_dayNum_zeroHr[1]*86400); #hr, convert to hr with 0 hr at specified day
    
    if( np.mod(np.round(np.min(AMPERE_timeUnique_hr)),2) == 0 ):
        AMPERE_time_hr_axis_min = np.round(np.min(AMPERE_timeUnique_hr)); #is even, good to go
    else:
        AMPERE_time_hr_axis_min = np.round(np.min(AMPERE_timeUnique_hr))+1; #is odd, make even
    #END IF
    if( np.mod(np.round(np.max(AMPERE_timeUnique_hr)),2) == 0 ):
        AMPERE_time_hr_axis_max = np.round(np.max(AMPERE_timeUnique_hr)); #is even, good to go
    else:
        AMPERE_time_hr_axis_max = np.round(np.max(AMPERE_timeUnique_hr))-1; #is odd, make even
    #END IF
    
    if( (np.min(plotLatRange) >= 0) & (np.max(plotLatRange) >= 0) ):
        #northern hemisphere
        kInRange = data['AMPERE']['lat'] >= 0; #get data in the range
    else:
        #southern hemisphere
        kInRange = data['AMPERE']['lat'] <= 0; #get data in the range
    #END IF
    
    AMPERE_integrate = np.zeros( AMPERE_timeUnique_hr.size , dtype=np.float64); #prep integrated joule heating
    for i in range(AMPERE_timeUnique_hr.size):
        k = AMPERE_timeUnique[i] == data['AMPERE']['time']; #get the right time
        AMPERE_integrate[i] = np.sum((AMPERE_data[k&kInRange,AMPERE_plot_index])); #ergs/(cm^2*sec), get the Joule Heating for the current time stamp
    #END FOR i
    
    if( FLG_AMPERE_log == 1 ):
        strLog = 'Log of '; #set the string
        AMPERE_integrate = np.log10(AMPERE_integrate); #log it
        if( FLG_AMPERE_hp == 1 ):
            #want to highpass after the log, b/c negatives ruin log
            AMPERE_integrate = subfun_highpass(AMPERE_timeUnique_hr, AMPERE_integrate); #highpass the data
        #END IF
    else:
        strLog = ''; #nothing to say
        if( FLG_AMPERE_hp == 1 ):
            AMPERE_integrate = subfun_highpass(AMPERE_timeUnique_hr, AMPERE_integrate); #highpass the data
        #END IF
    #END IF
    
    AMPERE_plot_label = AMPERE_plot_labels[np.where(AMPERE_plot_indexes == AMPERE_plot_index)[0][0]]; #get the label
    AMPERE_plot_label_noUnits = AMPERE_plot_label[0:AMPERE_plot_label.find('[')-1]; #remove the (units)
    
    #no time alignment yet NOW
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( AMPERE_timeUnique_hr - np.min(time_cutout_range_delayed_AMPERE) )) == np.abs( AMPERE_timeUnique_hr - np.min(time_cutout_range_delayed_AMPERE) ) )[0][0] , \
        np.where(np.min(np.abs( AMPERE_timeUnique_hr - np.max(time_cutout_range_delayed_AMPERE) )) == np.abs( AMPERE_timeUnique_hr - np.max(time_cutout_range_delayed_AMPERE) ) )[0][0] ) ); #get the indexes for that time cutout range
    
    AMPERE_integrate_cutOut = AMPERE_integrate[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    AMPERE_timeUnique_hr_cutOut = AMPERE_timeUnique_hr[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    
    
    from scipy import signal
#    from matplotlib import mlab
    window = np.hamming(110);
#    window= np.pad(window,(0,512-110),mode='constant')
    
    pwr_TEC_Z = np.sqrt(1/avgPt_vTEC_timeMatch_HP_cutOut.size*np.sum(avgPt_vTEC_timeMatch_HP_cutOut**2)); #estimate power of signal
    pwr_TEC_M = np.sqrt(1/avgPt_vTEC_timeMatch_HP_cutOut_MISA.size*np.sum(avgPt_vTEC_timeMatch_HP_cutOut_MISA**2)); #estimate power of signal
    pwr_Z = np.sqrt(1/Zenith_POPL_hp_altAvgd_cutOut.size*np.sum(Zenith_POPL_hp_altAvgd_cutOut**2)); #estimate power of signal
    pwr_M = np.sqrt(1/MISA_POPL_hp_altAvgd_cutOut.size*np.sum(MISA_POPL_hp_altAvgd_cutOut**2)); #estimate power of signal
    pwr_AMPERE = np.sqrt(1/AMPERE_integrate_cutOut.size*np.sum(AMPERE_integrate_cutOut**2)); #estimate power of signal
    
    Fs = 1/(Zenith_time_delta*24*60); #min, zenith time delta in freq form
    [freqs_TECZ,Cxx_TECZ] = signal.welch(1/pwr_TEC_Z*avgPt_vTEC_timeMatch_HP_cutOut ,window=window,noverlap=100,nfft=512,fs=Fs);
    [freqs_Z,Cxx_Z] = signal.welch(1/pwr_Z*Zenith_POPL_hp_altAvgd_cutOut ,window=window,noverlap=100,nfft=512,fs=Fs);
    [freqs_AMPERE,Cxx_AMPERE] = signal.welch(1/pwr_AMPERE*AMPERE_integrate_cutOut ,window=window,noverlap=100,nfft=512,fs=1/(np.median(np.diff(AMPERE_timeUnique_hr))*60));
    
    Fs = 1/(MISA_time_delta*24*60); #min, MISA time delta in freq form
    [freqs_TECM,Cxx_TECM] = signal.welch(1/pwr_TEC_M*avgPt_vTEC_timeMatch_HP_cutOut_MISA ,window=window,noverlap=100,nfft=512,fs=Fs);
    [freqs_M,Cxx_M] = signal.welch(1/pwr_M*MISA_POPL_hp_altAvgd_cutOut ,window=window,noverlap=100,nfft=512,fs=Fs);
    
    warnings.filterwarnings("ignore", category=RuntimeWarning); #silences warnings about NaNs used in a logical comparisons #yolo
    fig, ax = plt.subplots(nrows=1, ncols=1); #use instead of fig because it inits an axis too (I think I dunno)
    figManager = plt.get_current_fig_manager(); #req to maximize
    figManager.window.showMaximized(); #force maximized
    #Remove the aspect ratio from the basemap so it fills the screen better
    ax.set_aspect('auto');
    
    p1, = ax.plot(1/freqs_TECZ,(Cxx_TECZ),color='xkcd:cerulean',linewidth=PLOT_lineWidthRegular, linestyle='-');
    p2, = ax.plot(1/freqs_TECM,(Cxx_TECM),color='xkcd:deep red',linewidth=PLOT_lineWidthRegular, linestyle='--');
    p3, = ax.plot(1/freqs_Z,(Cxx_Z),color='xkcd:goldenrod',linewidth=PLOT_lineWidthRegular, linestyle='-.');
    p4, = ax.plot(1/freqs_M,(Cxx_M),color='xkcd:purple',linewidth=PLOT_lineWidthRegular, linestyle='-.');
    p5, = ax.plot(1/freqs_AMPERE,(Cxx_AMPERE),color='xkcd:forest green',linewidth=PLOT_lineWidthRegular, linestyle='-.');
    ax.set_xlim( (0, plot_periodLim_max) )
    ax.set_xlabel('Periods [min]',fontproperties=FONT_axisLabelFM);
    ax.set_ylabel('Arb. Power',fontproperties=FONT_axisLabelFM);
    ax.set_title('Spectral Comparison - (TEC HP\'d) Time Limited to '+str(str(np.round(time_cutout_range[0]/3600,2)).rstrip('0').rstrip('.'))+' to '+str(str(np.round(time_cutout_range[-1]/3600,2)).rstrip('0').rstrip('.'))+' hrs at Millstone '+str(np.round(latMillstone,2))+' degc lat/'+str(np.round(longMillstone,2))+' deg long on Day '+str(dateRange_dayNum_zeroHr[1])+', '+str(dateRange_dayNum_zeroHr[0]), \
        fontproperties=FONT_titleFM);
    ax.legend([p1,p2,p3,p4,p5],['Point TEC AVG''d to Zenith Times & HP', \
        'Point TEC AVG''d to MISA Times & HP', \
        'Zenith HP AVG''d to '+str(pointAltitude)+' km +/-'+str(avgPt_ISRavgAlt)+' km',\
        'MISA HP AVG''d to '+str(pointAltitude)+' km +/-'+str(avgPt_ISRavgAlt)+' km',\
        strLog+'AMPERE '+AMPERE_plot_label_noUnits+' (Time Delayed '+str(time_cutout_range_delay_AMPERE)+' hrs)'], \
        loc='upper left');
    
    xAxisTicks = np.arange( 0, plot_periodLim_max+10, 10); #sets the start hr, stop hr, and the step size between (in this case, 2 hr)
    ax.set_xticks(xAxisTicks); #set x axis ticks
    #final plot adjusting stuff
    fig.subplots_adjust(left = 0.065, right = 0.975, top = 0.96, bottom = 0.065 , hspace = 0.225); #sets padding to small numbers for minimal white space
    #fig.tight_layout(); #function for a tight layout, doesn't seem to do much here
    plt.show(); #req to make plot show up
    warnings.filterwarnings("default", category=RuntimeWarning); #silences warnings about NaNs used in a logical comparisons #yolo
#END IF

#==============Analysis: Plot the delta-vTEC point-averaged time series with the ISR POPL HP altitude-averaged time series, along with an ISR RTI plot, over a cut-out time period==============
if( FLG_avgPt_HP_timeMatch_POPLnAMPERE_plotWithISR_ZenithOnly_cutOut == 1 ):
    #ZENITH ONLY - NO MISA!!!
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (avgPt_vTEC_timeMatch_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (avgPt_vTEC_timeMatch_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , \
        np.where(np.min(np.abs( (avgPt_vTEC_timeMatch_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (avgPt_vTEC_timeMatch_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range
    
    avgPt_vTEC_timeMatch_HP_cutOut = avgPt_vTEC_timeMatch_HP[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    avgPt_vTEC_timeMatch_time_cutOut = avgPt_vTEC_timeMatch_time[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , \
        np.where(np.min(np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range
    
    Zenith_time_cutOut = Zenith_time[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    Zenith_POPL_hp_cutOut = Zenith_POPL_hp[:,time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    Zenith_POPL_hp_altAvgd_cutOut = Zenith_POPL_hp_altAvgd[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , \
        np.where(np.min(np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range

    MISA_time_cutOut = MISA_time[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    MISA_POPL_hp_altAvgd_cutOut = MISA_POPL_hp_altAvgd[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    
        #AMPERE plot prep
    AMPERE_timeUnique_hr = (AMPERE_timeUnique - dateRange_dayNum_zeroHr[1]*86400); #hr, convert to hr with 0 hr at specified day
    
    if( np.mod(np.round(np.min(AMPERE_timeUnique_hr)),2) == 0 ):
        AMPERE_time_hr_axis_min = np.round(np.min(AMPERE_timeUnique_hr)); #is even, good to go
    else:
        AMPERE_time_hr_axis_min = np.round(np.min(AMPERE_timeUnique_hr))+1; #is odd, make even
    #END IF
    if( np.mod(np.round(np.max(AMPERE_timeUnique_hr)),2) == 0 ):
        AMPERE_time_hr_axis_max = np.round(np.max(AMPERE_timeUnique_hr)); #is even, good to go
    else:
        AMPERE_time_hr_axis_max = np.round(np.max(AMPERE_timeUnique_hr))-1; #is odd, make even
    #END IF
    
    if( (np.min(plotLatRange) >= 0) & (np.max(plotLatRange) >= 0) ):
        #northern hemisphere
        kInRange = data['AMPERE']['lat'] >= 0; #get data in the range
    else:
        #southern hemisphere
        kInRange = data['AMPERE']['lat'] <= 0; #get data in the range
    #END IF
    
    AMPERE_integrate = np.zeros( AMPERE_timeUnique_hr.size , dtype=np.float64); #prep integrated joule heating
    for i in range(AMPERE_timeUnique_hr.size):
        k = AMPERE_timeUnique[i] == data['AMPERE']['time']; #get the right time
        AMPERE_integrate[i] = np.sum((AMPERE_data[k&kInRange,AMPERE_plot_index])); #ergs/(cm^2*sec), get the Joule Heating for the current time stamp
    #END FOR i
    
    if( FLG_AMPERE_log == 1 ):
        strLog = 'Log of '; #set the string
        AMPERE_integrate = np.log10(AMPERE_integrate); #log it
        if( FLG_AMPERE_hp == 1 ):
            #want to highpass after the log, b/c negatives ruin log
            AMPERE_integrate = subfun_highpass(AMPERE_timeUnique_hr, AMPERE_integrate); #highpass the data
        #END IF
    else:
        strLog = ''; #nothing to say
        if( FLG_AMPERE_hp == 1 ):
            AMPERE_integrate = subfun_highpass(AMPERE_timeUnique_hr, AMPERE_integrate); #highpass the data
        #END IF
    #END IF
    
    AMPERE_plot_label = AMPERE_plot_labels[np.where(AMPERE_plot_indexes == AMPERE_plot_index)[0][0]]; #get the label
    AMPERE_plot_label_noUnits = AMPERE_plot_label[0:AMPERE_plot_label.find('[')-1]; #remove the (units)
    
    #no time alignment yet NOW
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( AMPERE_timeUnique_hr - np.min(time_cutout_range_delayed_AMPERE) )) == np.abs( AMPERE_timeUnique_hr - np.min(time_cutout_range_delayed_AMPERE) ) )[0][0] , \
        np.where(np.min(np.abs( AMPERE_timeUnique_hr - np.max(time_cutout_range_delayed_AMPERE) )) == np.abs( AMPERE_timeUnique_hr - np.max(time_cutout_range_delayed_AMPERE) ) )[0][0] ) ); #get the indexes for that time cutout range
    
    AMPERE_integrate_cutOut = AMPERE_integrate[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( AMPERE_timeUnique_hr - np.min(time_cutout_range) )) == np.abs( AMPERE_timeUnique_hr - np.min(time_cutout_range) ) )[0][0] , \
        np.where(np.min(np.abs( AMPERE_timeUnique_hr - np.max(time_cutout_range) )) == np.abs( AMPERE_timeUnique_hr - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range
    AMPERE_timeUnique_hr_cutOut = AMPERE_timeUnique_hr[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    
    GRITI_TEC_avgPt_HP_timeMatch_POPLnAMPERE_plotWithISR_ZenithOnly_cutOut(avgPt_vTEC_timeMatch_HP_cutOut,avgPt_vTEC_timeMatch_time_cutOut, \
        Zenith_time_cutOut,Zenith_height,Zenith_POPL_hp_cutOut,Zenith_POPL_hp_altAvgd_cutOut,MISA_time_cutOut,MISA_height,MISA_POPL_hp_altAvgd_cutOut, \
        AMPERE_integrate_cutOut, AMPERE_timeUnique_hr_cutOut, AMPERE_plot_label, AMPERE_plot_label_noUnits, FLG_AMPERE_log, FLG_AMPERE_hp, \
        filter_cutoffPeriod,ISR_RTI_heightLimValues,ISR_POPL_plotLimValu,avgPt_coords[0,:],avgPt_ISRavgAlt,pointAltitude,time_cutout_range, time_cutout_range_delay_AMPERE, \
        dateRange,dateRange_dayNum,dateRange_dayNum_zeroHr,FONT_titleFM,FONT_axisTick,FONT_axisLabelFM,PLOT_lineWidth);
#END IF


if( FLG_avgPt_HP_timeMatch_FFTthruTime_POPLnOMNI == 1 ):
    from scipy import signal
#    from matplotlib import mlab
    window = np.hamming(110);
#    window= np.pad(window,(0,512-110),mode='constant')
    Zenith_time_delta = np.median(np.diff(Zenith_time)); #days, delta of time between readings
    MISA_time_delta = np.median(np.diff(MISA_time)); #days, delta of time between readings
    
    #OMNI plot prep
    OMNI_plot_label = OMNI_dictPlot[OMNI_dict[OMNI_plot_name]]; #get the label
    OMNI_plot_labelNoUnits = OMNI_plot_label[0:OMNI_plot_label.find('[')-1]; #remove the (units)
    
    time_range = np.array( ((time_Ref[0]-dateRange_dayNum_zeroHr[1]*86400) , (time_Ref[-1]-dateRange_dayNum_zeroHr[1]*86400)) ); #make a time range based on the reference time
    time_rangeRound = np.int64(np.floor(np.abs(time_range))*(time_range/np.abs(time_range))); #get the absolute hours - absolute shennanigans are to get floor to floor -11.3 -> -11 and not -12
    thruTime_num = np.int64((np.diff(time_rangeRound).item()-thruTime_width)/thruTime_step)+1; #number of times the time_rangeRound can be split into the required width and step size
    thruTime = np.zeros( (thruTime_num,2) ); #prep array
    for i in range(0,thruTime_num):
        thruTime[i,0] = time_rangeRound[0]+i*thruTime_step; #get the starting time
        thruTime[i,1] = thruTime[i,0] + thruTime_width; #get the ending time
    #END FOR i
    
    thruTime_spectral = np.zeros([6,thruTime_num,np.int64(512/2+1)]); #prep a holder for the spectral info
    for i in range(0,thruTime_num):
        #ZENITH NOW
        time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (avgPt_vTEC_timeMatch_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(thruTime[i,:]) )) == np.abs( (avgPt_vTEC_timeMatch_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(thruTime[i,:]) ) )[0][0] , \
            np.where(np.min(np.abs( (avgPt_vTEC_timeMatch_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(thruTime[i,:]) )) == np.abs( (avgPt_vTEC_timeMatch_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(thruTime[i,:]) ) )[0][0] ) ); #get the indexes for that time cutout range
        
        avgPt_vTEC_timeMatch_HP_cutOut = avgPt_vTEC_timeMatch_HP[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
        avgPt_vTEC_timeMatch_time_cutOut = avgPt_vTEC_timeMatch_time[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
        
        time_cutout_indexesZ = np.array( ( np.where(np.min(np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(thruTime[i,:]) )) == np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(thruTime[i,:]) ) )[0][0] , \
            np.where(np.min(np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(thruTime[i,:]) )) == np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(thruTime[i,:]) ) )[0][0] ) ); #get the indexes for that time cutout range
        
        Zenith_time_cutOut = Zenith_time[time_cutout_indexesZ[0]:time_cutout_indexesZ[1]+1];
        Zenith_POPL_hp_cutOut = Zenith_POPL_hp[:,time_cutout_indexesZ[0]:time_cutout_indexesZ[1]+1];
        Zenith_POPL_hp_altAvgd_cutOut = Zenith_POPL_hp_altAvgd[time_cutout_indexesZ[0]:time_cutout_indexesZ[1]+1];
        
        #MISA NOW
        time_cutout_indexesM = np.array( ( np.where(np.min(np.abs( (avgPt_vTEC_timeMatch_time_MISA-dateRange_dayNum_zeroHr[1]*86400) - np.min(thruTime[i,:]) )) == np.abs( (avgPt_vTEC_timeMatch_time_MISA-dateRange_dayNum_zeroHr[1]*86400) - np.min(thruTime[i,:]) ) )[0][0] , \
            np.where(np.min(np.abs( (avgPt_vTEC_timeMatch_time_MISA-dateRange_dayNum_zeroHr[1]*86400) - np.max(thruTime[i,:]) )) == np.abs( (avgPt_vTEC_timeMatch_time_MISA-dateRange_dayNum_zeroHr[1]*86400) - np.max(thruTime[i,:]) ) )[0][0] ) ); #get the indexes for that time cutout range
        
        avgPt_vTEC_timeMatch_HP_cutOut_MISA = avgPt_vTEC_timeMatch_HP_MISA[time_cutout_indexesM[0]:time_cutout_indexesM[1]+1];
        avgPt_vTEC_timeMatch_time_cutOut_MISA = avgPt_vTEC_timeMatch_time_MISA[time_cutout_indexesM[0]:time_cutout_indexesM[1]+1];
                
        time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(thruTime[i,:]) )) == np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(thruTime[i,:]) ) )[0][0] , 
            np.where(np.min(np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(thruTime[i,:]) )) == np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(thruTime[i,:]) ) )[0][0] ) ); #get the indexes for that time cutout range
                                 
        MISA_time_cutOut = MISA_time[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
        MISA_POPL_hp_cutOut = MISA_POPL_hp[:,time_cutout_indexes[0]:time_cutout_indexes[1]+1];
        MISA_POPL_hp_altAvgd_cutOut = MISA_POPL_hp_altAvgd[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
        
        #ZENITH NOW
        time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (OMNI_data_timeMatch_time_Zenith-dateRange_dayNum_zeroHr[1]*86400) - np.min(thruTime[i,:]+time_cutout_range_delay_OMNI) )) == np.abs( (OMNI_data_timeMatch_time_Zenith-dateRange_dayNum_zeroHr[1]*86400) - np.min(thruTime[i,:]+time_cutout_range_delay_OMNI) ) )[0][0] , \
            np.where(np.min(np.abs( (OMNI_data_timeMatch_time_Zenith-dateRange_dayNum_zeroHr[1]*86400) - np.max(thruTime[i,:]+time_cutout_range_delay_OMNI) )) == np.abs( (OMNI_data_timeMatch_time_Zenith-dateRange_dayNum_zeroHr[1]*86400) - np.max(thruTime[i,:]+time_cutout_range_delay_OMNI) ) )[0][0] ) ); #get the indexes for that time cutout range
        
        OMNI_data_timeMatch_HP_Zenith_cutOut = OMNI_data_timeMatch_HP_Zenith[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
        OMNI_data_timeMatch_time_Zenith_cutOut = OMNI_data_timeMatch_time_Zenith[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
        
        #MISA NOW
        time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (OMNI_data_timeMatch_time_MISA-dateRange_dayNum_zeroHr[1]*86400) - np.min(thruTime[i,:]+time_cutout_range_delay_OMNI) )) == np.abs( (OMNI_data_timeMatch_time_MISA-dateRange_dayNum_zeroHr[1]*86400) - np.min(thruTime[i,:]+time_cutout_range_delay_OMNI) ) )[0][0] , \
            np.where(np.min(np.abs( (OMNI_data_timeMatch_time_MISA-dateRange_dayNum_zeroHr[1]*86400) - np.max(thruTime[i,:]+time_cutout_range_delay_OMNI) )) == np.abs( (OMNI_data_timeMatch_time_MISA-dateRange_dayNum_zeroHr[1]*86400) - np.max(thruTime[i,:]+time_cutout_range_delay_OMNI) ) )[0][0] ) ); #get the indexes for that time cutout range
        
        OMNI_data_timeMatch_HP_MISA_cutOut = OMNI_data_timeMatch_HP_MISA[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
        OMNI_data_timeMatch_time_MISA_cutOut = OMNI_data_timeMatch_time_MISA[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
        
        #do some spectral analysis on this
        pwr_TEC_Z = np.sqrt(1/avgPt_vTEC_timeMatch_HP_cutOut.size*np.sum(avgPt_vTEC_timeMatch_HP_cutOut**2)); #estimate power of signal
        pwr_TEC_M = np.sqrt(1/avgPt_vTEC_timeMatch_HP_cutOut_MISA.size*np.sum(avgPt_vTEC_timeMatch_HP_cutOut_MISA**2)); #estimate power of signal
        pwr_Z = np.sqrt(1/Zenith_POPL_hp_altAvgd_cutOut.size*np.sum(Zenith_POPL_hp_altAvgd_cutOut**2)); #estimate power of signal
        pwr_M = np.sqrt(1/MISA_POPL_hp_altAvgd_cutOut.size*np.sum(MISA_POPL_hp_altAvgd_cutOut**2)); #estimate power of signal
        pwr_OMNI_Z = np.sqrt(1/OMNI_data_timeMatch_HP_Zenith_cutOut.size*np.sum(OMNI_data_timeMatch_HP_Zenith_cutOut**2)); #estimate power of signal
        pwr_OMNI_M = np.sqrt(1/OMNI_data_timeMatch_HP_MISA_cutOut.size*np.sum(OMNI_data_timeMatch_HP_MISA_cutOut**2)); #estimate power of signal
        
        #ZENITH STUFF
        Fs = 1/(Zenith_time_delta*24*60); #min, zenith time delta in freq form
        [freqs_TECZ,Cxx_TECZ] = signal.welch(1/pwr_TEC_Z*avgPt_vTEC_timeMatch_HP_cutOut ,window=window,noverlap=100,nfft=512,fs=Fs);
        [freqs_Z,Cxx_Z] = signal.welch(1/pwr_Z*Zenith_POPL_hp_altAvgd_cutOut ,window=window,noverlap=100,nfft=512,fs=Fs);
        [freqs_OMNIZ,Cxx_OMNIZ] = signal.welch(1/pwr_OMNI_Z*OMNI_data_timeMatch_HP_Zenith_cutOut ,window=window,noverlap=100,nfft=512,fs=Fs);
        
        #MISA STUFF
        Fs = 1/(MISA_time_delta*24*60); #min, misa time delta in freq form
        [freqs_TECM,Cxx_TECM] = signal.welch(1/pwr_TEC_M*avgPt_vTEC_timeMatch_HP_cutOut_MISA ,window=window,noverlap=100,nfft=512,fs=Fs);
        [freqs_M,Cxx_M] = signal.welch(1/pwr_M*MISA_POPL_hp_altAvgd_cutOut ,window=window,noverlap=100,nfft=512,fs=Fs);
        [freqs_OMNIM,Cxx_OMNIM] = signal.welch(1/pwr_OMNI_M*OMNI_data_timeMatch_HP_MISA_cutOut ,window=window,noverlap=100,nfft=512,fs=Fs);
        
        thruTime_spectral[0,i,:] = Cxx_TECZ; #record
        thruTime_spectral[3,i,:] = Cxx_TECM; #record
        thruTime_spectral[1,i,:] = Cxx_Z; #record
        thruTime_spectral[4,i,:] = Cxx_M; #record
        thruTime_spectral[2,i,:] = Cxx_OMNIZ; #record
        thruTime_spectral[5,i,:] = Cxx_OMNIM; #record
    #END FOR i
    
    
    #PLOT IT UP
    warnings.filterwarnings("ignore", category=RuntimeWarning); #silences warnings about NaNs used in a logical comparisons #yolo
    FLG_sameColorLimits = 0; #if 0 different, if 1 samesies
    xAxisTicks = np.arange( np.round(np.min(1/freqs_TECZ)/10)*10, plot_periodLim_max+10, 10); #sets the start hr, stop hr, and the step size between (in this case, 2 hr)
    fig, ax = plt.subplots(nrows=2, ncols=3); #use instead of fig because it inits an axis too (I think I dunno)
    figManager = plt.get_current_fig_manager(); #req to maximize
    figManager.window.showMaximized(); #force maximized
    
    if( np.max(thruTime_spectral[:,:,1/freqs_TECZ <= plot_periodLim_max]) > 200 ):
        rounder = 50; #set to round to every 50
    else:
        rounder = 25; #set to round to every 25
    #END IF
    vMax = np.ceil(np.max(thruTime_spectral[:,:,1/freqs_TECZ <= plot_periodLim_max])/rounder)*rounder; #get the overall max - FLG_sameColorLimits=0 overrides this
    for i in range(0,ax.shape[0]): #helps automagically plot
        for j in range(0,ax.shape[1]):
            if( FLG_sameColorLimits == 0 ):
                if( np.max(thruTime_spectral[i*ax.shape[1]+j,:,:]) > 200 ):
                    rounder = 50; #set to round to every 50
                else:
                    rounder = 25; #set to round to every 25
                #END IF
                vMax = np.ceil(np.max(thruTime_spectral[i*ax.shape[1]+j,:,:])/rounder)*rounder; #get the max for the plot itself
            #END IF
            #prep colorbar
            divider = make_axes_locatable(ax[i,j]); #prep to add an axis
            cax = divider.append_axes('right', size='2.0%', pad=0.15); #make a color bar axis
            #Remove the aspect ratio from the basemap so it fills the screen better
            ax[i,j].set_aspect('auto');
            
            pltHelprX, pltHelprY = np.meshgrid( thruTime[:,0], 1/freqs_TECZ);
            #gotta catch inf
            pltHelprY[np.isinf(pltHelprY)] = np.max(pltHelprY[~np.isinf(pltHelprY)])*2; #remove the infs
            im = ax[i,j].pcolormesh(pltHelprX, pltHelprY,  thruTime_spectral[i*ax.shape[1]+j,:,:].T , \
                vmin=0, vmax=vMax, cmap='nipy_spectral'); # pseudocolor plot "stretched" to the grid
            cbar = fig.colorbar(im, cax=cax, orientation='vertical'); #create a colorbar using the prev. defined cax
            # cax.yaxis.set_major_formatter(tick.FormatStrFormatter('%.1f')); #force a rounded format
            cbar.ax.tick_params(labelsize=FONT_axisTick);
            cbar.mappable.set_clim(vmin=0, vmax=vMax);
            # cax.yaxis.set_ticks(np.linspace(np.min(TEC_plotLimValu),np.max(TEC_plotLimValu),11)); #create useful tick marks
            ax[i,j].set_title('Power Spectra for TEC at Zenith - '+str(thruTime_width)+' hr width', \
                fontproperties=FONT_titleFM);
            ax[i,j].set_yticks(xAxisTicks); #set y axis ticks
            ax[i,j].set_ylim( (np.min(1/freqs_TECvZ), plot_periodLim_max) ); #set the axis limit
            
            if( i == ax.shape[0]-1 and j == np.int64((ax.shape[1]-1)/2) ):
                ax[i,j].set_xlabel('Start Hour - Time in UT [hr] - 0 Hr on '+dateRange_zeroHr_monthName+ \
                    ' '+str(dateRange_zeroHr[2])+dateRange_zeroHr_dayPostfix+' | Day '+ \
                    str(dateRange_dayNum_zeroHr[1])+', '+str(dateRange_dayNum_zeroHr[0]),fontproperties=FONT_axisLabelFM);
            #END IF
            if( j == 0 ):
                ax[i,j].set_ylabel('Periods [min]',fontproperties=FONT_axisLabelFM);
            elif( j == ax.shape[1]-1 ):
                cbar.set_label('Arb. Power'); #tabel the colorbar
                cax.yaxis.label.set_font_properties(FONT_axisLabelFM);
            #END IF
            if( i == 0 and j == 0 ):
                ax[i,j].set_title('TEC at Zenith', fontproperties=FONT_titleFM);
            elif( i == 0 and j == 1 ):
                ax[i,j].set_title('Zenith ISR', fontproperties=FONT_titleFM);
            elif( i == 0 and j == 2 ):
                ax[i,j].set_title(OMNI_plot_labelNoUnits+' on Zenith ['+str(time_cutout_range_delay_OMNI)+' hr]', fontproperties=FONT_titleFM);
            elif( i == 1 and j == 0 ):
                ax[i,j].set_title('TEC at MISA', fontproperties=FONT_titleFM);
            elif( i == 1 and j == 1 ):
                ax[i,j].set_title('MISA ISR', fontproperties=FONT_titleFM);
            elif( i == 1 and j == 2 ):
                ax[i,j].set_title(OMNI_plot_labelNoUnits+' on MISA ['+str(time_cutout_range_delay_OMNI)+' hr]', fontproperties=FONT_titleFM);
            #END IF
        #END FOR j
    #END FOR i
    
    
    #final plot adjusting stuff
    fig.subplots_adjust(left = 0.060, right = 0.945, top = 0.96, bottom = 0.075 , hspace = 0.175, wspace = 0.275); #sets padding to small numbers for minimal white space
    # fig.tight_layout(); #function for a tight layout, doesn't seem to do much here
    plt.show(); #req to make plot show up
    warnings.filterwarnings("default", category=RuntimeWarning); #silences warnings about NaNs used in a logical comparisons #yolo
    
#END IF

if( FLG_FFTthruTime_KEOnAvgPtnAMPEREintegrated == 1 ):
    from scipy import signal
    from scipy.signal import savgol_filter
    from scipy.interpolate import interp1d
#    from matplotlib import mlab
    window = np.hamming(110);
    
    #got a few things going
    #TEC on its own time
    #AMPERE on its own time
    #avgPt_vTEC_HP, avgPt_vTEC_time
    
#    window= np.pad(window,(0,512-110),mode='constant')
    # TEC_time_delta = TEC_dataRate/86400; #days, delta of time between readings
    AMPERE_time_delta = np.median(np.diff(AMPERE_timeUnique)); #days, delta of time between readings
    
    time_range = np.array( ((time_Ref[0]-dateRange_dayNum_zeroHr[1]*86400) , (time_Ref[-1]-dateRange_dayNum_zeroHr[1]*86400)) ); #make a time range based on the reference time
    time_rangeRound = np.int64(np.floor(np.abs(time_range))*(time_range/np.abs(time_range))); #get the absolute hours - absolute shennanigans are to get floor to floor -11.3 -> -11 and not -12
    thruTime_num = np.int64((np.diff(time_rangeRound).item()-thruTime_width)/thruTime_step)+1; #number of times the time_rangeRound can be split into the required width and step size
    thruTime = np.zeros( (thruTime_num,2) ); #prep array
    for i in range(0,thruTime_num):
        thruTime[i,0] = time_rangeRound[0]+i*thruTime_step; #get the starting time
        thruTime[i,1] = thruTime[i,0] + thruTime_width; #get the ending time
    #END FOR i
    
    #----PREP TEC KEO STUFF----
    if( settings['TEC']['keo']['keo plot latlong name'] == 'Latitude' ):
        vTECChunked_keo_index = np.where( np.min(np.abs(settings['TEC']['keo']['keo plot latlong chunks'] - avgPt_coords[0,0])) == np.abs(settings['TEC']['keo']['keo plot latlong chunks'] - avgPt_coords[0,0]))[0].item(); #get index nearest to the data we want
    else:
        vTECChunked_keo_index = np.where( np.min(np.abs(settings['TEC']['keo']['keo plot latlong chunks'] - avgPt_coords[0,1])) == np.abs(settings['TEC']['keo']['keo plot latlong chunks'] - avgPt_coords[0,1]))[0].item(); #get index nearest to the data we want
    #END IF
    vTECChunked_keo_lined = np.nanmean(data['TEC']['keo'][:,vTECChunked_keo_index-3:vTECChunked_keo_index+3],axis=1); #get some extra pts as well to make it steadier
    
    #-----Plot AMPERE results as a 1D line-----
    AMPERE_timeUnique_hr = (AMPERE_timeUnique - dateRange_dayNum_zeroHr[1]*86400); #hr, convert to hr with 0 hr at specified day
    
    if( np.mod(np.round(np.min(AMPERE_timeUnique_hr)),2) == 0 ):
        AMPERE_time_hr_axis_min = np.round(np.min(AMPERE_timeUnique_hr)); #is even, good to go
    else:
        AMPERE_time_hr_axis_min = np.round(np.min(AMPERE_timeUnique_hr))+1; #is odd, make even
    #END IF
    if( np.mod(np.round(np.max(AMPERE_timeUnique_hr)),2) == 0 ):
        AMPERE_time_hr_axis_max = np.round(np.max(AMPERE_timeUnique_hr)); #is even, good to go
    else:
        AMPERE_time_hr_axis_max = np.round(np.max(AMPERE_timeUnique_hr))-1; #is odd, make even
    #END IF
    
    if( (np.min(plotLatRange) >= 0) & (np.max(plotLatRange) >= 0) ):
        #northern hemisphere
        kInRange = data['AMPERE']['lat'] >= 0; #get data in the range
    else:
        #southern hemisphere
        kInRange = data['AMPERE']['lat'] <= 0; #get data in the range
    #END IF
    
    AMPERE_integrate = np.zeros( AMPERE_timeUnique_hr.size , dtype=np.float64); #prep integrated joule heating
    for i in range(AMPERE_timeUnique_hr.size):
        k = AMPERE_timeUnique[i] == data['AMPERE']['time']; #get the right time
        AMPERE_integrate[i] = np.sum((AMPERE_data[k&kInRange,AMPERE_plot_index])); #ergs/(cm^2*sec), get the Joule Heating for the current time stamp
    #END FOR i
    #Can't log 0's, interpolate over them
    k = np.where( AMPERE_integrate == 0 )[0]; #get where 0's are
    AMPERE_integrate[k] = 1; #set to 1 to prevent error
    AMPERE_integrate = np.log10(AMPERE_integrate); #log it
    
    #make sure FFT can happen if it is on
    #if there are data gaps, data needs to be scargled
    # FLG_avg_anyAngle_Scargle_FFT = 0;
    #also NaNs need to be yeeted
    # if( np.isnan(AMPERE_integrate).sum() > 0 ):
    #     k = np.logical_not(np.isnan(AMPERE_integrate));
    #     AMPERE_integrate = AMPERE_integrate[k]; #remove NaNs
    #     AMPERE_timeUnique_hr = AMPERE_timeUnique_hr[k]; #remove NaNs
    # elif( np.isnan(vTECChunked_keo_lined).sum() > 0 ):
    #     k = np.logical_not(np.isnan(vTECChunked_keo_lined));
    #     vTECChunked_keo_lined = vTECChunked_keo_lined[k]; #remove NaNs
    #     TEC_timeUnique = TEC_timeUnique[k]; #remove NaNs
    # #END IF
    
    #Force TEC onto AMPERE data cadence
    if( np.isclose(np.median(np.diff(TEC_timeUnique)),np.median(np.diff(AMPERE_timeUnique))) == False ):
        #Match the data in the 1st input (and its time in the 2nd input) to the time scale given in the 3rd input time and return that data and that data's highpassed form
        _, vTECChunked_keo_lined_timeMatch_HP, TEC_timeUnique_timeMatch = GRITI_TEC_avgPt_timeMatch(vTECChunked_keo_lined,TEC_timeUnique,AMPERE_timeUnique,dateRange_dayNum_zeroHr,filter_cutoffPeriod=settings_spectra['filter cutoff period']);
        _, avgPt_vTEC_timeMatch_HP, TEC_timeUnique_timeMatch = GRITI_TEC_avgPt_timeMatch(avgPt_vTEC,TEC_timeUnique,AMPERE_timeUnique,dateRange_dayNum_zeroHr,filter_cutoffPeriod=settings_spectra['filter cutoff period']); 
    else:
        #-----Highpass the data to keep the power within the period range we want-----
        vTECChunked_keo_lined_timeMatch_HP = subfun_highpass((TEC_timeUnique - dateRange_dayNum_zeroHr[1]*86400), vTECChunked_keo_lined, filter_cutoffPeriod=settings_spectra['filter cutoff period'], filter_order=settings_spectra['filter order'], windowType=settings_spectra['window type'], axisToUse=1);
    #END IF

    #prep the Sav-Gol filter for debiasing
    windowLen_savGol = np.int64(np.round(settings_TEC_import['filter_savGolPeriod']/(AMPERE_time_delta*24*60))); #window length, 60 minutes, converted to seconds, and divided by sample rate (plus 1 because odd is required) gets 121 for an hour window length (frame length)
    #from conversations with AC ^
    if( np.remainder(windowLen_savGol,2) == 0 ): #if there's no remainder, it's even. Gotta add 1 cause Sovitsky-Golay filter needs an odd window length
        windowLen_savGol = windowLen_savGol + 1; #add 1 so it's odd
    #END IF
    polyYvals = savgol_filter(AMPERE_integrate,windowLen_savGol, settings_TEC_import['order_savGol'] ); #filter it up
    AMPERE_integrate_HP = AMPERE_integrate - polyYvals;
    
    #-----Highpass the data to keep the power within the period range we want-----
    # AMPERE_integrate_HP = subfun_highpass(AMPERE_timeUnique_hr, AMPERE_integrate, filter_cutoffPeriod=settings_spectra['filter cutoff period'], filter_order=settings_spectra['filter order'], windowType=settings_spectra['window type'], axisToUse=1)
    
    AMPERE_plot_label = AMPERE_plot_labels[np.where(AMPERE_plot_indexes == AMPERE_plot_index)[0][0]]; #get the label
    AMPERE_plot_label_noUnits = AMPERE_plot_label[0:AMPERE_plot_label.find('[')-1]; #remove the (units)
    
    thruTime_spectral = np.zeros([3,thruTime_num,np.int64(512/2+1)]); #prep a holder for the spectral info
    thruTime_freq = np.zeros([3,thruTime_num,np.int64(512/2+1)]); #prep a holder for the spectral info
    for i in range(0,thruTime_num):
        #TEC NOW
        time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (TEC_timeUnique_timeMatch-dateRange_dayNum_zeroHr[1]*86400) - np.min(thruTime[i,:]) )) == np.abs( (TEC_timeUnique_timeMatch-dateRange_dayNum_zeroHr[1]*86400) - np.min(thruTime[i,:]) ) )[0][0] , \
            np.where(np.min(np.abs( (TEC_timeUnique_timeMatch-dateRange_dayNum_zeroHr[1]*86400) - np.max(thruTime[i,:]) )) == np.abs( (TEC_timeUnique_timeMatch-dateRange_dayNum_zeroHr[1]*86400) - np.max(thruTime[i,:]) ) )[0][0] ) ); #get the indexes for that time cutout range
        
        vTECChunked_keo_cutOut = vTECChunked_keo_lined_timeMatch_HP[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
        avgPt_vTEC_HP_cutOut = avgPt_vTEC_timeMatch_HP[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
        TEC_timeUnique_cutOut = TEC_timeUnique_timeMatch[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
        
        #AMPERE NOW
        time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (AMPERE_timeUnique-dateRange_dayNum_zeroHr[1]*86400) - np.min(thruTime[i,:]) )) == np.abs( (AMPERE_timeUnique-dateRange_dayNum_zeroHr[1]*86400) - np.min(thruTime[i,:]) ) )[0][0] , \
            np.where(np.min(np.abs( (AMPERE_timeUnique-dateRange_dayNum_zeroHr[1]*86400) - np.max(thruTime[i,:]) )) == np.abs( (AMPERE_timeUnique-dateRange_dayNum_zeroHr[1]*86400) - np.max(thruTime[i,:]) ) )[0][0] ) ); #get the indexes for that time cutout range
        
        AMPERE_timeUnique_cutOut = AMPERE_timeUnique[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
        AMPERE_integrate_HP_cutOut = AMPERE_integrate_HP[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
        
        #do some spectral analysis on this
        pwr_TEC_pt = np.sqrt(1/avgPt_vTEC_HP_cutOut.size*np.sum(avgPt_vTEC_HP_cutOut**2)); #estimate power of signal
        pwr_TEC_keo = np.sqrt(1/vTECChunked_keo_cutOut.size*np.sum(vTECChunked_keo_cutOut**2)); #estimate power of signal
        pwr_AMPERE = np.sqrt(1/AMPERE_integrate_HP_cutOut.size*np.sum(AMPERE_integrate_HP_cutOut**2)); #estimate power of signal
        
        #TEC STUFF
        # Fs = 1/(TEC_dataRate/60); #min, zenith time delta in freq form [TEC is on AMPERE data rate now]
        Fs = 1/(AMPERE_time_delta*24*60); #min, misa time delta in freq form
        [freqs_TECpt,Cxx_TECpt] = signal.welch(1/pwr_TEC_pt*avgPt_vTEC_HP_cutOut ,window=window,noverlap=100,nfft=512,fs=Fs);
        [freqs_TECkeo,Cxx_TECkeo] = signal.welch(1/pwr_TEC_keo*vTECChunked_keo_cutOut ,window=window,noverlap=100,nfft=512,fs=Fs);
        
        #AMPERE STUFF
        Fs = 1/(AMPERE_time_delta*24*60); #min, misa time delta in freq form
        [freqs_AMPERE,Cxx_AMPERE] = signal.welch(1/pwr_AMPERE*AMPERE_integrate_HP_cutOut ,window=window,noverlap=100,nfft=512,fs=Fs);
        
        thruTime_spectral[0,i,:] = Cxx_TECpt; #record
        thruTime_spectral[1,i,:] = Cxx_TECkeo; #record
        thruTime_spectral[2,i,:] = Cxx_AMPERE; #record
        thruTime_freq[0,i,:] = freqs_TECpt; #record
        thruTime_freq[1,i,:] = freqs_TECkeo; #record
        thruTime_freq[2,i,:] = freqs_AMPERE; #record
    #END FOR i
    
    
    #PLOT IT UP
    warnings.filterwarnings("ignore", category=RuntimeWarning); #silences warnings about NaNs used in a logical comparisons #yolo
    FLG_sameColorLimits = 0; #if 0 different, if 1 samesies
    xAxisTicks = np.arange( np.round(np.min(1/freqs_TECkeo)/10)*10, plot_periodLim_max+10, 10); #sets the start hr, stop hr, and the step size between (in this case, 2 hr)
    fig, ax = plt.subplots(nrows=1, ncols=3); #use instead of fig because it inits an axis too (I think I dunno)
    figManager = plt.get_current_fig_manager(); #req to maximize
    figManager.window.showMaximized(); #force maximized
    
    if( np.max(thruTime_spectral[:,:,1/freqs_TECkeo <= plot_periodLim_max]) > 200 ):
        rounder = 50; #set to round to every 50
    else:
        rounder = 25; #set to round to every 25
    #END IF
    vMax = np.ceil(np.max(thruTime_spectral[:,:,1/freqs_TECkeo <= plot_periodLim_max])/rounder)*rounder; #get the overall max - FLG_sameColorLimits=0 overrides this
    for i in range(0,ax.shape[0]): #helps automagically plot
        if( FLG_sameColorLimits == 0 ):
            if( np.max(thruTime_spectral[i,:,:]) > 200 ):
                rounder = 50; #set to round to every 50
            else:
                rounder = 25; #set to round to every 25
            #END IF
            vMax = np.ceil(np.max(thruTime_spectral[i,:,:])/rounder)*rounder; #get the max for the plot itself
        #END IF
        #prep colorbar
        divider = make_axes_locatable(ax[i]); #prep to add an axis
        cax = divider.append_axes('right', size='2.0%', pad=0.15); #make a color bar axis
        #Remove the aspect ratio from the basemap so it fills the screen better
        ax[i].set_aspect('auto');
        
        tempTime = np.copy(thruTime[:,0]);
        if( i == 2 ):
            tempTime = tempTime + time_cutout_range_delay_AMPERE; #shift by this
        #END IF
        
        pltHelprX, pltHelprY = np.meshgrid( tempTime, 1/thruTime_freq[i,0,:]);
        #gotta catch inf
        pltHelprY[np.isinf(pltHelprY)] = np.max(pltHelprY[~np.isinf(pltHelprY)])*2; #remove the infs
        im = ax[i].pcolormesh(pltHelprX, pltHelprY,  thruTime_spectral[i,:,:].T , \
            vmin=0, vmax=vMax, cmap='nipy_spectral'); # pseudocolor plot "stretched" to the grid
        cbar = fig.colorbar(im, cax=cax, orientation='vertical'); #create a colorbar using the prev. defined cax
        # cax.yaxis.set_major_formatter(tick.FormatStrFormatter('%.1f')); #force a rounded format
        cbar.ax.tick_params(labelsize=FONT_axisTick);
        cbar.mappable.set_clim(vmin=0, vmax=vMax);
        # cax.yaxis.set_ticks(np.linspace(np.min(TEC_plotLimValu),np.max(TEC_plotLimValu),11)); #create useful tick marks
        ax[i].set_title('Power Spectra for TEC at Zenith - '+str(thruTime_width)+' hr width', \
            fontproperties=FONT_titleFM);
        ax[i].set_yticks(xAxisTicks); #set y axis ticks
        ax[i].set_ylim( (np.min(1/thruTime_freq[i,0,:]), plot_periodLim_max) ); #set the axis limit
        ax[i].set_xlim( (np.min(thruTime[:,0]), np.max(thruTime[:,0])) ); #set the axis limit
        ax[i].set_xticks(np.arange( np.min(thruTime[:,0]), np.max(thruTime[:,0]), 8 )); #set y axis ticks
        
        if( i == 1 ):
            ax[i].set_xlabel('Start Hour - Time in UT [hr] - 0 Hr on '+dateRange_zeroHr_monthName+ \
                ' '+str(dateRange_zeroHr[2])+dateRange_zeroHr_dayPostfix+' | Day '+ \
                str(dateRange_dayNum_zeroHr[1])+', '+str(dateRange_dayNum_zeroHr[0]),fontproperties=FONT_axisLabelFM);
        #END IF
        if( i == 0 ):
            ax[i].set_ylabel('Periods [min]',fontproperties=FONT_axisLabelFM);
        elif( i == 2 ):
            cbar.set_label('Arb. Power'); #tabel the colorbar
            cax.yaxis.label.set_font_properties(FONT_axisLabelFM);
        #END IF
        if( i == 0 ):
            ax[i].set_title('TEC Pt Avg', fontproperties=FONT_titleFM);
        elif( i == 1 ):
            ax[i].set_title('TEC Keo Avg', fontproperties=FONT_titleFM);
        elif( i == 2 ):
            ax[i].set_title(AMPERE_plot_label_noUnits+' offset by '+str(time_cutout_range_delay_AMPERE)+' hrs', fontproperties=FONT_titleFM);
        #END IF
    #END FOR i
    
    
    #final plot adjusting stuff
    fig.subplots_adjust(left = 0.060, right = 0.945, top = 0.96, bottom = 0.075 , hspace = 0.175, wspace = 0.275); #sets padding to small numbers for minimal white space
    # fig.tight_layout(); #function for a tight layout, doesn't seem to do much here
    plt.show(); #req to make plot show up
    warnings.filterwarnings("default", category=RuntimeWarning); #silences warnings about NaNs used in a logical comparisons #yolo
    
#END IF


if( FLG_FFTthruTime_KEOnAMPEREnOMNIintegrated == 1 ):
    from scipy import signal
    from scipy.signal import savgol_filter
    from subfun_timeMatch import subfun_timeMatch
    from subfun_filter import subfun_filter
    from subfun_spectra import subfun_spectra
    from subfun_figFitter import figFitter
    
    #got a few things going
    #TEC on its own time
    #AMPERE on its own time
    #avgPt_vTEC_HP, avgPt_vTEC_time
    
#    window= np.pad(window,(0,512-110),mode='constant')
    # TEC_time_delta = TEC_dataRate/86400; #days, delta of time between readings
    OMNI_time_delta = np.median(np.diff(OMNI_timeUnique)); #sec, delta of time between readings
    
    time_range = np.array( ((time_Ref[0]-dateRange_dayNum_zeroHr[1]*86400) , (time_Ref[-1]-dateRange_dayNum_zeroHr[1]*86400)) ); #make a time range based on the reference time
    time_rangeRound = np.int64(np.floor(np.abs(time_range))*(time_range/np.abs(time_range))); #get the absolute hours - absolute shennanigans are to get floor to floor -11.3 -> -11 and not -12
    thruTime_num = np.int64((np.diff(time_rangeRound).item()-thruTime_width*3600)/(thruTime_step*3600))+1; #number of times the time_rangeRound can be split into the required width and step size
    thruTime = np.zeros( (thruTime_num,2) ); #prep array
    for i in range(0,thruTime_num):
        thruTime[i,0] = time_rangeRound[0]+i*thruTime_step*3600; #get the starting time
        thruTime[i,1] = thruTime[i,0] + thruTime_width*3600; #get the ending time
    #END FOR i
    
    #----PREP TEC KEO STUFF----
    if( settings['TEC']['keo']['keo plot latlong name'] == 'Latitude' ):
        vTECChunked_keo_index = np.where( np.min(np.abs(settings['TEC']['keo']['keo plot latlong chunks'] - avgPt_coords[0,0])) == np.abs(settings['TEC']['keo']['keo plot latlong chunks'] - avgPt_coords[0,0]))[0].item(); #get index nearest to the data we want
    else:
        vTECChunked_keo_index = np.where( np.min(np.abs(settings['TEC']['keo']['keo plot latlong chunks'] - avgPt_coords[0,1])) == np.abs(settings['TEC']['keo']['keo plot latlong chunks'] - avgPt_coords[0,1]))[0].item(); #get index nearest to the data we want
    #END IF
    vTECChunked_keo_lined = np.nanmean(data['TEC']['keo'][:,vTECChunked_keo_index-3:vTECChunked_keo_index+3],axis=1); #get some extra pts as well to make it steadier
    
    #-----Plot AMPERE results as a 1D line-----
    AMPERE_timeUnique_hr = (AMPERE_timeUnique -time_cutout_range_delay_AMPERE*3600 - dateRange_dayNum_zeroHr[1]*86400)/3600; #hr, convert to hr with 0 hr at specified day (already done w/ AMPERE)
    
    if( np.mod(np.round(np.min(AMPERE_timeUnique_hr)),2) == 0 ):
        AMPERE_time_hr_axis_min = np.round(np.min(AMPERE_timeUnique_hr)); #is even, good to go
    else:
        AMPERE_time_hr_axis_min = np.round(np.min(AMPERE_timeUnique_hr))+1; #is odd, make even
    #END IF
    if( np.mod(np.round(np.max(AMPERE_timeUnique_hr)),2) == 0 ):
        AMPERE_time_hr_axis_max = np.round(np.max(AMPERE_timeUnique_hr)); #is even, good to go
    else:
        AMPERE_time_hr_axis_max = np.round(np.max(AMPERE_timeUnique_hr))-1; #is odd, make even
    #END IF
    
    #prep to plot
    if( FLG_FFTthruTime_KEOnAMPEREnOMNIintegrated_upTo90 == 0 ):
        #regular
        kInRange = (data['AMPERE']['lat'] >= np.min(plotLatRange)) & (data['AMPERE']['lat'] <= np.max(plotLatRange)) & \
            (data['AMPERE']['long'] >= np.min(plotLongRange)) & (data['AMPERE']['long'] <= np.max(plotLongRange)); #get data in the range
    elif( FLG_FFTthruTime_KEOnAMPEREnOMNIintegrated_upTo90 == 1 ):
        #max is 90 now
        kInRange = (data['AMPERE']['lat'] >= np.min(plotLatRange)) & (data['AMPERE']['lat'] <= 90) & \
            (data['AMPERE']['long'] >= np.min(plotLongRange)) & (data['AMPERE']['long'] <= np.max(plotLongRange)); #get data in the range
    elif( FLG_FFTthruTime_KEOnAMPEREnOMNIintegrated_upTo90 == 2 ):
        #max is user-defined now
        kInRange = (data['AMPERE']['lat'] >= np.min(plotLatRange)) & (data['AMPERE']['lat'] <= FFTthruTime_KEOnAMPEREnOMNIintegrated_AMPERE_upToVal) & \
            (data['AMPERE']['long'] >= np.min(plotLongRange)) & (data['AMPERE']['long'] <= np.max(plotLongRange)); #get data in the range
    elif( FLG_FFTthruTime_KEOnAMPEREnOMNIintegrated_upTo90 == 3 ):
        if( (np.min(plotLatRange) >= 0) & (np.max(plotLatRange) >= 0) ):
            #northern hemisphere
            kInRange = data['AMPERE']['lat'] >= 0; #get data in the range
        else:
            #southern hemisphere
            kInRange = data['AMPERE']['lat'] <= 0; #get data in the range
        #END IF
    #END IF  
    
    AMPERE_integrate = np.zeros( AMPERE_timeUnique_hr.size , dtype=np.float64); #prep integrated joule heating
    for i in range(AMPERE_timeUnique_hr.size):
        k = AMPERE_timeUnique[i] == data['AMPERE']['time']; #get the right time
        AMPERE_integrate[i] = np.sum((data['AMPERE'][settings_AMPERE['data type']][k&kInRange])); #ergs/(cm^2*sec), get the Joule Heating for the current time stamp
    #END FOR i
    #Can't log 0's, interpolate over them
    # k = np.where( AMPERE_integrate == 0 )[0]; #get where 0's are
    # AMPERE_integrate[k] = 1; #set to 1 to prevent error
    # AMPERE_integrate = np.log10(AMPERE_integrate); #log it
    
    #-----Plot OMNI results as a 1D line-----
    OMNI_timeUnique_hr = (OMNI_timeUnique - dateRange_dayNum_zeroHr[1]*86400)/3600; #hr, convert to hr with 0 hr at specified day
    
    if( np.mod(np.round(np.min(OMNI_timeUnique_hr)),2) == 0 ):
        OMNI_time_hr_axis_min = np.round(np.min(OMNI_timeUnique_hr)); #is even, good to go
    else:
        OMNI_time_hr_axis_min = np.round(np.min(OMNI_timeUnique_hr))+1; #is odd, make even
    #END IF
    if( np.mod(np.round(np.max(OMNI_timeUnique_hr)),2) == 0 ):
        OMNI_time_hr_axis_max = np.round(np.max(OMNI_timeUnique_hr)); #is even, good to go
    else:
        OMNI_time_hr_axis_max = np.round(np.max(OMNI_timeUnique_hr))-1; #is odd, make even
    #END IF
    

    #make sure FFT can happen if it is on
    #if there are data gaps, data needs to be scargled
    # FLG_avg_anyAngle_Scargle_FFT = 0;
    #also NaNs need to be yeeted
    # if( np.isnan(OMNI_jouleHeating_integrate).sum() > 0 ):
    #     k = np.logical_not(np.isnan(OMNI_jouleHeating_integrate));
    #     OMNI_jouleHeating_integrate = OMNI_jouleHeating_integrate[k]; #remove NaNs
    #     OMNI_timeUnique_hr = OMNI_timeUnique_hr[k]; #remove NaNs
    # elif( np.isnan(vTECChunked_keo_lined).sum() > 0 ):
    #     k = np.logical_not(np.isnan(vTECChunked_keo_lined));
    #     vTECChunked_keo_lined = vTECChunked_keo_lined[k]; #remove NaNs
    #     TEC_timeUnique = TEC_timeUnique[k]; #remove NaNs
    #END IF
    
    #Force TEC and OMNI onto 6 min data cadance [which is used by ISR/AMPERE] !!note that their orig data rates cause too much spread-spectrum noise for this type of plot!!
    #---TEC---
    if( np.abs(TEC_dataRate-360) > 0.05 ):
        sixMin_timeUnique = np.arange(0,dateRange_dayNum_full.shape[0]*86400,360); #sec, arange time stamps
        # sixMin_timeUnique = sixMin_timeUnique - dates['date range zero hr hour offset']*3600; #sec, align to 0 hour
        sixMin_timeUnique = sixMin_timeUnique + dates['date range dayNum'][0,1]*86400; #sec, align to date range
        #Match the data in the 1st input (and its time in the 2nd input) to the time scale given in the 3rd input time and return that data and that data's highpassed form
        # _, vTECChunked_keo_lined_timeMatch_HP, TEC_timeUnique_timeMatch = GRITI_TEC_avgPt_timeMatch(vTECChunked_keo_lined,TEC_timeUnique,sixMin_timeUnique,dateRange_dayNum_zeroHr,filter_cutoffPeriod=settings_spectra['filter cutoff period']);
        vTECChunked_keo_lined_timeMatch, TEC_timeUnique_timeMatch = subfun_timeMatch(vTECChunked_keo_lined, TEC_timeUnique, sixMin_timeUnique, timeMatch_delta=360., FLG_removeNaNs=0); #match to 6 min time step
        vTECChunked_keo_lined_timeMatch_HP = subfun_filter( vTECChunked_keo_lined_timeMatch, TEC_timeUnique_timeMatch, 'high-pass', settings_spectra, dataRate = 360., reduceWindow = 0); #high-pass filter
        TEC_dataRate_timeMatch = 360; #overwrite
    else:
    #-----Highpass the data to keep the power within the period range we want-----
        # vTECChunked_keo_lined_timeMatch_HP = subfun_highpass((TEC_timeUnique - dateRange_dayNum_zeroHr[1]*86400), vTECChunked_keo_lined, filter_cutoffPeriod=settings_spectra['filter cutoff period'], filter_order=settings_spectra['filter order'], windowType=settings_spectra['window type'], axisToUse=1);
        vTECChunked_keo_lined_timeMatch_HP = subfun_filter( vTECChunked_keo_lined, TEC_timeUnique, 'high-pass', settings_spectra, dataRate = 360., reduceWindow = 0); #high-pass filter
        TEC_timeUnique_timeMatch = TEC_timeUnique; #set so no errors
        TEC_dataRate_timeMatch = 360; #overwrite
    #END IF
    #---AMPERE---
    if( np.abs(data['AMPERE']['data rate']-360) > 0.05 ):
        sixMin_timeUnique = np.arange(0,dateRange_dayNum_full.shape[0]*86400,360)-time_cutout_range_delay_AMPERE*3600; #sec, arange time stamps
        # sixMin_timeUnique = sixMin_timeUnique - dates['date range zero hr hour offset']*3600; #sec, align to 0 hour
        sixMin_timeUnique = sixMin_timeUnique + dates['date range dayNum'][0,1]*86400; #sec, align to date range
        #Match the data in the 1st input (and its time in the 2nd input) to the time scale given in the 3rd input time and return that data and that data's highpassed form
        # AMPERE_integrate_timeMatch, _, AMPERE_timeUnique_timeMatch = GRITI_TEC_avgPt_timeMatch(AMPERE_integrate,AMPERE_timeUnique,sixMin_timeUnique,dateRange_dayNum_zeroHr,filter_cutoffPeriod=settings_spectra['filter cutoff period']);
        AMPERE_integrate_timeMatch, AMPERE_timeUnique_timeMatch = subfun_timeMatch(AMPERE_integrate, AMPERE_timeUnique, sixMin_timeUnique, timeMatch_delta=360., FLG_removeNaNs=0); #match to 6 min time step
        AMPERE_dataRate_timeMatch = 360; #overwrite
    else:
    #-----Highpass the data to keep the power within the period range we want-----
        AMPERE_integrate_timeMatch = AMPERE_integrate; #set so no errors
        AMPERE_timeUnique_timeMatch = AMPERE_timeUnique; #set so no errors
        AMPERE_dataRate_timeMatch = 360; #overwrite
    #END IF
    #---OMNI---
    if( np.abs(OMNI_time_delta-360) > 0.05 ):
        sixMin_timeUnique = np.arange(0,dateRange_dayNum_full.shape[0]*86400,360); #sec, arange time stamps
        # sixMin_timeUnique = sixMin_timeUnique - dates['date range zero hr hour offset']*3600; #sec, align to 0 hour
        sixMin_timeUnique = sixMin_timeUnique + dates['date range dayNum'][0,1]*86400-time_cutout_range_delay_OMNI*3600; #sec, align to date range
        #adjust OMNI too
        OMNI_data_timeMatch = [[] for i in range(0,len(FLG_FFTthruTime_KEOnAMPEREnOMNIintegrated_OMNIindexes))]; #prep a holder
        for i in range(0,len(FLG_FFTthruTime_KEOnAMPEREnOMNIintegrated_OMNIindexes)):
            # OMNI_data_timeMatch[i], _, OMNI_timeUnique_timeMatch = GRITI_TEC_avgPt_timeMatch(OMNI_data[:,OMNI_dict[FLG_FFTthruTime_KEOnAMPEREnOMNIintegrated_OMNIindexes[i]]],OMNI_timeUnique,sixMin_timeUnique,dateRange_dayNum_zeroHr,filter_cutoffPeriod=settings_spectra['filter cutoff period']);
            OMNI_data_timeMatch[i], OMNI_timeUnique_timeMatch = subfun_timeMatch(OMNI_data[:,OMNI_dict[FLG_FFTthruTime_KEOnAMPEREnOMNIintegrated_OMNIindexes[i]]], OMNI_timeUnique, sixMin_timeUnique, timeMatch_delta=360., FLG_removeNaNs=2); #match to 6 min time step
        #END FOR i
        OMNI_dataRate_timeMatch = 360; #overwrite
    else:
         #fix so it works good
        OMNI_data_timeMatch = [[] for i in range(0,len(FLG_FFTthruTime_KEOnAMPEREnOMNIintegrated_OMNIindexes))]; #prep a holder
        for i in range(0,len(FLG_FFTthruTime_KEOnAMPEREnOMNIintegrated_OMNIindexes)):
            OMNI_data_timeMatch[i] = OMNI_data[:,OMNI_dict[FLG_FFTthruTime_KEOnAMPEREnOMNIintegrated_OMNIindexes[i]]]; #set so no errors
        #END FOR i
        OMNI_timeUnique_timeMatch = OMNI_timeUnique; #set so no errors
        OMNI_dataRate_timeMatch = 360; #overwrite
    #END IF

    #prep the Sav-Gol filter for debiasing
    #---AMPERE---
    AMPERE_integrate_timeMatch_HP = subfun_filter( AMPERE_integrate_timeMatch, AMPERE_timeUnique_timeMatch, 'log10 & high-pass', settings_spectra, dataRate = AMPERE_dataRate_timeMatch, reduceWindow = 0); #sav-gol filter
    #-----Highpass the data to keep the power within the period range we want-----
    # AMPERE_integrate_HP = subfun_highpass(AMPERE_timeUnique_timeMatch*24, AMPERE_integrate_timeMatch, filter_cutoffPeriod=settings_spectra['filter cutoff period'], filter_order=settings_spectra['filter order'], windowType=settings_spectra['window type'], axisToUse=1)
    
    AMPERE_plot_label = AMPERE_plot_labels[np.where(AMPERE_plot_indexes == AMPERE_plot_index)[0][0]]; #get the label
    AMPERE_plot_label_noUnits = AMPERE_plot_label[0:AMPERE_plot_label.find('[')-1]; #remove the (units)
    
    #prep the Sav-Gol filter for debiasing
    #---OMNI---
    #roll through every OMNI needed
    OMNI_dataFilt = np.zeros( [OMNI_timeUnique_timeMatch.size , len(FLG_FFTthruTime_KEOnAMPEREnOMNIintegrated_OMNIindexes)] ); #preallocate
    OMNI_plot_labelSet = []; #prep empty list
    OMNI_plot_labelSet_noUnits = []; #prep empty list
    for i in range(0,len(FLG_FFTthruTime_KEOnAMPEREnOMNIintegrated_OMNIindexes)):
        OMNI_dataFilt[:,i] = subfun_filter( OMNI_data_timeMatch[i], OMNI_timeUnique_timeMatch, 'high-pass', settings_spectra, dataRate = OMNI_dataRate_timeMatch, reduceWindow = 0); #sav-gol filter
        # OMNI_dataFilt[:,i] = subfun_highpass(OMNI_timeUnique_hr, OMNI_dataFilt[:,i], filter_cutoffPeriod=settings_spectra['filter cutoff period'], filter_order=settings_spectra['filter order'], windowType=settings_spectra['window type'], axisToUse=1);
    
        #also get plot labels
        OMNI_plot_labelSet.append(OMNI_dictPlot[OMNI_dict[FLG_FFTthruTime_KEOnAMPEREnOMNIintegrated_OMNIindexes[i]]]); #get the label
        OMNI_plot_labelSet_noUnits.append(OMNI_dictPlot[OMNI_dict[FLG_FFTthruTime_KEOnAMPEREnOMNIintegrated_OMNIindexes[i]]][0:OMNI_dictPlot[OMNI_dict[FLG_FFTthruTime_KEOnAMPEREnOMNIintegrated_OMNIindexes[i]]].find('[')-1]); #remove the (units)
    #END FOR i
    
    thruTime_spectral = [[] for i in range(0,2+len(FLG_FFTthruTime_KEOnAMPEREnOMNIintegrated_OMNIindexes))]; #prep a holder for the spectral info
    thruTime_freq = [[] for i in range(0,2+len(FLG_FFTthruTime_KEOnAMPEREnOMNIintegrated_OMNIindexes))]; #prep a holder for the spectral info
    for i in range(0,2):
        #TEC
        thruTime_spectral[i] = np.zeros([thruTime_num,np.int64(settings_spectra['nfft']['6min']/2+1)]); #preallocate in the list
        thruTime_freq[i] = np.zeros([thruTime_num,np.int64(settings_spectra['nfft']['6min']/2+1)]); #preallocate in the list
    #END FOR i
    for i in range(1,2+len(FLG_FFTthruTime_KEOnAMPEREnOMNIintegrated_OMNIindexes)):
        #OMNI
        thruTime_spectral[i] = np.zeros([thruTime_num,np.int64(settings_spectra['nfft']['6min']/2+1)]); #preallocate in the list
        thruTime_freq[i] = np.zeros([thruTime_num,np.int64(settings_spectra['nfft']['6min']/2+1)]); #preallocate in the list
    #END FOR i
    for i in range(0,thruTime_num):
        #TEC NOW
        time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (TEC_timeUnique_timeMatch-dateRange_dayNum_zeroHr[1]*86400) - np.min(thruTime[i,:]) )) == np.abs( (TEC_timeUnique_timeMatch-dateRange_dayNum_zeroHr[1]*86400) - np.min(thruTime[i,:]) ) )[0][0] , \
            np.where(np.min(np.abs( (TEC_timeUnique_timeMatch-dateRange_dayNum_zeroHr[1]*86400) - np.max(thruTime[i,:]) )) == np.abs( (TEC_timeUnique_timeMatch-dateRange_dayNum_zeroHr[1]*86400) - np.max(thruTime[i,:]) ) )[0][0] ) ); #get the indexes for that time cutout range
        
        vTECChunked_keo_cutOut = vTECChunked_keo_lined_timeMatch_HP[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
        # avgPt_vTEC_HP_cutOut = avgPt_vTEC_timeMatch_HP[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
        TEC_timeUnique_cutOut = TEC_timeUnique_timeMatch[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
        
        #do some spectral analysis on this
        Cxx_TECkeo, freqs_TECkeo = subfun_spectra( vTECChunked_keo_cutOut, TEC_timeUnique_cutOut, 'fft', settings_spectra, dataRate = TEC_dataRate_timeMatch, reduceWindow = 0, returnFreqs = 1); #calc spectra
                        
        thruTime_spectral[0][i,:] = Cxx_TECkeo/60; #record (scale down by sec -> min conversion to get pwr wrt min which is lower so it is easier to plot)
        thruTime_freq[0][i,:] = freqs_TECkeo; #record
        
        #AMPERE NOW
        time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (AMPERE_timeUnique_timeMatch-dateRange_dayNum_zeroHr[1]*86400) - (np.min(thruTime[i,:])-time_cutout_range_delay_AMPERE*3600) )) == np.abs( (AMPERE_timeUnique_timeMatch-dateRange_dayNum_zeroHr[1]*86400) - (np.min(thruTime[i,:])-time_cutout_range_delay_AMPERE*3600) ) )[0][0] , \
            np.where(np.min(np.abs( (AMPERE_timeUnique_timeMatch-dateRange_dayNum_zeroHr[1]*86400) - (np.max(thruTime[i,:])-time_cutout_range_delay_AMPERE*3600) )) == np.abs( (AMPERE_timeUnique_timeMatch-dateRange_dayNum_zeroHr[1]*86400) - (np.max(thruTime[i,:])-time_cutout_range_delay_AMPERE*3600) ) )[0][0] ) ); #get the indexes for that time cutout range
        # time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (AMPERE_timeUnique_timeMatch-dateRange_dayNum_zeroHr[1]*86400) - np.min(thruTime[i,:]) )) == np.abs( (AMPERE_timeUnique_timeMatch-dateRange_dayNum_zeroHr[1]*86400) - np.min(thruTime[i,:]) ) )[0][0] , \
        #     np.where(np.min(np.abs( (AMPERE_timeUnique_timeMatch-dateRange_dayNum_zeroHr[1]*86400) - np.max(thruTime[i,:]) )) == np.abs( (AMPERE_timeUnique_timeMatch-dateRange_dayNum_zeroHr[1]*86400) - np.max(thruTime[i,:]) ) )[0][0] ) ); #get the indexes for that time cutout range
        
        AMPERE_timeUnique_cutOut = AMPERE_timeUnique_timeMatch[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
        AMPERE_integrate_HP_cutOut = AMPERE_integrate_timeMatch_HP[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
        
        Cxx_AMPERE, freqs_AMPERE = subfun_spectra( AMPERE_integrate_HP_cutOut, AMPERE_timeUnique_cutOut, 'fft', settings_spectra, dataRate = AMPERE_dataRate_timeMatch, reduceWindow = 0, returnFreqs = 1); #calc spectra
        
        thruTime_spectral[1][i,:] = Cxx_AMPERE/60; #record (scale down by sec -> min conversion to get pwr wrt min which is lower so it is easier to plot)
        thruTime_freq[1][i,:] = freqs_AMPERE; #record
        
        #OMNI NOW
        time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (OMNI_timeUnique_timeMatch-dateRange_dayNum_zeroHr[1]*86400) - (np.min(thruTime[i,:])-time_cutout_range_delay_OMNI*3600) )) == np.abs( (OMNI_timeUnique_timeMatch-dateRange_dayNum_zeroHr[1]*86400) - (np.min(thruTime[i,:])-time_cutout_range_delay_OMNI*3600) ) )[0][0] , \
            np.where(np.min(np.abs( (OMNI_timeUnique_timeMatch-dateRange_dayNum_zeroHr[1]*86400) - (np.max(thruTime[i,:])-time_cutout_range_delay_OMNI*3600) )) == np.abs( (OMNI_timeUnique_timeMatch-dateRange_dayNum_zeroHr[1]*86400) - (np.max(thruTime[i,:])-time_cutout_range_delay_OMNI*3600) ) )[0][0] ) ); #get the indexes for that time cutout range
        OMNI_timeUnique_cutOut = OMNI_timeUnique_timeMatch[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
        for j in range(0,len(FLG_FFTthruTime_KEOnAMPEREnOMNIintegrated_OMNIindexes)):

            OMNI_dataFilt_cutOut = OMNI_dataFilt[time_cutout_indexes[0]:time_cutout_indexes[1]+1,j];
            
            #do some spectral analysis on this
            Cxx_OMNI, freqs_OMNI = subfun_spectra( OMNI_dataFilt_cutOut, OMNI_timeUnique_cutOut, 'fft', settings_spectra, dataRate = OMNI_dataRate_timeMatch, reduceWindow = 0, returnFreqs = 1); #calc spectra        

            thruTime_spectral[j+2][i,:] = Cxx_OMNI/60; #record (scale down by sec -> min conversion to get pwr wrt min which is lower so it is easier to plot)
            thruTime_freq[j+2][i,:] = freqs_OMNI; #record
        #END FOR j
    #END FOR i
    
    
    #PLOT IT UP
    warnings.filterwarnings("ignore", category=RuntimeWarning); #silences warnings about NaNs used in a logical comparisons #yolo
    FLG_sameColorLimits = 0; #if 0 different, if 1 samesies
    xAxisTicks = np.arange( np.round(np.min(1/freqs_TECkeo)/60/20)*20, settings_spectra['period limit max']/60+20, 20); #sets the start hr, stop hr, and the step size between (in this case, 2 hr)
    fig, ax = plt.subplots(nrows=2, ncols=3); #use instead of fig because it inits an axis too (I think I dunno)
    figManager = plt.get_current_fig_manager(); #req to maximize
    figManager.window.showMaximized(); #force maximized
    
    # if( np.max(thruTime_spectral[:,:,1/freqs_TECkeo <= settings_spectra['period limit max']]) > 200 ):
    #     rounder = 50; #set to round to every 50
    # else:
    #     rounder = 25; #set to round to every 25
    # #END IF
    # vMax = np.ceil(np.max(thruTime_spectral[:,:,1/freqs_TECkeo <= settings_spectra['period limit max']])/rounder)*rounder; #get the overall max - FLG_sameColorLimits=0 overrides this
    cntr = -1; #start cntr
    for i in range(0,ax.shape[0]): #helps automagically plot
        for j in range(0,ax.shape[1]): #helps automagically plot
            cntr += 1; #for counting continuously
            if( FLG_sameColorLimits == 0 ):
                if( np.max(thruTime_spectral[cntr][:,:]) > 200 ):
                    rounder = 50; #set to round to every 50
                elif( np.max(thruTime_spectral[cntr][:,:]) < 0.5 ):
                    rounder = 0.5; #set to round to every 50
                else:
                    rounder = 25; #set to round to every 25
                #END IF
                vMax = np.ceil(np.max(thruTime_spectral[cntr][:,:])/rounder)*rounder; #get the max for the plot itself
            #END IF
            #prep colorbar
            divider = make_axes_locatable(ax[i,j]); #prep to add an axis
            cax = divider.append_axes('right', size='2.0%', pad=0.15); #make a color bar axis
            #Remove the aspect ratio from the basemap so it fills the screen better
            ax[i,j].set_aspect('auto');
            
            tempTime = np.copy(thruTime[:,0]);
            # if( (i == 0) & (j == 1) ):
            #     tempTime = tempTime + time_cutout_range_delay_AMPERE*3600; #shift by this
            # #END IF
            
            pltHelprX, pltHelprY = np.meshgrid( tempTime/3600, 1/thruTime_freq[cntr][0,:]/60);
            #gotta catch inf
            pltHelprY[np.isinf(pltHelprY)] = np.max(pltHelprY[~np.isinf(pltHelprY)])*2; #remove the infs
            im = ax[i,j].pcolormesh(pltHelprX, pltHelprY,  thruTime_spectral[cntr][:,:].T , \
                vmin=0, vmax=vMax, cmap='nipy_spectral'); # pseudocolor plot "stretched" to the grid
            cbar = fig.colorbar(im, cax=cax, orientation='vertical'); #create a colorbar using the prev. defined cax
            # cax.yaxis.set_major_formatter(tick.FormatStrFormatter('%.1f')); #force a rounded format
            cbar.ax.tick_params(labelsize=FONT_axisTick);
            cbar.mappable.set_clim(vmin=0, vmax=vMax);
            # cax.yaxis.set_ticks(np.linspace(np.min(TEC_plotLimValu),np.max(TEC_plotLimValu),11)); #create useful tick marks
            ax[i,j].set_title('Power Spectra for TEC at Zenith - '+str(thruTime_width)+' hr width', \
                fontproperties=FONT_titleFM);
            ax[i,j].set_yticks(xAxisTicks); #set y axis ticks
            ax[i,j].set_ylim( (np.min(1/thruTime_freq[cntr][0,:])/60, settings_spectra['period limit max']/60) ); #set the axis limit
            ax[i,j].set_xlim( (np.min(thruTime[:,0])/3600, np.max(thruTime[:,0])/3600) ); #set the axis limit
            ax[i,j].set_xticks(np.arange( np.min(thruTime[:,0])/3600, np.max(thruTime[:,0])/3600, 8 )); #set y axis ticks
            
            if( (i == (ax.shape[0]-1) ) & (j == (ax.shape[1]-1)//2) ):
                ax[i,j].set_xlabel('Start Hour - Time in UT [hr] - 0 Hr on '+dateRange_zeroHr_monthName+ \
                    ' '+str(dateRange_zeroHr[2])+dateRange_zeroHr_dayPostfix+' | Day '+ \
                    str(dateRange_dayNum_zeroHr[1])+', '+str(dateRange_dayNum_zeroHr[0]),fontproperties=FONT_axisLabelFM);
            #END IF
            if( j == 0 ):
                ax[i,j].set_ylabel('Periods [min]',fontproperties=FONT_axisLabelFM);
            elif( j == (ax.shape[1] - 1) ):
                cbar.set_label('Arb. Power'); #tabel the colorbar
                cax.yaxis.label.set_font_properties(FONT_axisLabelFM);
            #END IF
            if( (i == 0) & (j == 0) ):
                ax[i,j].set_title('TEC Keo', fontproperties=FONT_titleFM);
            elif( (i == 0) & (j == 1) ):
                ax[i,j].set_title(AMPERE_plot_label_noUnits+' offset by '+str(time_cutout_range_delay_AMPERE)+' hrs', fontproperties=FONT_titleFM);
            else:
                ax[i,j].set_title(OMNI_plot_labelSet_noUnits[cntr-2]+' offset by '+str(time_cutout_range_delay_OMNI)+' hrs', fontproperties=FONT_titleFM);
            #END IF
        #END FOR j
    #END FOR i
    
    #final plot adjusting stuff
    fig.subplots_adjust(hspace = 0.175, wspace = 0.275); #pad the plot spacing correctly
    figFitter(fig); #fit that fig fast
    # fig.subplots_adjust(left = 0.060, right = 0.945, top = 0.96, bottom = 0.075 , hspace = 0.175, wspace = 0.275); #sets padding to small numbers for minimal white space
    # fig.tight_layout(); #function for a tight layout, doesn't seem to do much here
    plt.show(); #req to make plot show up
    warnings.filterwarnings("default", category=RuntimeWarning); #silences warnings about NaNs used in a logical comparisons #yolo
    
#END IF

if( FLG_FFTthruTime_KEOnOMNIintegrated == 1 ):
    from scipy import signal
    from scipy.signal import savgol_filter
    from subfun_timeMatch import subfun_timeMatch
    from subfun_filter import subfun_filter
    from subfun_spectra import subfun_spectra
    from subfun_figFitter import figFitter
    
    #got a few things going
    #TEC on its own time
    #AMPERE on its own time
    #avgPt_vTEC_HP, avgPt_vTEC_time
    
#    window= np.pad(window,(0,512-110),mode='constant')
    # TEC_time_delta = TEC_dataRate/86400; #days, delta of time between readings
    OMNI_time_delta = np.median(np.diff(OMNI_timeUnique)); #sec, delta of time between readings
    
    time_range = np.array( ((time_Ref[0]-dateRange_dayNum_zeroHr[1]*86400) , (time_Ref[-1]-dateRange_dayNum_zeroHr[1]*86400)) ); #make a time range based on the reference time
    time_rangeRound = np.int64(np.floor(np.abs(time_range))*(time_range/np.abs(time_range))); #get the absolute hours - absolute shennanigans are to get floor to floor -11.3 -> -11 and not -12
    thruTime_num = np.int64((np.diff(time_rangeRound).item()-thruTime_width*3600)/(thruTime_step*3600))+1; #number of times the time_rangeRound can be split into the required width and step size
    thruTime = np.zeros( (thruTime_num,2) ); #prep array
    for i in range(0,thruTime_num):
        thruTime[i,0] = time_rangeRound[0]+i*thruTime_step*3600; #get the starting time
        thruTime[i,1] = thruTime[i,0] + thruTime_width*3600; #get the ending time
    #END FOR i
    
    #----PREP TEC KEO STUFF----
    if( settings['TEC']['keo']['keo plot latlong name'] == 'Latitude' ):
        vTECChunked_keo_index = np.where( np.min(np.abs(settings['TEC']['keo']['keo plot latlong chunks'] - avgPt_coords[0,0])) == np.abs(settings['TEC']['keo']['keo plot latlong chunks'] - avgPt_coords[0,0]))[0].item(); #get index nearest to the data we want
    else:
        vTECChunked_keo_index = np.where( np.min(np.abs(settings['TEC']['keo']['keo plot latlong chunks'] - avgPt_coords[0,1])) == np.abs(settings['TEC']['keo']['keo plot latlong chunks'] - avgPt_coords[0,1]))[0].item(); #get index nearest to the data we want
    #END IF
    vTECChunked_keo_lined = np.nanmean(data['TEC']['keo'][:,vTECChunked_keo_index-3:vTECChunked_keo_index+3],axis=1); #get some extra pts as well to make it steadier
        
    #-----Plot OMNI results as a 1D line-----
    OMNI_timeUnique_hr = (OMNI_timeUnique - dateRange_dayNum_zeroHr[1]*86400)/3600; #hr, convert to hr with 0 hr at specified day
    
    if( np.mod(np.round(np.min(OMNI_timeUnique_hr)),2) == 0 ):
        OMNI_time_hr_axis_min = np.round(np.min(OMNI_timeUnique_hr)); #is even, good to go
    else:
        OMNI_time_hr_axis_min = np.round(np.min(OMNI_timeUnique_hr))+1; #is odd, make even
    #END IF
    if( np.mod(np.round(np.max(OMNI_timeUnique_hr)),2) == 0 ):
        OMNI_time_hr_axis_max = np.round(np.max(OMNI_timeUnique_hr)); #is even, good to go
    else:
        OMNI_time_hr_axis_max = np.round(np.max(OMNI_timeUnique_hr))-1; #is odd, make even
    #END IF
    
    #make sure FFT can happen if it is on
    #if there are data gaps, data needs to be scargled
    # FLG_avg_anyAngle_Scargle_FFT = 0;
    #also NaNs need to be yeeted
    # if( np.isnan(OMNI_jouleHeating_integrate).sum() > 0 ):
    #     k = np.logical_not(np.isnan(OMNI_jouleHeating_integrate));
    #     OMNI_jouleHeating_integrate = OMNI_jouleHeating_integrate[k]; #remove NaNs
    #     OMNI_timeUnique_hr = OMNI_timeUnique_hr[k]; #remove NaNs
    # elif( np.isnan(vTECChunked_keo_lined).sum() > 0 ):
    #     k = np.logical_not(np.isnan(vTECChunked_keo_lined));
    #     vTECChunked_keo_lined = vTECChunked_keo_lined[k]; #remove NaNs
    #     TEC_timeUnique = TEC_timeUnique[k]; #remove NaNs
    #END IF
    
    #Force TEC and OMNI onto 6 min data cadance [which is used by ISR/AMPERE] !!note that their orig data rates cause too much spread-spectrum noise for this type of plot!!
    #---TEC---
    if( np.abs(TEC_dataRate-360) > 0.05 ):
        sixMin_timeUnique = np.arange(0,dateRange_dayNum_full.shape[0]*86400,360); #sec, arange time stamps
        # sixMin_timeUnique = sixMin_timeUnique - dates['date range zero hr hour offset']*3600; #sec, align to 0 hour
        sixMin_timeUnique = sixMin_timeUnique + dates['date range dayNum'][0,1]*86400; #sec, align to date range
        #Match the data in the 1st input (and its time in the 2nd input) to the time scale given in the 3rd input time and return that data and that data's highpassed form
        # _, vTECChunked_keo_lined_timeMatch_HP, TEC_timeUnique_timeMatch = GRITI_TEC_avgPt_timeMatch(vTECChunked_keo_lined,TEC_timeUnique,sixMin_timeUnique,dateRange_dayNum_zeroHr,filter_cutoffPeriod=settings_spectra['filter cutoff period']);
        vTECChunked_keo_lined_timeMatch, TEC_timeUnique_timeMatch = subfun_timeMatch(vTECChunked_keo_lined, TEC_timeUnique, sixMin_timeUnique, timeMatch_delta=360., FLG_removeNaNs=0); #match to 6 min time step
        vTECChunked_keo_lined_timeMatch_HP = subfun_filter( vTECChunked_keo_lined_timeMatch, TEC_timeUnique_timeMatch, 'high-pass', settings_spectra, dataRate = 360., reduceWindow = 0); #high-pass filter
        TEC_dataRate_timeMatch = 360; #overwrite
    else:
    #-----Highpass the data to keep the power within the period range we want-----
        # vTECChunked_keo_lined_timeMatch_HP = subfun_highpass((TEC_timeUnique - dateRange_dayNum_zeroHr[1]*86400), vTECChunked_keo_lined, filter_cutoffPeriod=settings_spectra['filter cutoff period'], filter_order=settings_spectra['filter order'], windowType=settings_spectra['window type'], axisToUse=1);
        vTECChunked_keo_lined_timeMatch_HP = subfun_filter( vTECChunked_keo_lined, TEC_timeUnique, 'high-pass', settings_spectra, dataRate = 360., reduceWindow = 0); #high-pass filter
        TEC_timeUnique_timeMatch = TEC_timeUnique; #set so no errors
        TEC_dataRate_timeMatch = 360; #overwrite
    #END IF
    #---OMNI---
    if( np.abs(OMNI_time_delta-360) > 0.05 ):
        sixMin_timeUnique = np.arange(0,dateRange_dayNum_full.shape[0]*86400,360); #sec, arange time stamps
        # sixMin_timeUnique = sixMin_timeUnique - dates['date range zero hr hour offset']*3600; #sec, align to 0 hour
        sixMin_timeUnique = sixMin_timeUnique + dates['date range dayNum'][0,1]*86400-time_cutout_range_delay_OMNI*3600; #sec, align to date range
        #adjust OMNI too
        OMNI_data_timeMatch = [[] for i in range(0,len(FLG_FFTthruTime_KEOnAMPEREnOMNIintegrated_OMNIindexes))]; #prep a holder
        for i in range(0,len(FLG_FFTthruTime_KEOnAMPEREnOMNIintegrated_OMNIindexes)):
            # OMNI_data_timeMatch[i], _, OMNI_timeUnique_timeMatch = GRITI_TEC_avgPt_timeMatch(OMNI_data[:,OMNI_dict[FLG_FFTthruTime_KEOnAMPEREnOMNIintegrated_OMNIindexes[i]]],OMNI_timeUnique,sixMin_timeUnique,dateRange_dayNum_zeroHr,filter_cutoffPeriod=settings_spectra['filter cutoff period']);
            OMNI_data_timeMatch[i], OMNI_timeUnique_timeMatch = subfun_timeMatch(OMNI_data[:,OMNI_dict[FLG_FFTthruTime_KEOnAMPEREnOMNIintegrated_OMNIindexes[i]]], OMNI_timeUnique, sixMin_timeUnique, timeMatch_delta=360., FLG_removeNaNs=2); #match to 6 min time step
        #END FOR i
        OMNI_dataRate_timeMatch = 360; #overwrite
    else:
         #fix so it works good
        OMNI_data_timeMatch = [[] for i in range(0,len(FLG_FFTthruTime_KEOnAMPEREnOMNIintegrated_OMNIindexes))]; #prep a holder
        for i in range(0,len(FLG_FFTthruTime_KEOnAMPEREnOMNIintegrated_OMNIindexes)):
            OMNI_data_timeMatch[i] = OMNI_data[:,OMNI_dict[FLG_FFTthruTime_KEOnAMPEREnOMNIintegrated_OMNIindexes[i]]]; #set so no errors
        #END FOR i
        OMNI_timeUnique_timeMatch = OMNI_timeUnique; #set so no errors
        OMNI_dataRate_timeMatch = 360; #overwrite
    #END IF

    #---OMNI---
    #roll through every OMNI needed
    OMNI_dataFilt = np.zeros( [OMNI_timeUnique_timeMatch.size , len(FLG_FFTthruTime_KEOnAMPEREnOMNIintegrated_OMNIindexes)] ); #preallocate
    OMNI_plot_labelSet = []; #prep empty list
    OMNI_plot_labelSet_noUnits = []; #prep empty list
    for i in range(0,len(FLG_FFTthruTime_KEOnAMPEREnOMNIintegrated_OMNIindexes)):
        OMNI_dataFilt[:,i] = subfun_filter( OMNI_data_timeMatch[i], OMNI_timeUnique_timeMatch, 'high-pass', settings_spectra, dataRate = OMNI_dataRate_timeMatch, reduceWindow = 0); #sav-gol filter
        # OMNI_dataFilt[:,i] = subfun_highpass(OMNI_timeUnique_hr, OMNI_dataFilt[:,i], filter_cutoffPeriod=settings_spectra['filter cutoff period'], filter_order=settings_spectra['filter order'], windowType=settings_spectra['window type'], axisToUse=1);
    
        #also get plot labels
        OMNI_plot_labelSet.append(OMNI_dictPlot[OMNI_dict[FLG_FFTthruTime_KEOnAMPEREnOMNIintegrated_OMNIindexes[i]]]); #get the label
        OMNI_plot_labelSet_noUnits.append(OMNI_dictPlot[OMNI_dict[FLG_FFTthruTime_KEOnAMPEREnOMNIintegrated_OMNIindexes[i]]][0:OMNI_dictPlot[OMNI_dict[FLG_FFTthruTime_KEOnAMPEREnOMNIintegrated_OMNIindexes[i]]].find('[')-1]); #remove the (units)
    #END FOR i
    
    thruTime_spectral = [[] for i in range(0,2+len(FLG_FFTthruTime_KEOnAMPEREnOMNIintegrated_OMNIindexes))]; #prep a holder for the spectral info
    thruTime_freq = [[] for i in range(0,2+len(FLG_FFTthruTime_KEOnAMPEREnOMNIintegrated_OMNIindexes))]; #prep a holder for the spectral info
    for i in range(0,2):
        #TEC
        thruTime_spectral[i] = np.zeros([thruTime_num,np.int64(settings_spectra['nfft']['6min']/2+1)]); #preallocate in the list
        thruTime_freq[i] = np.zeros([thruTime_num,np.int64(settings_spectra['nfft']['6min']/2+1)]); #preallocate in the list
    #END FOR i
    for i in range(1,2+len(FLG_FFTthruTime_KEOnAMPEREnOMNIintegrated_OMNIindexes)):
        #OMNI
        thruTime_spectral[i] = np.zeros([thruTime_num,np.int64(settings_spectra['nfft']['6min']/2+1)]); #preallocate in the list
        thruTime_freq[i] = np.zeros([thruTime_num,np.int64(settings_spectra['nfft']['6min']/2+1)]); #preallocate in the list
    #END FOR i
    for i in range(0,thruTime_num):
        #TEC NOW
        time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (TEC_timeUnique_timeMatch-dateRange_dayNum_zeroHr[1]*86400) - np.min(thruTime[i,:]) )) == np.abs( (TEC_timeUnique_timeMatch-dateRange_dayNum_zeroHr[1]*86400) - np.min(thruTime[i,:]) ) )[0][0] , \
            np.where(np.min(np.abs( (TEC_timeUnique_timeMatch-dateRange_dayNum_zeroHr[1]*86400) - np.max(thruTime[i,:]) )) == np.abs( (TEC_timeUnique_timeMatch-dateRange_dayNum_zeroHr[1]*86400) - np.max(thruTime[i,:]) ) )[0][0] ) ); #get the indexes for that time cutout range
        
        vTECChunked_keo_cutOut = vTECChunked_keo_lined_timeMatch_HP[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
        # avgPt_vTEC_HP_cutOut = avgPt_vTEC_timeMatch_HP[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
        TEC_timeUnique_cutOut = TEC_timeUnique_timeMatch[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
        
        #do some spectral analysis on this
        Cxx_TECkeo, freqs_TECkeo = subfun_spectra( vTECChunked_keo_cutOut, TEC_timeUnique_cutOut, 'fft', settings_spectra, dataRate = TEC_dataRate_timeMatch, reduceWindow = 0, returnFreqs = 1); #calc spectra
                        
        thruTime_spectral[0][i,:] = Cxx_TECkeo/60; #record (scale down by sec -> min conversion to get pwr wrt min which is lower so it is easier to plot)
        thruTime_freq[0][i,:] = freqs_TECkeo; #record
        
        #OMNI NOW
        time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (OMNI_timeUnique_timeMatch-dateRange_dayNum_zeroHr[1]*86400) - (np.min(thruTime[i,:])-time_cutout_range_delay_OMNI*3600) )) == np.abs( (OMNI_timeUnique_timeMatch-dateRange_dayNum_zeroHr[1]*86400) - (np.min(thruTime[i,:])-time_cutout_range_delay_OMNI*3600) ) )[0][0] , \
            np.where(np.min(np.abs( (OMNI_timeUnique_timeMatch-dateRange_dayNum_zeroHr[1]*86400) - (np.max(thruTime[i,:])-time_cutout_range_delay_OMNI*3600) )) == np.abs( (OMNI_timeUnique_timeMatch-dateRange_dayNum_zeroHr[1]*86400) - (np.max(thruTime[i,:])-time_cutout_range_delay_OMNI*3600) ) )[0][0] ) ); #get the indexes for that time cutout range
        OMNI_timeUnique_cutOut = OMNI_timeUnique_timeMatch[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
        for j in range(0,len(FLG_FFTthruTime_KEOnAMPEREnOMNIintegrated_OMNIindexes)):

            OMNI_dataFilt_cutOut = OMNI_dataFilt[time_cutout_indexes[0]:time_cutout_indexes[1]+1,j];
            
            #do some spectral analysis on this
            Cxx_OMNI, freqs_OMNI = subfun_spectra( OMNI_dataFilt_cutOut, OMNI_timeUnique_cutOut, 'fft', settings_spectra, dataRate = OMNI_dataRate_timeMatch, reduceWindow = 0, returnFreqs = 1); #calc spectra        

            thruTime_spectral[j+1][i,:] = Cxx_OMNI/60; #record (scale down by sec -> min conversion to get pwr wrt min which is lower so it is easier to plot)
            thruTime_freq[j+1][i,:] = freqs_OMNI; #record
        #END FOR j
    #END FOR i
    
    
    #PLOT IT UP
    warnings.filterwarnings("ignore", category=RuntimeWarning); #silences warnings about NaNs used in a logical comparisons #yolo
    FLG_sameColorLimits = 0; #if 0 different, if 1 samesies
    xAxisTicks = np.arange( np.round(np.min(1/freqs_TECkeo)/60/20)*20, settings_spectra['period limit max']/60+20, 20); #sets the start hr, stop hr, and the step size between (in this case, 2 hr)
    fig, ax = plt.subplots(nrows=2, ncols=3); #use instead of fig because it inits an axis too (I think I dunno)
    figManager = plt.get_current_fig_manager(); #req to maximize
    figManager.window.showMaximized(); #force maximized
    
    # if( np.max(thruTime_spectral[:,:,1/freqs_TECkeo <= settings_spectra['period limit max']]) > 200 ):
    #     rounder = 50; #set to round to every 50
    # else:
    #     rounder = 25; #set to round to every 25
    # #END IF
    # vMax = np.ceil(np.max(thruTime_spectral[:,:,1/freqs_TECkeo <= settings_spectra['period limit max']])/rounder)*rounder; #get the overall max - FLG_sameColorLimits=0 overrides this
    cntr = -1; #start cntr
    for i in range(0,ax.shape[0]): #helps automagically plot
        for j in range(0,ax.shape[1]): #helps automagically plot
            cntr += 1; #for counting continuously
            if( FLG_sameColorLimits == 0 ):
                if( np.max(thruTime_spectral[cntr][:,:]) > 200 ):
                    rounder = 50; #set to round to every 50
                elif( np.max(thruTime_spectral[cntr][:,:]) < 0.5 ):
                    rounder = 0.5; #set to round to every 50
                else:
                    rounder = 25; #set to round to every 25
                #END IF
                vMax = np.ceil(np.max(thruTime_spectral[cntr][:,:])/rounder)*rounder; #get the max for the plot itself
            #END IF
            #prep colorbar
            divider = make_axes_locatable(ax[i,j]); #prep to add an axis
            cax = divider.append_axes('right', size='2.0%', pad=0.15); #make a color bar axis
            #Remove the aspect ratio from the basemap so it fills the screen better
            ax[i,j].set_aspect('auto');
            
            tempTime = np.copy(thruTime[:,0]);
            
            if( np.all(thruTime_freq[cntr][0,:] == 0) == False ):
                pltHelprX, pltHelprY = np.meshgrid( tempTime/3600, 1/thruTime_freq[cntr][0,:]/60);
                #gotta catch inf
                pltHelprY[np.isinf(pltHelprY)] = np.max(pltHelprY[~np.isinf(pltHelprY)])*2; #remove the infs
                im = ax[i,j].pcolormesh(pltHelprX, pltHelprY,  thruTime_spectral[cntr][:,:].T , \
                    vmin=0, vmax=vMax, cmap='nipy_spectral'); # pseudocolor plot "stretched" to the grid
                cbar = fig.colorbar(im, cax=cax, orientation='vertical'); #create a colorbar using the prev. defined cax
                # cax.yaxis.set_major_formatter(tick.FormatStrFormatter('%.1f')); #force a rounded format
                cbar.ax.tick_params(labelsize=FONT_axisTick);
                cbar.mappable.set_clim(vmin=0, vmax=vMax);
                # cax.yaxis.set_ticks(np.linspace(np.min(TEC_plotLimValu),np.max(TEC_plotLimValu),11)); #create useful tick marks
                ax[i,j].set_title('Power Spectra for TEC at Zenith - '+str(thruTime_width)+' hr width', \
                    fontproperties=FONT_titleFM);
                ax[i,j].set_yticks(xAxisTicks); #set y axis ticks
                ax[i,j].set_ylim( (np.min(1/thruTime_freq[cntr][0,:])/60, settings_spectra['period limit max']/60) ); #set the axis limit
                ax[i,j].set_xlim( (np.min(thruTime[:,0])/3600, np.max(thruTime[:,0])/3600) ); #set the axis limit
                ax[i,j].set_xticks(np.arange( np.min(thruTime[:,0])/3600, np.max(thruTime[:,0])/3600, 8 )); #set y axis ticks
                
                if( (i == (ax.shape[0]-1) ) & (j == (ax.shape[1]-1)//2) ):
                    ax[i,j].set_xlabel('Start Hour - Time in UT [hr] - 0 Hr on '+dateRange_zeroHr_monthName+ \
                        ' '+str(dateRange_zeroHr[2])+dateRange_zeroHr_dayPostfix+' | Day '+ \
                        str(dateRange_dayNum_zeroHr[1])+', '+str(dateRange_dayNum_zeroHr[0]),fontproperties=FONT_axisLabelFM);
                #END IF
                if( j == 0 ):
                    ax[i,j].set_ylabel('Periods [min]',fontproperties=FONT_axisLabelFM);
                elif( j == (ax.shape[1] - 1) ):
                    cbar.set_label('Arb. Power'); #tabel the colorbar
                    cax.yaxis.label.set_font_properties(FONT_axisLabelFM);
                #END IF
                if( (i == 0) & (j == 0) ):
                    ax[i,j].set_title('TEC Keo', fontproperties=FONT_titleFM);
                else:
                    ax[i,j].set_title(OMNI_plot_labelSet_noUnits[cntr-1]+' offset by '+str(time_cutout_range_delay_OMNI)+' hrs', fontproperties=FONT_titleFM);
                #END IF
            #END IF
        #END FOR j
    #END FOR i
    
    #final plot adjusting stuff
    fig.subplots_adjust(hspace = 0.175, wspace = 0.275); #pad the plot spacing correctly
    figFitter(fig); #fit that fig fast
    # fig.subplots_adjust(left = 0.060, right = 0.945, top = 0.96, bottom = 0.075 , hspace = 0.175, wspace = 0.275); #sets padding to small numbers for minimal white space
    # fig.tight_layout(); #function for a tight layout, doesn't seem to do much here
    plt.show(); #req to make plot show up
    warnings.filterwarnings("default", category=RuntimeWarning); #silences warnings about NaNs used in a logical comparisons #yolo
    
#END IF

#****************************************************************ISR ANALYSIS****************************************************************

if( FLG_ISR_plot_POPL_HP == 1 ): #plot some of that ISR data on its own to check it out
    GRITI_ISR_Haystack_plot_POPL_HP(Zenith_time,Zenith_height,Zenith_POPL_hp, \
      MISA_time,MISA_height,MISA_POPL_hp, \
      filter_cutoffPeriod,ISR_RTI_heightLimValues,ISR_POPL_plotLimValu, \
      dateRange,dateRange_dayNum,dateRange_dayNum_zeroHr,FONT_titleFM,FONT_axisTick,FONT_axisLabelFM);
#END IF

if( (FLG_ISR_plot_POPL_HP == 1) & (FLG_fancyPlot == 1) ): #plot some of that ISR data on its own to check it out
    GRITI_ISR_Haystack_fancyPlot_POPL_HP_wDayNite(Zenith_time,Zenith_height,Zenith_POPL_hp, \
        MISA_time,MISA_height,MISA_POPL_hp,filter_cutoffPeriod,ISR_RTI_heightLimValues,ISR_POPL_plotLimValu, \
        dateRange_full,dateRange_dayNum_full,dateRange_dayNum_zeroHr,dateRange_zeroHr, dateRange_zeroHr_monthName, \
        dateRange_zeroHr_dayPostfix, latLong_ref[0],FONT_grandioseFM, FONT_titleFM, FONT_axisLabelFM, FONT_axisTick, \
        PLOT_lineWidth, folder, journal_width_2C,journal_height_max,journal_dpi);
#END IF
    
if( FLG_ISR_plot_POPL_HP_cutOut == 1 ):
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , \
        np.where(np.min(np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range

    Zenith_time_cutOut = Zenith_time[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    Zenith_POPL_hp_cutOut = Zenith_POPL_hp[:,time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , \
        np.where(np.min(np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range
                                    
    MISA_time_cutOut = MISA_time[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    MISA_POPL_hp_cutOut = MISA_POPL_hp[:,time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    
    GRITI_ISR_Haystack_plot_POPL_HP_cutOut(Zenith_time_cutOut,Zenith_height,\
        Zenith_POPL_hp_cutOut,MISA_time_cutOut,MISA_height,MISA_POPL_hp_cutOut,filter_cutoffPeriod,ISR_RTI_heightLimValues, \
        ISR_POPL_plotLimValu,time_cutout_range,dateRange,dateRange_dayNum,dateRange_dayNum_zeroHr, \
        FONT_titleFM,FONT_axisTick,FONT_axisLabelFM);
#END IF  
    
if( FLG_ISR_Pokerflat_plot_POPL_HP == 1 ): #plot some of that ISR data on its own to check it out
    GRITI_ISR_Pokerflat_plot_POPL_HP(PFISR_time,PFISR_height,PFISR_POPL_hp,PFISR_el,PFISR_az, \
      filter_cutoffPeriod,ISR_Pokerflat_RTI_heightLimValues,ISR_POPL_plotLimValu, \
      dateRange,dateRange_dayNum,dateRange_dayNum_zeroHr,FONT_titleFM,FONT_axisTick,FONT_axisLabelFM);
#END IF

if( FLG_ISR_plot_POPL == 1 ): #plot some of that ISR data on its own to check it out
    GRITI_ISR_Haystack_plot_POPL(Zenith_time,Zenith_height,Zenith_POPL, \
       MISA_time,MISA_height,MISA_POPL, \
       filter_cutoffPeriod,ISR_RTI_heightLimValues, \
       dateRange,dateRange_dayNum,dateRange_dayNum_zeroHr,FONT_titleFM,FONT_axisTick,FONT_axisLabelFM);
#END IF

if( FLG_ISR_Pokerflat_plot_POPL == 1 ): #plot some of that ISR data on its own to check it out
    GRITI_ISR_Pokerflat_plot_POPL(PFISR_time,PFISR_height,PFISR_POPL,PFISR_el,PFISR_az, \
      filter_cutoffPeriod,ISR_Pokerflat_RTI_heightLimValues,  \
      dateRange,dateRange_dayNum,dateRange_dayNum_zeroHr,FONT_titleFM,FONT_axisTick,FONT_axisLabelFM);
#END IF
    
if( FLG_ISR_plot_POPL_limited == 1 ): #plot some of that ISR data on its own to check it out
    GRITI_ISR_Haystack_plot_POPL_limited(Zenith_time,Zenith_height,Zenith_POPL, \
       MISA_time,MISA_height,MISA_POPL, \
       filter_cutoffPeriod,ISR_RTI_heightLimValues,ISR_POPL_plotLimValu_noFilt, \
       dateRange,dateRange_dayNum,dateRange_dayNum_zeroHr,FONT_titleFM,FONT_axisTick,FONT_axisLabelFM);
#END IF
    
if( FLG_ISR_Pokerflat_plot_POPL_limited == 1 ): #plot some of that ISR data on its own to check it out
    GRITI_ISR_Pokerflat_plot_POPL_limited(PFISR_time,PFISR_height,PFISR_POPL,PFISR_el,PFISR_az, \
      filter_cutoffPeriod,ISR_Pokerflat_RTI_heightLimValues,ISR_POPL_plotLimValu_noFilt,  \
      dateRange,dateRange_dayNum,dateRange_dayNum_zeroHr,FONT_titleFM,FONT_axisTick,FONT_axisLabelFM);
#END IF

if( FLG_ISR_plot_POPL_ScargleSet == 1 ):
    GRITI_ISR_Haystack_plot_POPL_scargleSet(Zenith_time,Zenith_POPL,Zenith_POPL_hp,Zenith_filtHeight, \
        MISA_time,MISA_POPL,MISA_POPL_hp,MISA_filtHeight,pointAltitude,plot_periodLim_max, \
        dateRange,dateRange_dayNum,dateRange_dayNum_zeroHr,FONT_titleFM,FONT_axisTick,FONT_axisLabelFM);
#END IF
    
if( FLG_ISR_plot_POPL_FFTSet == 1 ):
    GRITI_ISR_Haystack_plot_POPL_FFTSet(Zenith_time,Zenith_POPL,Zenith_POPL_hp,Zenith_filtHeight, \
        MISA_time,MISA_POPL,MISA_POPL_hp,MISA_filtHeight,pointAltitude,plot_periodLim_max, \
        dateRange,dateRange_dayNum,dateRange_dayNum_zeroHr,FONT_titleFM,FONT_axisTick,FONT_axisLabelFM);
#END IF

if( FLG_ISR_plot_SNR_HP == 1 ): #plot some of that ISR data on its own to check it out
    GRITI_ISR_Haystack_plot_SNR_HP(Zenith_time,Zenith_height,Zenith_SNR_hp, \
      MISA_time,MISA_height,MISA_SNR_hp, \
      filter_cutoffPeriod,ISR_RTI_heightLimValues,ISR_plotLimValu, \
      dateRange,dateRange_dayNum,dateRange_dayNum_zeroHr,FONT_titleFM,FONT_axisTick,FONT_axisLabelFM);
#END IF                                 

if( FLG_ISR_plot_SNR == 1 ): #plot some of that ISR data on its own to check it out
    GRITI_ISR_Haystack_plot_SNR(Zenith_time,Zenith_height,Zenith_SNR, \
       MISA_time,MISA_height,MISA_SNR, \
       filter_cutoffPeriod,ISR_RTI_heightLimValues, \
       dateRange,dateRange_dayNum,dateRange_dayNum_zeroHr,FONT_titleFM,FONT_axisTick,FONT_axisLabelFM);
#END IF
    
if( FLG_ISR_plot_SNR_limited == 1 ): #plot some of that ISR data on its own to check it out
    GRITI_ISR_Haystack_plot_SNR_limited(Zenith_time,Zenith_height,Zenith_SNR, \
       MISA_time,MISA_height,MISA_SNR, \
       filter_cutoffPeriod,ISR_RTI_heightLimValues,ISR_plotLimValu, \
       dateRange,dateRange_dayNum,dateRange_dayNum_zeroHr,FONT_titleFM,FONT_axisTick,FONT_axisLabelFM);
#END IF

if( FLG_ISR_plot_ScargleSet == 1 ):
    GRITI_ISR_Haystack_plot_scargleSet(Zenith_time,Zenith_SNR,Zenith_SNR_hp,Zenith_filtHeight, \
        MISA_time,MISA_SNR,MISA_SNR_hp,MISA_filtHeight,pointAltitude,plot_periodLim_max, \
        dateRange,dateRange_dayNum,dateRange_dayNum_zeroHr,FONT_titleFM,FONT_axisTick,FONT_axisLabelFM);
#END IF
    
if( FLG_ISR_plot_ionVel == 1 ):
    GRITI_ISR_Haystack_plot_ionVel(Zenith_time,Zenith_height,Zenith_vel,\
        MISA_time,MISA_height,MISA_vel,ISR_RTI_heightLimValues,ISR_ionVel_plotLimValu_noFilt, \
        dateRange,dateRange_dayNum,dateRange_dayNum_zeroHr,FONT_titleFM,FONT_axisTick,FONT_axisLabelFM);
#END IF
      
if( FLG_ISR_plot_ionVel_cutOut == 1 ):
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , \
        np.where(np.min(np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range

    Zenith_time_cutOut = Zenith_time[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    Zenith_vel_cutOut = Zenith_vel[:,time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , \
        np.where(np.min(np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range
                                    
    MISA_time_cutOut = MISA_time[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    MISA_vel_cutOut = MISA_vel[:,time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    
    GRITI_ISR_Haystack_plot_ionVel_cutOut(Zenith_time_cutOut,Zenith_height,\
        Zenith_vel_cutOut,MISA_time_cutOut,MISA_height,MISA_vel_cutOut,ISR_RTI_heightLimValues, \
        ISR_ionVel_plotLimValu_noFilt,time_cutout_range,dateRange,dateRange_dayNum,dateRange_dayNum_zeroHr, \
        FONT_titleFM,FONT_axisTick,FONT_axisLabelFM);
#END IF
    
if( FLG_ISR_plot_ionVel_hp == 1 ):
    GRITI_ISR_Haystack_plot_ionVel_HP(Zenith_time,Zenith_height,Zenith_vel_hp,\
        MISA_time,MISA_height,MISA_vel_hp,ISR_RTI_heightLimValues,ISR_ionVel_plotLimValu,filter_cutoffPeriod, \
        dateRange,dateRange_dayNum,dateRange_dayNum_zeroHr,FONT_titleFM,FONT_axisTick,FONT_axisLabelFM);
#END IF
    
if( FLG_ISR_plot_ionVel_hp_cutOut == 1 ):
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , \
        np.where(np.min(np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (Zenith_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range

    Zenith_time_cutOut = Zenith_time[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    Zenith_vel_hp_cutOut = Zenith_vel_hp[:,time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , \
        np.where(np.min(np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (MISA_time-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range
                                    
    MISA_time_cutOut = MISA_time[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    MISA_vel_hp_cutOut = MISA_vel_hp[:,time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    
    GRITI_ISR_Haystack_plot_ionVel_HP_cutOut(Zenith_time_cutOut,Zenith_height,\
        Zenith_vel_hp_cutOut,MISA_time_cutOut,MISA_height,MISA_vel_hp_cutOut,ISR_RTI_heightLimValues, \
        ISR_ionVel_plotLimValu,filter_cutoffPeriod,time_cutout_range,dateRange,dateRange_dayNum,dateRange_dayNum_zeroHr, \
        FONT_titleFM,FONT_axisTick,FONT_axisLabelFM);
#END IF
    
#****************************************************************Kp ANALYSIS****************************************************************
if( FLG_Kp_plot == 1 ):
    GRITI_Kp_plot(Kp_data,Kp_time,time_Ref,time_Reference, \
        dateRange_full,dateRange_zeroHr,dateRange_dayNum_zeroHr,dateRange_zeroHr_monthName, \
        dateRange_zeroHr_dayPostfix,FONT_titleFM,FONT_axisLabelFM,opt=2);
#END IF
                                                      
#****************************************************************OMNI ANALYSIS****************************************************************
if( FLG_OMNI_plot == 1 ):
    GRITI_OMNI_plot(OMNI_data,OMNI_timeUnique,OMNI_dict,OMNI_dictPlot,OMNI_plotSet_name, \
        time_Ref,time_Reference,dateRange_full,dateRange_zeroHr,dateRange_dayNum_zeroHr, \
        dateRange_zeroHr_monthName,dateRange_zeroHr_dayPostfix,FONT_titleFM,FONT_axisLabelFM,opt=2);
#END IF

if( FLG_OMNI_plot_scargle == 1 ):
    GRITI_OMNI_plot_scargle(OMNI_data,OMNI_timeUnique,OMNI_dict,OMNI_dictPlot,OMNI_plot_scargle_name,\
        filter_cutoffPeriod,dateRange,dateRange_dayNum_zeroHr,FONT_titleFM,FONT_axisLabelFM,settings, \
        plot_Period_Lim=plot_periodLim_max,OMNI_plot_scargle_highpassOption=OMNI_plot_scargle_highpassOption);
#END IF
    
if( FLG_OMNI_plot_FFT == 1 ):
    GRITI_OMNI_plot_FFT(OMNI_data,OMNI_timeUnique,OMNI_dict,OMNI_dictPlot,OMNI_plot_scargle_name,\
        filter_cutoffPeriod,dateRange,dateRange_dayNum_zeroHr,FONT_titleFM,FONT_axisLabelFM,settings, \
        plot_Period_Lim=plot_periodLim_max,OMNI_plot_scargle_highpassOption=OMNI_plot_scargle_highpassOption);
#END IF

if( FLG_OMNI_stacker == 1 ):
    from subfun_figFitterFast import subfun_figFitterFast
    from subfun_insert import subfun_insert
    from scipy.interpolate import interp1d
    
    #-----Unpack-----
    # plotLatRange = settings['map']['lat range'];
    # plotLongRange = settings['map']['long range'];
    
    PLOT_lineWidthThicc = PLOT_lineWidth['thicc']; #get the line widths
    PLOT_lineWidthDoublePlus = PLOT_lineWidth['double plus']; #get the line widths
    PLOT_lineWidthPlus = PLOT_lineWidth['plus']; #get the line widths
    PLOT_lineWidthRegularPlus = PLOT_lineWidth['regular plus']; #get the line widths
    PLOT_lineWidthRegular = PLOT_lineWidth['regular']; #get the line widths
    PLOT_lineWidthSmol = PLOT_lineWidth['smol']; #get the line widths
    
    #-----Stack-----
    OMNI_timeUnique_uniqueDays, OMNI_timeUnique_uniqueDaysIndex, OMNI_timeUnique_uniqueDayCounts = np.unique(np.int64(OMNI_timeUnique),return_inverse=True,return_counts=True); #get the unique days and the indexes that get us to them
    
    OMNI_stackerDaysStacked = OMNI_timeUnique_uniqueDays.size; #get the number of days to stack
    OMNI_stackerTime = np.int64(np.arange(0,86400,data['OMNI']['data rate'])); #sec, make a time vector to go with the stacker var
    OMNI_stackerHolder = np.zeros( (OMNI_stackerTime.size , OMNI_timeUnique_uniqueDays.size) ); #preallocate
    #STACK EM
    for i in range(0,OMNI_timeUnique_uniqueDays.size):
        k = np.where( OMNI_timeUnique_uniqueDaysIndex == i )[0]; #get indexes with the first day
        if( OMNI_timeUnique_uniqueDayCounts[i] == OMNI_stackerTime.size ):
            OMNI_stackerHolder[:,i] = OMNI_data[:,OMNI_dict[OMNI_plot_name]][k]; #yoink
        else:
            tempTimeSec = np.int64(np.round((OMNI_timeUnique[k]-OMNI_timeUnique_uniqueDays[i])*86400)); #get the seconds in the day
            k2 = np.isin(OMNI_stackerTime, tempTimeSec, assume_unique=True,invert=True); #get missing time steps
            #--- Pad with NaNs ---
            # OMNI_stackerHolder[:,i] = subfun_insert(OMNI_data[:,OMNI_dict[OMNI_plot_name]][k],np.where(k2)[0],np.nan); #yoink, pad with NaN's as needed
            #--- Interpolate over NaNs ---
            k3 = np.isin(np.arange(0,OMNI_stackerTime.size,step=1), np.where(k2)[0], assume_unique=True,invert=True); #get data indexes
            OMNI_stackerHolder[k3,i] = OMNI_data[:,OMNI_dict[OMNI_plot_name]][k]; #record the real data
            nan_interper = interp1d(tempTimeSec,OMNI_data[:,OMNI_dict[OMNI_plot_name]][k],kind='linear',fill_value='extrapolate'); #make an interpolator
            OMNI_stackerHolder[np.where(k2)[0],i] = nan_interper(OMNI_stackerTime[np.where(k2)[0]]); #interpolate over the NaNs
        #END IF     
        #--- Condition data to be normalized ---
        OMNI_stackerHolder[:,i] = OMNI_stackerHolder[:,i] - np.nanmean(OMNI_stackerHolder[:,i]); #0 the mean
        pwr = np.sqrt(1/OMNI_stackerHolder[:,i].size*np.nansum(OMNI_stackerHolder[:,i]**2)); #estimate power of signal
        OMNI_stackerHolder[:,i] = 1/pwr*OMNI_stackerHolder[:,i]; #normalize power
    #END FOR i
    
    OMNI_stacker = np.nanmean(OMNI_stackerHolder,axis=1); #average along the 3rd axis
            
    data['OMNI']['stacker'] = OMNI_stacker; #record
    data['OMNI']['stacker per day'] = OMNI_stackerHolder; #record
    data['OMNI']['stacker time'] = OMNI_stackerTime; #record
    
    #Start the OMNI and OMNI AE plot
    fig, ax = plt.subplots(nrows=1, ncols=1); #use instead of fig because it inits an axis too (I think I dunno)
    figManager = plt.get_current_fig_manager(); #req to maximize
    figManager.window.showMaximized(); #force maximized
    
    #-----PLOT OMNI-----
    ax.set_aspect('auto'); #Remove the aspect ratio from the basemap so it fills the screen better
    ax.plot( OMNI_stackerTime/3600, OMNI_stacker , linewidth=PLOT_lineWidthRegular ); #plot
    
    xAxisTicks = np.arange(np.int64(np.floor(np.min(OMNI_stackerTime/3600))),np.int64(np.ceil(np.max(OMNI_stackerTime/3600)))+1,1); #sets the start hr, stop hr, and the step size between (in this case, 4 hr)
    ax.set_xticks(xAxisTicks); #set x axis ticks
    
#        ax[0].set_xticklabels([]); #if statement to remove x axis labels except for the last line
#        ax[0].tick_params(axis="x",direction="in");
    
    ax.set_xlim( np.min(xAxisTicks) , np.max(xAxisTicks) ); #set y axis limits
    
    ax.set_ylabel(OMNI_dictPlot[OMNI_dict[OMNI_plot_name]],fontproperties=FONT_axisLabelFM); #set the y axis label
    
    # ax[0].set_ylim( np.min(OMNI_jouleHeating_integrate) , 150000 ); #set y axis limits
    
    ax.grid(b=True, which='major', axis='both', color='xkcd:light grey'); #sets major axis grid lines to be on                
    
    string_title = str(OMNI_stackerDaysStacked)+' Days Stacked of OMNI '+OMNI_plot_name; #create mecha title
    ax.set_title(string_title,fontproperties=FONT_titleFM); #set the title        
            
    ax.set_xlabel('Relative time through a day, aligned to 0 UT [hr]',fontproperties=FONT_axisLabelFM); #set the x axis label
    
    subfun_figFitterFast(fig); #fit the fig fast
    # fig.subplots_adjust(left = 0.090, right = 0.985, top = 0.96, bottom = 0.070); #sets padding to small numbers for minimal white space
    #fig.tight_layout(); #function for a tight layout, doesn't seem to do much here
    plt.show(); #req to make plot show up    
    
    #Start the OMNI and OMNI AE plot
    fig, ax = plt.subplots(nrows=1, ncols=1); #use instead of fig because it inits an axis too (I think I dunno)
    figManager = plt.get_current_fig_manager(); #req to maximize
    figManager.window.showMaximized(); #force maximized
    
    #-----PLOT OMNI-----
    ax.set_aspect('auto'); #Remove the aspect ratio from the basemap so it fills the screen better
    for i in range(0,OMNI_stackerHolder.shape[1]):
        ax.plot( OMNI_stackerTime/3600, OMNI_stackerHolder[:,i] , linewidth=PLOT_lineWidthRegular, color=settings['plot']['color'][i] , label='Day '+str(i+1)); #plot
    #END FOR i
    ax.legend(); #make the legend show up
    
    xAxisTicks = np.arange(np.int64(np.floor(np.min(OMNI_stackerTime/3600))),np.int64(np.ceil(np.max(OMNI_stackerTime/3600)))+1,1); #sets the start hr, stop hr, and the step size between (in this case, 4 hr)
    ax.set_xticks(xAxisTicks); #set x axis ticks
    
#        ax[0].set_xticklabels([]); #if statement to remove x axis labels except for the last line
#        ax[0].tick_params(axis="x",direction="in");
    
    ax.set_xlim( np.min(xAxisTicks) , np.max(xAxisTicks) ); #set y axis limits
    
    ax.set_ylabel(OMNI_dictPlot[OMNI_dict[OMNI_plot_name]],fontproperties=FONT_axisLabelFM); #set the y axis label
    
    # ax[0].set_ylim( np.min(OMNI_jouleHeating_integrate) , 150000 ); #set y axis limits
    
    ax.grid(b=True, which='major', axis='both', color='xkcd:light grey'); #sets major axis grid lines to be on                
    
    string_title = str(OMNI_stackerDaysStacked)+' Days [Not Stacked] of OMNI '+OMNI_plot_name; #create mecha title
    ax.set_title(string_title,fontproperties=FONT_titleFM); #set the title        
            
    ax.set_xlabel('Relative time through a day, aligned to 0 UT [hr]',fontproperties=FONT_axisLabelFM); #set the x axis label
    
    subfun_figFitterFast(fig); #fit the fig fast
    # fig.subplots_adjust(left = 0.090, right = 0.985, top = 0.96, bottom = 0.070); #sets padding to small numbers for minimal white space
    #fig.tight_layout(); #function for a tight layout, doesn't seem to do much here
    plt.show(); #req to make plot show up 
#END IF

if( FLG_OMNI_stacker_FFT == 1 ):
    from subfun_filter import subfun_filter
    from subfun_spectra import subfun_spectra
    from subfun_figFitterFast import subfun_figFitterFast
    from subfun_timeMatch import subfun_timeMatch
    
    #---- Unpack -----
    settings_spectra = settings['spectra'];

    OMNI_dataRate = np.copy(data['OMNI']['data rate']).item(); #get the data rate
    #---OMNI PREP - time Match & HP---
    if( np.isclose(OMNI_dataRate,360) == False ):
        sixMin_timeUnique_sec = np.arange(0,86400,360); #sec, arange time stamps
        #Match the data in the 1st input (and its time in the 2nd input) to the time scale given in the 3rd input time and return that data and that data's highpassed form
        OMNI_timeMatch, OMNI_timeUnique_timeMatch = subfun_timeMatch(data['OMNI']['stacker'], data['OMNI']['stacker time'], sixMin_timeUnique_sec, timeMatch_delta=OMNI_dataRate, FLG_useSum=0); #match that time scale
        OMNI_dataRate = 6*60; #sec, record the new data rate
    else:
        OMNI_timeMatch = data['OMNI']['stacker']; #set so no errors
        OMNI_timeUnique_timeMatch = data['OMNI']['stacker time']; #set so no errors
    #END IF
    
    OMNI_timeMatch_filt = subfun_filter( OMNI_timeMatch, OMNI_timeUnique_timeMatch, OMNI_FFT_filtMethod, settings_spectra, dataRate = OMNI_dataRate); #filter
    
    Cxx_OMNI, period_OMNI = subfun_spectra( OMNI_timeMatch_filt, OMNI_timeUnique_timeMatch, 'FFT', settings_spectra, dataRate = OMNI_dataRate); #get spectra
    # Cxx_OMNI, period_OMNI, _ = subfun_spectra( OMNI_timeMatch_filt, OMNI_timeUnique_timeMatch, 'Lomb-Scargle', settings_spectra, dataRate = OMNI_dataRate); #get spectra

    #PLOT IT UP
    warnings.filterwarnings("ignore", category=RuntimeWarning); #silences warnings about NaNs used in a logical comparisons #yolo
    
    #Start the OMNI stacker FFT plot
    fig, ax = plt.subplots(); #use instead of fig because it inits an axis too (I think I dunno)
    figManager = plt.get_current_fig_manager(); #req to maximize
    figManager.window.showMaximized(); #force maximized
    
    ax.plot( period_OMNI/60, Cxx_OMNI ); #plot
#        ax.plot( OMNI_data_scargPeriod, np.tile(OMNI_data_scarggf,np.size(OMNI_data_scargPeriod)) , color="xkcd:grey" ); #plot
    
    ax.set_xlabel("Periods [min]"+' for Date Range '+str(dateRange[0,1])+'/'+str(dateRange[0,2])+ \
        '/'+str(dateRange[0,0])+' to '+str(dateRange[-1,1])+ '/'+str(dateRange[-1,2])+'/'+str(dateRange[-1,0])+ ' (M/D/Y)',fontproperties=FONT_axisLabelFM); #set the x axis label
    ax.set_ylabel('Normalized Power',fontproperties=FONT_axisLabelFM); #set the y axis label
    
    xAxisTicks = np.arange( 0, settings_spectra['period limit max']/60+10, 10); #sets the start hr, stop hr, and the step size between (in this case, 2 hr)
    ax.set_xticks(xAxisTicks); #set x axis ticks
    ax.set_xlim( (settings_spectra['period limit min']/60, settings_spectra['period limit max']/60) ); #set x axis limits

#        if( OMNI_data_scarggf < np.max(OMNI_data_scargPower[OMNI_data_scargPeriod<=plot_Period_Lim])+0.1*np.max(OMNI_data_scargPower[OMNI_data_scargPeriod<=plot_Period_Lim]) ):
#            ax.set_ylim( (0, np.max(OMNI_data_scargPower[OMNI_data_scargPeriod<=plot_Period_Lim])+0.1*np.max(OMNI_data_scargPower[OMNI_data_scargPeriod<=plot_Period_Lim]) ) ); #set x axis limits
#        else:
#            ax.set_ylim( (0, OMNI_data_scarggf+0.1*OMNI_data_scarggf ) ); #set x axis limits
#        #END IF 
    

    string_title = str(OMNI_stackerDaysStacked)+' Days Stacked of OMNI '+OMNI_plot_name+' - FFT Power Spectra with '+OMNI_FFT_filtMethod+' Filter with a '+str(settings['spectra']['savgol filter period']/60).strip('0').strip('.')+' min Cutoff Period'; #create mecha title
    ax.set_title(string_title,fontproperties=FONT_titleFM); #set the title
    
    subfun_figFitterFast(fig); #fit the fig fast
    # fig.subplots_adjust(left = 0.050, right = 0.985, top = 0.96, bottom = 0.065); #sets padding to small numbers for minimal white space
    #fig.tight_layout(); #function for a tight layout, doesn't seem to do much here
    plt.show(); #req to make plot show up    

    warnings.filterwarnings("default", category=RuntimeWarning); #silences warnings about NaNs used in a logical comparisons #yolo
    
    #Start the OMNI stacker per day FFT plot
    fig, ax = plt.subplots(); #use instead of fig because it inits an axis too (I think I dunno)
    figManager = plt.get_current_fig_manager(); #req to maximize
    figManager.window.showMaximized(); #force maximized
    
    for i in range(0,data['OMNI']['stacker per day'].shape[1]):
        OMNI_stackerPerDay = data['OMNI']['stacker per day'][:,i]; #unpack
        OMNI_stackerPerDay[np.isnan(OMNI_stackerPerDay)] = 0; #force NaNs to 0
        OMNI_timeMatch_filt = subfun_filter( OMNI_stackerPerDay, OMNI_timeUnique_timeMatch, OMNI_FFT_filtMethod, settings_spectra, dataRate = OMNI_dataRate); #filter
        Cxx_OMNI, period_OMNI = subfun_spectra( OMNI_timeMatch_filt, OMNI_timeUnique_timeMatch, 'FFT', settings_spectra, dataRate = OMNI_dataRate); #get spectra
        # Cxx_OMNI, period_OMNI, _ = subfun_spectra( OMNI_timeMatch_filt, OMNI_timeUnique_timeMatch, 'Lomb-Scargle', settings_spectra, dataRate = OMNI_dataRate); #get spectra
        ax.plot( period_OMNI/60, Cxx_OMNI , color=settings['plot']['color'][i], label='Day '+str(i+1)); #plot
    #END FOR i
    ax.legend(); #make the legend show up
    
    ax.set_xlabel("Periods [min]"+' for Date Range '+str(dateRange[0,1])+'/'+str(dateRange[0,2])+ \
        '/'+str(dateRange[0,0])+' to '+str(dateRange[-1,1])+ '/'+str(dateRange[-1,2])+'/'+str(dateRange[-1,0])+ ' (M/D/Y)',fontproperties=FONT_axisLabelFM); #set the x axis label
    ax.set_ylabel('Normalized Power',fontproperties=FONT_axisLabelFM); #set the y axis label
    
    xAxisTicks = np.arange( 0, settings_spectra['period limit max']/60+10, 10); #sets the start hr, stop hr, and the step size between (in this case, 2 hr)
    ax.set_xticks(xAxisTicks); #set x axis ticks
    ax.set_xlim( (settings_spectra['period limit min']/60, settings_spectra['period limit max']/60) ); #set x axis limits
    
#        if( OMNI_data_scarggf < np.max(OMNI_data_scargPower[OMNI_data_scargPeriod<=plot_Period_Lim])+0.1*np.max(OMNI_data_scargPower[OMNI_data_scargPeriod<=plot_Period_Lim]) ):
#            ax.set_ylim( (0, np.max(OMNI_data_scargPower[OMNI_data_scargPeriod<=plot_Period_Lim])+0.1*np.max(OMNI_data_scargPower[OMNI_data_scargPeriod<=plot_Period_Lim]) ) ); #set x axis limits
#        else:
#            ax.set_ylim( (0, OMNI_data_scarggf+0.1*OMNI_data_scarggf ) ); #set x axis limits
#        #END IF 
    
    string_title = str(OMNI_stackerDaysStacked)+' Days [Not Stacked] of OMNI '+OMNI_plot_name+' - FFT Power Spectra with '+OMNI_FFT_filtMethod+' Filter with a '+str(settings['spectra']['savgol filter period']/60).strip('0').strip('.')+' min Cutoff Period'; #create mecha title
    ax.set_title(string_title,fontproperties=FONT_titleFM); #set the title
    
    subfun_figFitterFast(fig); #fit the fig fast
    # fig.subplots_adjust(left = 0.050, right = 0.985, top = 0.96, bottom = 0.065); #sets padding to small numbers for minimal white space
    #fig.tight_layout(); #function for a tight layout, doesn't seem to do much here
    plt.show(); #req to make plot show up    

    warnings.filterwarnings("default", category=RuntimeWarning); #silences warnings about NaNs used in a logical comparisons #yolo
#END IF

#****************************************************************Kp AND OMNI ANALYSIS****************************************************************
#this is activated implicitly by fancyPlot and the other 2 plot commands on
if( (FLG_Kp_plot == 1) & (FLG_OMNI_plot == 1) & (FLG_fancyPlot == 1) ):
    GRITI_KpOMNI_fancyPlot(Kp_data,Kp_time, OMNI_data,OMNI_timeUnique, \
        OMNI_dict, OMNI_dictPlot, OMNI_plotSet_name, time_Ref,time_Reference, \
        dateRange_full, dateRange_zeroHr, dateRange_dayNum_zeroHr, dateRange_zeroHr_monthName, \
        dateRange_zeroHr_dayPostfix, FONT_grandioseFM, FONT_titleFM, FONT_axisLabelFM, \
        PLOT_lineWidth, journal_width_2C,journal_height_max,journal_dpi,opt=2);
#END IF

#****************************************************************AMPERE ANALYSIS****************************************************************
#==============Analysis: Any Angle AVG (Keogram)==============
if( (FLG_AMPERE_avg_anyAngle == 1) ):
    # AMPERE_plot_label = AMPERE_plot_labels[np.where(AMPERE_plot_indexes == AMPERE_plot_index)[0][0]]; #get the label
    # AMPERE_plot_label_noUnits = AMPERE_plot_label[0:AMPERE_plot_label.find('[')-1]; #remove the (units)
    AMPERE_plot_label = settings_AMPERE['labels'][settings_AMPERE['data type']]+settings_AMPERE['units'][settings_AMPERE['data type']]; #get the label and units
    AMPERE_plot_label_noUnits = settings_AMPERE['labels'][settings_AMPERE['data type']]; #get the label
    
    (AMPERE_keo, avg_anyAngle,settings['TEC']['keo']['keo width'], \
    settings['TEC']['keo']['keo plot latlong chunks'],settings['TEC']['keo']['keo plot latlong name']) = \
        GRITI_TEC_keo(plotLatRange,plotLongRange,AMPERE_timeUnique,\
            AMPERE_plotLimValu,AMPERE_colorMap,AMPERE_data[settings_AMPERE['data type']],AMPERE_data['time'],\
            AMPERE_data['lat'],AMPERE_data['long'],time_Ref,avg_anyAngle, \
            AMPERE_avg_anyAngle_N,avg_anyAngle_Width_orig,avg_anyAngle_45vsLatLong,avgPt_coords,geoMap_projectionStyle,\
            dateRange_dayNum_zeroHr,plotLatRange_autoTick,plotLongRange_autoTick,plotLongRange_autoTick_Crunched, gif_Millstone_Marker, gif_Millstone_Marker_Color, \
            gif_Millstone_Marker_Size,FONT_titleFM,FONT_axisTick,FONT_axisTickFM,FONT_axisLabelFM,BasemapFixDir,\
            AMPERE_plot_label_noUnits,AMPERE_plot_label,FLG_fancyPlot,PLOT_lineWidth, folder, journal_width_2C,journal_height_max,journal_dpi,\
            avg_anyAngle_polarMode=avg_anyAngle_polarMode);
    #call the mecha function that runs the keo alg and makes a plot showing the averaging are
    data['AMPERE']['keo'] = AMPERE_keo; #record
#END IF
  
    
#==============Analysis: Plot Keograms of Any Angle AVG==============
if( (FLG_AMPERE_avg_anyAngle_plot == 1) & (FLG_AMPERE_avg_anyAngle == 1) ):
    #-----Plot TEC results as a Keogram-----
    GRITI_TEC_keo_plot_TEC(AMPERE_keo,AMPERE_timeUnique,AMPERE_plotLimValu,AMPERE_colorMap, \
        plotLatRange,plotLongRange,latMillstone,longMillstone, \
        dateRange_dayNum_zeroHr,avg_anyAngle,settings['TEC']['keo']['keo width'], \
        settings['TEC']['keo']['keo plot latlong chunks'],settings['TEC']['keo']['keo plot latlong name'], \
        AMPERE_plot_label_noUnits,AMPERE_plot_label,\
        FONT_titleFM,FONT_axisTick,FONT_axisLabelFM);
    #call the mecha function that plots the avg'd delta-vTEC
#END IF
    
    
#==============Analysis: Plot Time Cut-out Keograms of Any Angle AVG==============
if( (FLG_AMPERE_avg_anyAngle_plot_timeCutout == 1) & (FLG_AMPERE_avg_anyAngle == 1) ):
    #-----Plot TEC results as a Keogram-----
    time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (AMPERE_timeUnique-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) )) == np.abs( (AMPERE_timeUnique-dateRange_dayNum_zeroHr[1]*86400) - np.min(time_cutout_range) ) )[0][0] , \
        np.where(np.min(np.abs( (AMPERE_timeUnique-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) )) == np.abs( (AMPERE_timeUnique-dateRange_dayNum_zeroHr[1]*86400) - np.max(time_cutout_range) ) )[0][0] ) ); #get the indexes for that time cutout range
    
    AMPERE_keo_cutOut = AMPERE_keo[time_cutout_indexes[0]:time_cutout_indexes[1]+1,:];
    AMPERE_timeUnique_cutOut = AMPERE_timeUnique[time_cutout_indexes[0]:time_cutout_indexes[1]+1];
    
    GRITI_TEC_keo_plot_TEC_cutOut(AMPERE_keo_cutOut,AMPERE_timeUnique_cutOut,AMPERE_plotLimValu,AMPERE_colorMap, \
        plotLatRange,plotLongRange,latMillstone,longMillstone, \
        dateRange_dayNum_zeroHr,avg_anyAngle,settings['TEC']['keo']['keo width'], \
        settings['TEC']['keo']['keo plot latlong chunks'],settings['TEC']['keo']['keo plot latlong name'],
        AMPERE_plot_label_noUnits,AMPERE_plot_label,time_cutout_range, \
        FONT_titleFM,FONT_axisTick,FONT_axisLabelFM);
    #call the mecha function that plots the avg'd delta-vTEC
#END IF

#==============Analysis: Plot FFT of Keogram==============
if( (FLG_AMPERE_keo_spectra == 1) & (FLG_AMPERE_avg_anyAngle == 1) ):
    if( settings['TEC']['keo']['keo plot latlong name'] == 'Longitude' ):
        goalIndex = np.where( np.abs(settings['TEC']['keo']['keo plot latlong chunks'] - avgPt_coords[0,1]) == np.min(np.abs(settings['TEC']['keo']['keo plot latlong chunks'] - avgPt_coords[0,1])) )[0].item() - 1; #set the goal index (closet to key pt)
    else:
        goalIndex = np.where( np.abs(settings['TEC']['keo']['keo plot latlong chunks'] - avgPt_coords[0,0]) == np.min(np.abs(settings['TEC']['keo']['keo plot latlong chunks'] - avgPt_coords[0,0])) )[0].item() - 1; #set the goal index (closet to key pt)
    #END IF
    AMPERE_keo_atIndexNoNAN = np.copy(AMPERE_keo[:,goalIndex]); #copy it
    AMPERE_keo_atIndexNoNAN[np.isnan(AMPERE_keo_atIndexNoNAN)] = 0; #set NaN's to 0
    
    GRITI_spectral_6minAnalysisPlot(AMPERE_keo_atIndexNoNAN, AMPERE_timeUnique, 'day', data['AMPERE']['data rate'], 'sec', 'min',
        AMPERE_keo_spectra_filtMethod, AMPERE_keo_spectra_spectraMethod, dates, settings_spectra, settings_plot, settings_paths, settings['AMPERE']['labels'][settings['AMPERE']['data type']]+' Keogram at Pt of Interest' );
#END IF

#==============Analysis: Plot Keogram with Sun Location==============
if( (FLG_AMPERE_keo_plot_wSun == 1) & (FLG_AMPERE_avg_anyAngle == 1) ):
    #-----Plot TEC results as a Keogram-----
    GRITI_keo_plot_wSun(AMPERE_keo, AMPERE_timeUnique, AMPERE_plotLimValu,AMPERE_colorMap, \
      plotLatRange,plotLongRange,latMillstone,longMillstone, \
      dates,avg_anyAngle,settings['TEC']['keo']['keo width'], \
      settings['TEC']['keo']['keo plot latlong chunks'],settings['TEC']['keo']['keo plot latlong name'], \
      AMPERE_plot_label_noUnits,AMPERE_plot_label,\
      FONT_titleFM,FONT_axisTick,FONT_axisLabelFM);
    #call the mecha function that plots the avg'd delta-vTEC
#END IF

#==============Analysis: Plot Keogram with Centered Roll==============
if( (FLG_AMPERE_keo_plot_wSunCenter == 1) & (FLG_AMPERE_avg_anyAngle == 1) ):
    #-----Plot TEC results as a Keogram-----
    AMPERE_keo_sunAligned = GRITI_keo_plot_sunCentered(AMPERE_keo,AMPERE_timeUnique,AMPERE_plotLimValu,AMPERE_colorMap, \
        plotLatRange,plotLongRange,latMillstone,longMillstone, \
        dates,avg_anyAngle,settings['TEC']['keo']['keo width'], \
        settings['TEC']['keo']['keo plot latlong chunks'],settings['TEC']['keo']['keo plot latlong name'], \
        AMPERE_plot_label_noUnits,AMPERE_plot_label,\
        FONT_titleFM,FONT_axisTick,FONT_axisLabelFM);
    #call the mecha function that plots the avg'd delta-vTEC
#END IF

#==============Analysis: Plot FFT of Keogram with Centered Roll==============
if( (FLG_AMPERE_keo_spectra_wSunCenter == 1) & (FLG_AMPERE_avg_anyAngle == 1) ):
    goalIndex = np.where( np.abs(settings['TEC']['keo']['keo plot latlong chunks']-0) == np.min(np.abs(settings['TEC']['keo']['keo plot latlong chunks']-0)) )[0].item() - 1; #set the goal index (closet to 0)
    AMPERE_keo_sunAligned_sunIndexNoNAN = np.copy(AMPERE_keo_sunAligned[:,goalIndex]); #copy it
    AMPERE_keo_sunAligned_sunIndexNoNAN[np.isnan(AMPERE_keo_sunAligned_sunIndexNoNAN)] = 0; #set NaN's to 0
    
    GRITI_spectral_6minAnalysisPlot(AMPERE_keo_sunAligned_sunIndexNoNAN, AMPERE_timeUnique, 'day', data['AMPERE']['data rate'], 'sec', 'min',
        AMPERE_keo_spectra_filtMethod, AMPERE_keo_spectra_spectraMethod, dates, settings_spectra, settings_plot, settings_paths, settings['AMPERE']['labels'][settings['AMPERE']['data type']]+' Keogram Sun-Aligned' );
#END IF

if( FLG_AMPERE_integrate_plot == 1 ):
    from subfun_figFitter import subfun_figFitter
    #Unpack
    AMPERE_data = data['AMPERE']; #unpack
    
    #Unpack line widths
    PLOT_lineWidthThicc = PLOT_lineWidth['thicc']; #get the line widths
    PLOT_lineWidthDoublePlus = PLOT_lineWidth['double plus']; #get the line widths
    PLOT_lineWidthPlus = PLOT_lineWidth['plus']; #get the line widths
    PLOT_lineWidthRegularPlus = PLOT_lineWidth['regular plus']; #get the line widths
    PLOT_lineWidthRegular = PLOT_lineWidth['regular']; #get the line widths
    PLOT_lineWidthSmol = PLOT_lineWidth['smol']; #get the line widths
    
    #----- Integrate AMPERE Data -----    
    AMPERE_integrated = GRITI_AMPERE_integrator(data, dates, settings_AMPERE, plotLatRange, plotLongRange, settings['AMPERE']['integrate method'], settings['AMPERE']['integrate method lat val'], AMPERE_integrateMethod_log=settings['AMPERE']['integrate method log']); #integrate with the integrator function

    #--- Time match to 6 minutes if needed ---
    if( np.isclose(AMPERE_data['data rate'],360.) == False ):
        sixMin_timeUnique = np.arange(dates['date range zero hr hour bounds'][0]*3600,dates['date range zero hr hour bounds'][1]*3600,360); #sec, arange time stamps in 6 minute steps
        AMPERE_integrated, AMPERE_timeUnique_matched = subfun_timeMatch(AMPERE_integrated, AMPERE_timeUnique, sixMin_timeUnique, timeMatch_delta=AMPERE_data['data rate'], FLG_useSum=1); #time match alg to align to 6 minute cadence, add because it's a count (?)
        AMPERE_timeUnique_hr = AMPERE_timeUnique_matched/3600; #hr, convert to hr with 0 hr at specified day
    else:
        AMPERE_timeUnique_hr = AMPERE_timeUnique/3600; #hr, convert to hr with 0 hr at specified day
    #END IF
    
    #--- Prepare axis limits ---
    if( np.mod(np.round(np.min(AMPERE_timeUnique_hr)),2) == 0 ):
        AMPERE_time_hr_axis_min = np.round(np.min(AMPERE_timeUnique_hr)); #is even, good to go
    else:
        AMPERE_time_hr_axis_min = np.round(np.min(AMPERE_timeUnique_hr))+1; #is odd, make even
    #END IF
    if( np.mod(np.round(np.max(AMPERE_timeUnique_hr)),2) == 0 ):
        AMPERE_time_hr_axis_max = np.round(np.max(AMPERE_timeUnique_hr)); #is even, good to go
    else:
        AMPERE_time_hr_axis_max = np.round(np.max(AMPERE_timeUnique_hr))-1; #is odd, make even
    #END IF
    
    #-----BEGIN THE PLOTTING!------
    AMPERE_plot_label = settings['AMPERE']['labels'][settings['AMPERE']['data type']]+settings['AMPERE']['units'][settings['AMPERE']['data type']]; #get the label
    AMPERE_plot_label_noUnits = settings['AMPERE']['labels'][settings['AMPERE']['data type']]; #remove the (units)
    
    #Start the AMPERE plot
    fig, ax = plt.subplots(); #use instead of fig because it inits an axis too (I think I dunno)
    figManager = plt.get_current_fig_manager(); #req to maximize
    figManager.window.showMaximized(); #force maximized
    
    ax.set_aspect('auto'); #Remove the aspect ratio from the basemap so it fills the screen better
    ax.plot( AMPERE_timeUnique_hr, AMPERE_integrated , linewidth=PLOT_lineWidthRegular ); #plot
    
    if( (np.abs((np.min(AMPERE_timeUnique_hr)/24 + dateRange_dayNum_zeroHr[1]) - np.min(time_Ref))*24 >= 0.25) & ((time_Reference != 'Kp') & (time_Reference != 'AMPERE')) ): #as long as min Kp time is 15 min diff or more from the other time reference, plot where the time ref begins (not Kp tho)
        ax.plot( np.repeat( (np.min(time_Ref) - dateRange_dayNum_zeroHr[1]*86400) , 10) , np.linspace(np.min(AMPERE_integrate),np.max(AMPERE_integrate),num=10), linewidth=1.75, color='r'); #plot red lines showing ISR data time
    if( (np.abs((np.max(AMPERE_timeUnique_hr)/24 + dateRange_dayNum_zeroHr[1]) - np.max(time_Ref))*24 >= 0.25) & ((time_Reference != 'Kp') & (time_Reference != 'AMPERE')) ): #as long as max Kp time is 15 min diff or more from the other time reference, plot where the time ref ends (not Kp tho)
        ax.plot( np.repeat( (np.max(time_Ref) - dateRange_dayNum_zeroHr[1]*86400) , 10) , np.linspace(np.min(AMPERE_integrate),np.max(AMPERE_integrate),num=10), linewidth=1.75, color='r'); #plot red lines showing ISR data time
    #END IF
    
    xAxisTicks = np.arange(AMPERE_time_hr_axis_min,AMPERE_time_hr_axis_max+4,4); #sets the start hr, stop hr, and the step size between (in this case, 4 hr)
    ax.set_xticks(xAxisTicks); #set x axis ticks
    
    ax.set_xlim( AMPERE_time_hr_axis_min , AMPERE_time_hr_axis_max ); #set y axis limits
    
    ax.set_ylabel("Integrated AMPERE "+AMPERE_plot_label,fontproperties=FONT_axisLabelFM); #set the y axis label
    
    ax.set_ylim( np.min(AMPERE_integrated) , np.max(AMPERE_integrated) ); #set y axis limits
    
    ax.grid(b=True, which='major', axis='both', color='xkcd:light grey'); #sets major axis grid lines to be on        
    
    string_title = 'Integrated AMPERE '+AMPERE_plot_label_noUnits; #prep the title
    if( settings['AMPERE']['integrate method'] == 0 ):
        string_title = string_title + ' within keo area'; #add to mecha title
    elif( settings['AMPERE']['integrate method'] == 1 ):
        string_title = string_title + ' within keo long & up to pole'; #add to mecha title
    elif( settings['AMPERE']['integrate method'] == 2 ):
        string_title = string_title + ' within keo long & up to '+str(settings['AMPERE']['integrate method lat val'])+' degc lat'; #add to mecha title
    elif( settings['AMPERE']['integrate method'] == 3 ):
        if( (np.min(plotLatRange) <= 0) & (np.max(plotLatRange) >= 0) ):
            string_title = string_title + ' both Hemispheres'; #add to mecha title
        else:
            if( (np.min(plotLatRange) >= 0) & (np.max(plotLatRange) >= 0) ):
                #northern hemisphere
                string_title = string_title + ' Northern Hemisphere'; #add to mecha title
            else:
                #southern hemisphere
                string_title = string_title + ' Southern Hemisphere'; #add to mecha title
            #END IF
        #END IF
    #END IF
    string_title += ' '+str(dateRange[0,1])+'/'+str(dateRange[0,2])+ \
    '/'+str(dateRange[0,0])+' to '+str(dateRange[-1,1])+ \
    '/'+str(dateRange[-1,2])+'/'+str(dateRange[-1,0])+ \
    ' (M/D/Y)'; #create mecha title
    ax.set_title(string_title,fontproperties=FONT_titleFM); #set the title
    
    ax.set_xlabel('Time in UT [hr] - 0 Hr on '+dateRange_zeroHr_monthName+' '+str(dateRange_zeroHr[2])+dateRange_zeroHr_dayPostfix+' | Day '+str(dateRange_dayNum_zeroHr[1])+', '+str(dateRange_dayNum_zeroHr[0]),fontproperties=FONT_axisLabelFM); #set the x axis label

    subfun_figFitter(fig); #fit that fig fast
    # fig.subplots_adjust(left = 0.070, right = 0.985, top = 0.96, bottom = 0.065); #sets padding to small numbers for minimal white space
    #fig.tight_layout(); #function for a tight layout, doesn't seem to do much here
    plt.show(); #req to make plot show up
#END IF
    
if( FLG_AMPERE_integrate_limArea_plot == 1 ):
    #Unpack line widths
    PLOT_lineWidthThicc = PLOT_lineWidth['thicc']; #get the line widths
    PLOT_lineWidthDoublePlus = PLOT_lineWidth['double plus']; #get the line widths
    PLOT_lineWidthPlus = PLOT_lineWidth['plus']; #get the line widths
    PLOT_lineWidthRegularPlus = PLOT_lineWidth['regular plus']; #get the line widths
    PLOT_lineWidthRegular = PLOT_lineWidth['regular']; #get the line widths
    PLOT_lineWidthSmol = PLOT_lineWidth['smol']; #get the line widths
    
    #limit based on area
    k = (AMPERE_data[:,6] <= np.max(plotLatRange)) & (AMPERE_data[:,6] >= np.min(plotLatRange)) & \
        (AMPERE_data[:,7] <= np.max(plotLongRange)) & (AMPERE_data[:,7] >= np.min(plotLongRange))
    AMPERE_data_limArea = AMPERE_data[k,:]; #get the limited area data
    AMPERE_timeUnique_limArea = np.unique(AMPERE_data_limArea[:,5]);  #get the limited time unique
    
    AMPERE_timeUnique_hr = (AMPERE_timeUnique_limArea - dateRange_dayNum_zeroHr[1]*86400); #hr, convert to hr with 0 hr at specified day
    
    if( np.mod(np.round(np.min(AMPERE_timeUnique_hr)),2) == 0 ):
        AMPERE_time_hr_axis_min = np.round(np.min(AMPERE_timeUnique_hr)); #is even, good to go
    else:
        AMPERE_time_hr_axis_min = np.round(np.min(AMPERE_timeUnique_hr))+1; #is odd, make even
    #END IF
    if( np.mod(np.round(np.max(AMPERE_timeUnique_hr)),2) == 0 ):
        AMPERE_time_hr_axis_max = np.round(np.max(AMPERE_timeUnique_hr)); #is even, good to go
    else:
        AMPERE_time_hr_axis_max = np.round(np.max(AMPERE_timeUnique_hr))-1; #is odd, make even
    #END IF
    
    #-----BEGIN THE PLOTTING!------
    AMPERE_integrate = np.zeros( AMPERE_timeUnique_hr.size , dtype=np.float64); #prep integrated joule heating
    for i in range(AMPERE_timeUnique_hr.size):
        k = np.where(AMPERE_timeUnique_limArea[i] == AMPERE_data_limArea[:,locAMPERE_time])[0]
        AMPERE_integrate[i] = np.sum(AMPERE_data_limArea[k,AMPERE_plot_index]); #ergs/(cm^2*sec), get the Joule Heating for the current time stamp
    #END FOR i
    
    AMPERE_plot_label = AMPERE_plot_labels[np.where(AMPERE_plot_indexes == AMPERE_plot_index)[0][0]]; #get the label
    AMPERE_plot_label_noUnits = AMPERE_plot_label[0:AMPERE_plot_label.find('[')-1]; #remove the (units)
    
    #Start the AMPERE plot
    fig, ax = plt.subplots(); #use instead of fig because it inits an axis too (I think I dunno)
    figManager = plt.get_current_fig_manager(); #req to maximize
    figManager.window.showMaximized(); #force maximized
    
    ax.set_aspect('auto'); #Remove the aspect ratio from the basemap so it fills the screen better
    ax.plot( AMPERE_timeUnique_hr, AMPERE_integrate , linewidth=PLOT_lineWidthRegular ); #plot
    
    if( (np.abs((np.min(AMPERE_timeUnique_hr)/24 + dateRange_dayNum_zeroHr[1]) - np.min(time_Ref))*24 >= 0.25) & ((time_Reference != 'Kp') & (time_Reference != 'AMPERE')) ): #as long as min Kp time is 15 min diff or more from the other time reference, plot where the time ref begins (not Kp tho)
        ax.plot( np.repeat( (np.min(time_Ref) - dateRange_dayNum_zeroHr[1]*86400) , 10) , np.linspace(np.min(AMPERE_integrate),np.max(AMPERE_integrate),num=10), linewidth=1.75, color='r'); #plot red lines showing ISR data time
    if( (np.abs((np.max(AMPERE_timeUnique_hr)/24 + dateRange_dayNum_zeroHr[1]) - np.max(time_Ref))*24 >= 0.25) & ((time_Reference != 'Kp') & (time_Reference != 'AMPERE')) ): #as long as max Kp time is 15 min diff or more from the other time reference, plot where the time ref ends (not Kp tho)
        ax.plot( np.repeat( (np.max(time_Ref) - dateRange_dayNum_zeroHr[1]*86400) , 10) , np.linspace(np.min(AMPERE_integrate),np.max(AMPERE_integrate),num=10), linewidth=1.75, color='r'); #plot red lines showing ISR data time
    #END IF
    
    xAxisTicks = np.arange(AMPERE_time_hr_axis_min,AMPERE_time_hr_axis_max+4,4); #sets the start hr, stop hr, and the step size between (in this case, 4 hr)
    ax.set_xticks(xAxisTicks); #set x axis ticks

    ax.set_xlim( AMPERE_time_hr_axis_min , AMPERE_time_hr_axis_max ); #set y axis limits
    
    ax.set_ylabel("Integrated AMPERE "+AMPERE_plot_label,fontproperties=FONT_axisLabelFM); #set the y axis label
    
    ax.set_ylim( np.min(AMPERE_integrate) , np.max(AMPERE_integrate) ); #set y axis limits
    
    ax.grid(b=True, which='major', axis='both', color='xkcd:light grey'); #sets major axis grid lines to be on        
    
    string_title = 'Integrated AMPERE '+AMPERE_plot_label_noUnits+' in the Nothern Hemisphere for '+str(dateRange[0,1])+'/'+str(dateRange[0,2])+ \
    '/'+str(dateRange[0,0])+' to '+str(dateRange[-1,1])+ \
    '/'+str(dateRange[-1,2])+'/'+str(dateRange[-1,0])+ \
    ' (M/D/Y)'+" for "+str(np.min(plotLatRange))+"x"+str(np.max(plotLatRange))+" lat, "+str(np.min(plotLongRange))+"x"+str(np.max(plotLatRange))+" long"; #create mecha title
    ax.set_title(string_title,fontproperties=FONT_titleFM); #set the title
    
    ax.set_xlabel('Time in UT (hr) - 0 Hr on '+dateRange_zeroHr_monthName+' '+str(dateRange_zeroHr[2])+dateRange_zeroHr_dayPostfix+' | Day '+str(dateRange_dayNum_zeroHr[1])+', '+str(dateRange_dayNum_zeroHr[0]),fontproperties=FONT_axisLabelFM); #set the x axis label
    
    fig.subplots_adjust(left = 0.070, right = 0.985, top = 0.96, bottom = 0.065); #sets padding to small numbers for minimal white space
    #fig.tight_layout(); #function for a tight layout, doesn't seem to do much here
    plt.show(); #req to make plot show up
#END IF

if( FLG_AMPERE_integrate_limArea_scargle == 1 ):
    #Unpack line widths
    PLOT_lineWidthThicc = PLOT_lineWidth['thicc']; #get the line widths
    PLOT_lineWidthDoublePlus = PLOT_lineWidth['double plus']; #get the line widths
    PLOT_lineWidthPlus = PLOT_lineWidth['plus']; #get the line widths
    PLOT_lineWidthRegularPlus = PLOT_lineWidth['regular plus']; #get the line widths
    PLOT_lineWidthRegular = PLOT_lineWidth['regular']; #get the line widths
    PLOT_lineWidthSmol = PLOT_lineWidth['smol']; #get the line widths
    
    #limit based on area
    k = (AMPERE_data[:,6] <= np.max(plotLatRange)) & (AMPERE_data[:,6] >= np.min(plotLatRange)) & \
        (AMPERE_data[:,7] <= np.max(plotLongRange)) & (AMPERE_data[:,7] >= np.min(plotLongRange))
    AMPERE_data_limArea = AMPERE_data[k,:]; #get the limited area data
    AMPERE_timeUnique_limArea = np.unique(AMPERE_data_limArea[:,5]);  #get the limited time unique

    AMPERE_timeUnique_hr = (AMPERE_timeUnique_limArea - dateRange_dayNum_zeroHr[1]*86400); #hr, convert to hr with 0 hr at specified day
    
    AMPERE_plot_scargle_label = AMPERE_plot_labels[np.where(AMPERE_plot_indexes == AMPERE_plot_scargle_index)[0][0]]; #get the label
    AMPERE_plot_scargle_label = AMPERE_plot_scargle_label[0:AMPERE_plot_scargle_label.find('[')-1]; #remove the (units)

        
    AMPERE_integrate = np.zeros( AMPERE_timeUnique_hr.size , dtype=np.float64); #prep integrated joule heating
    for i in range(AMPERE_timeUnique_hr.size):
        k = np.where(AMPERE_timeUnique_limArea[i] == AMPERE_data_limArea[:,locAMPERE_time])[0]
        AMPERE_integrate[i] = np.sum(AMPERE_data_limArea[k,AMPERE_plot_scargle_index]); #ergs/(cm^2*sec), get the Joule Heating for the current time stamp
    #END FOR i

    if( AMPERE_integrate_highpassOption == 0 ): #only original data, no high-passed data
        
        #Start the AMPERE/OMNI scargle plot
        fig, ax = plt.subplots(nrows=1, ncols=1); #use instead of fig because it inits an axis too (I think I dunno)
        figManager = plt.get_current_fig_manager(); #req to maximize
        figManager.window.showMaximized(); #force maximized
        
        #-----Plot an AMPERE data index's spectrum-----            
        AMPERE_integrate_scargPeriod, AMPERE_integrate_scargPower, AMPERE_integrate_scarggf = subfun_lombscargle(AMPERE_timeUnique_hr , AMPERE_integrate); #scargle that data
        AMPERE_integrate_scargPeriod = AMPERE_integrate_scargPeriod*60; #min, adjust the period out from hrs to minutes (since hrs goes in)
        
        ax.plot( AMPERE_integrate_scargPeriod, AMPERE_integrate_scargPower , linewidth=PLOT_lineWidthRegular ); #plot
        ax.plot( AMPERE_integrate_scargPeriod, np.tile(AMPERE_integrate_scarggf,np.size(AMPERE_integrate_scargPeriod)) , color="xkcd:grey" ); #plot
        
        ax.set_ylabel(AMPERE_plot_scargle_label+' Normalized Power',fontproperties=FONT_axisLabelFM); #set the y axis label
        
        xAxisTicks = np.arange(0,plot_periodLim_max+10,10); #sets the start hr, stop hr, and the step size between (in this case, 4 hr)
        ax.set_xticks(xAxisTicks); #set x axis ticks
        
        ax.set_xlim( (0, plot_periodLim_max) ); #set x axis limits
        if( AMPERE_integrate_scarggf < np.max(AMPERE_integrate_scargPower[AMPERE_integrate_scargPeriod<=plot_periodLim_max])+0.1*np.max(AMPERE_integrate_scargPower[AMPERE_integrate_scargPeriod<=plot_periodLim_max]) ):
            ax.set_ylim( (0, np.max(AMPERE_integrate_scargPower[AMPERE_integrate_scargPeriod<=plot_periodLim_max])+0.1*np.max(AMPERE_integrate_scargPower[AMPERE_integrate_scargPeriod<=plot_periodLim_max]) ) ); #set x axis limits
        else:
            ax.set_ylim( (0, AMPERE_integrate_scarggf+0.1*AMPERE_integrate_scarggf ) ); #set x axis limits
        #END IF
        
        ax.grid(b=True, which='major', axis='x', color='xkcd:light grey'); #sets major axis grid lines to be on 
        
        string_title = AMPERE_plot_scargle_label+' - Lomb-Scargle Periodogram for '+str(np.min(plotLatRange))+"x"+str(np.max(plotLatRange))+" lat, "+str(np.min(plotLongRange))+"x"+str(np.max(plotLatRange))+" long"; #create mecha title
        ax.set_title(string_title,fontproperties=FONT_titleFM); #set the title
                
        fig.subplots_adjust(left = 0.070, right = 0.985, top = 0.96, bottom = 0.065); #sets padding to small numbers for minimal white space
        #fig.tight_layout(); #function for a tight layout, doesn't seem to do much here
        plt.show(); #req to make plot show up    
        
    elif( AMPERE_integrate_highpassOption == 1 ): #combines original data scargle and high-passed data scargle
        from subfun_highpass import subfun_highpass
        #~~~~~HIGH-PASSED ONE~~~~~       
    
        #Start the AMPERE & OMNI scargle plot
        fig, ax = plt.subplots(nrows=1,ncols=1); #use instead of fig because it inits an axis too (I think I dunno)
        figManager = plt.get_current_fig_manager(); #req to maximize
        figManager.window.showMaximized(); #force maximized
                 
        #-----Plot an AMPERE data index's spectrum-----      
        AMPERE_integrate_hp = subfun_highpass(AMPERE_timeUnique_hr,AMPERE_integrate,filter_cutoffPeriod=filter_cutoffPeriod); #high-pass that data
        
        AMPERE_integrate_scargPeriod, AMPERE_integrate_scargPower, AMPERE_integrate_scarggf = subfun_lombscargle(AMPERE_timeUnique_hr , AMPERE_integrate_hp); #scargle that data
        AMPERE_integrate_scargPeriod = AMPERE_integrate_scargPeriod*60; #min, adjust the period out from hrs to minutes (since hrs goes in)
        
        ax.plot( AMPERE_integrate_scargPeriod, AMPERE_integrate_scargPower , linewidth=PLOT_lineWidthRegular ); #plot
        ax.plot( AMPERE_integrate_scargPeriod, np.tile(AMPERE_integrate_scarggf,np.size(AMPERE_integrate_scargPeriod)) , color="xkcd:grey" ); #plot
        
        ax.set_ylabel(AMPERE_plot_scargle_label+' Normalized Power',fontproperties=FONT_axisLabelFM); #set the y axis label
        
        xAxisTicks = np.arange(0,plot_periodLim_max+10,10); #sets the start hr, stop hr, and the step size between (in this case, 4 hr)
        ax.set_xticks(xAxisTicks); #set x axis ticks
        
        ax.set_xlim( (0, plot_periodLim_max) ); #set x axis limits
        if( AMPERE_integrate_scarggf < np.max(AMPERE_integrate_scargPower[AMPERE_integrate_scargPeriod<=plot_periodLim_max])+0.1*np.max(AMPERE_integrate_scargPower[AMPERE_integrate_scargPeriod<=plot_periodLim_max]) ):
            ax.set_ylim( (0, np.max(AMPERE_integrate_scargPower[AMPERE_integrate_scargPeriod<=plot_periodLim_max])+0.1*np.max(AMPERE_integrate_scargPower[AMPERE_integrate_scargPeriod<=plot_periodLim_max]) ) ); #set x axis limits
        else:
            ax.set_ylim( (0, AMPERE_integrate_scarggf+0.1*AMPERE_integrate_scarggf ) ); #set x axis limits
        #END IF
        
        ax.grid(b=True, which='major', axis='x', color='xkcd:light grey'); #sets major axis grid lines to be on 
        
        string_title = AMPERE_plot_scargle_label+' w/ High-pass Cutoff Period of '+str(filter_cutoffPeriod)+' hrs - Lomb-Scargle Periodogram for '+str(np.min(plotLatRange))+"x"+str(np.max(plotLatRange))+" lat, "+str(np.min(plotLongRange))+"x"+str(np.max(plotLatRange))+" long"; #create mecha title
        ax.set_title(string_title,fontproperties=FONT_titleFM); #set the title
                
        fig.subplots_adjust(left = 0.070, right = 0.985, top = 0.96, bottom = 0.065); #sets padding to small numbers for minimal white space
        #fig.tight_layout(); #function for a tight layout, doesn't seem to do much here
        plt.show(); #req to make plot show up   
    #END IF
#END IF   
    

if( FLG_AMPERE_integrate_stacker == 1 ):
    from subfun_figFitterFast import subfun_figFitterFast
    from subfun_insert import subfun_insert
    
    #-----Unpack-----
    # AMPERE_timeUnique = data['AMPERE']['time unique'];
    AMPERE_integrateMethod = settings['AMPERE']['integrate method'];
    AMPERE_integrateMethod_val = settings['AMPERE']['integrate method lat val'];
    AMPERE_integrateMethod_log = settings['AMPERE']['integrate method log'];
    # plotLatRange = settings['map']['lat range'];
    # plotLongRange = settings['map']['long range'];
    
    PLOT_lineWidthThicc = PLOT_lineWidth['thicc']; #get the line widths
    PLOT_lineWidthDoublePlus = PLOT_lineWidth['double plus']; #get the line widths
    PLOT_lineWidthPlus = PLOT_lineWidth['plus']; #get the line widths
    PLOT_lineWidthRegularPlus = PLOT_lineWidth['regular plus']; #get the line widths
    PLOT_lineWidthRegular = PLOT_lineWidth['regular']; #get the line widths
    PLOT_lineWidthSmol = PLOT_lineWidth['smol']; #get the line widths
    
    #-----Integrate-----
    AMPERE_integrate = GRITI_AMPERE_integrator(data, dates, settings['AMPERE'], settings['map']['lat range'], settings['map']['long range'], AMPERE_integrateMethod,AMPERE_integrateMethod_val,AMPERE_integrateMethod_log); #get the integrated AMPERE data
    
    #-----Stack-----
    AMPERE_timeUnique_uniqueDays, AMPERE_timeUnique_uniqueDaysIndex, AMPERE_timeUnique_uniqueDayCounts = np.unique(np.int64(AMPERE_timeUnique),return_inverse=True,return_counts=True); #get the unique days and the indexes that get us to them
    
    AMPERE_integrate_stackerDaysStacked = AMPERE_timeUnique_uniqueDays.size; #get the number of days to stack
    AMPERE_integrate_stackerTime = np.int64(np.arange(0,86400,data['AMPERE']['data rate'])); #sec, make a time vector to go with the stacker var
    AMPERE_integrate_stackerHolder = np.zeros( (AMPERE_integrate_stackerTime.size , AMPERE_timeUnique_uniqueDays.size) ); #preallocate
    #STACK EM
    for i in range(0,AMPERE_timeUnique_uniqueDays.size):
        k = np.where( AMPERE_timeUnique_uniqueDaysIndex == i )[0]; #get indexes with the first day
        if( AMPERE_timeUnique_uniqueDayCounts[i] == AMPERE_integrate_stackerTime.size ):
            AMPERE_integrate_stackerHolder[:,i] = AMPERE_integrate[k]; #yoink
        else:
            tempTimeSec = np.int64(np.round((AMPERE_timeUnique[k]-AMPERE_timeUnique_uniqueDays[i])*86400)); #get the seconds in the day
            k2 = np.isin(AMPERE_integrate_stackerTime, tempTimeSec, assume_unique=True,invert=True); #get missing time steps
            AMPERE_integrate_stackerHolder[:,i] = subfun_insert(AMPERE_integrate[k],np.where(k2)[0],np.nan); #yoink, pad with NaN's as needed
        #END IF
    #END FOR i
    
    AMPERE_integrate_stacker = np.nanmean(AMPERE_integrate_stackerHolder,axis=1); #average along the 3rd axis
            
    data['AMPERE']['integrated stacker'] = AMPERE_integrate_stacker; #record
    data['AMPERE']['integrated stacker per day'] = AMPERE_integrate_stackerHolder; #record
    data['AMPERE']['integrated stacker time'] = AMPERE_integrate_stackerTime; #record
    
    #Start the AMPERE and OMNI AE plot
    fig, ax = plt.subplots(nrows=1, ncols=1); #use instead of fig because it inits an axis too (I think I dunno)
    figManager = plt.get_current_fig_manager(); #req to maximize
    figManager.window.showMaximized(); #force maximized
    
    #-----PLOT AMPERE-----
    ax.set_aspect('auto'); #Remove the aspect ratio from the basemap so it fills the screen better
    ax.plot( AMPERE_integrate_stackerTime/3600, AMPERE_integrate_stacker , linewidth=PLOT_lineWidthRegular ); #plot
    
    xAxisTicks = np.arange(np.int64(np.floor(np.min(AMPERE_integrate_stackerTime/3600))),np.int64(np.ceil(np.max(AMPERE_integrate_stackerTime/3600)))+1,1); #sets the start hr, stop hr, and the step size between (in this case, 4 hr)
    ax.set_xticks(xAxisTicks); #set x axis ticks
    
#        ax[0].set_xticklabels([]); #if statement to remove x axis labels except for the last line
#        ax[0].tick_params(axis="x",direction="in");
    
    ax.set_xlim( np.min(xAxisTicks) , np.max(xAxisTicks) ); #set y axis limits
    
    ax.set_ylabel(settings['AMPERE']['labels'][settings['AMPERE']['data type']]+settings['AMPERE']['units'][settings['AMPERE']['data type']],fontproperties=FONT_axisLabelFM); #set the y axis label
    
    # ax[0].set_ylim( np.min(AMPERE_integrate) , 150000 ); #set y axis limits
    
    ax.grid(b=True, which='major', axis='both', color='xkcd:light grey'); #sets major axis grid lines to be on                
    
    if( AMPERE_integrateMethod == 0 ):
        string_title = '('+str(np.min(plotLatRange))+', '+str(np.max(plotLatRange))+') Lat, ('+str(np.min(plotLongRange))+', '+str(np.max(plotLongRange))+') Long Integrated'; #say how it was integrated
    if( AMPERE_integrateMethod == 1 ):
        string_title = '('+str(np.min(plotLatRange))+', 90) Lat, ('+str(np.min(plotLongRange))+', '+str(np.max(plotLongRange))+') Long Integrated'; #say how it was integrated
    if( AMPERE_integrateMethod == 2 ):
        string_title = '('+str(np.min(plotLatRange))+', '+str(AMPERE_integrateMethod_val)+') Lat, ('+str(np.min(plotLongRange))+', '+str(np.max(plotLongRange))+') Long Integrated'; #say how it was integrated
    if( AMPERE_integrateMethod == 3 ):
        if( (np.min(plotLatRange) >= 0) & (np.max(plotLatRange) >= 0) ):
            string_title = 'Northern Hemisphere Integrated'; #say how it was integrated
        else:
            string_title = 'Southern Hemisphere Integrated'; #say how it was integrated
        #END IF
    #END IF
    string_title = str(AMPERE_integrate_stackerDaysStacked)+' Days Stacked of '+string_title+' AMPERE '+settings['AMPERE']['labels'][settings['AMPERE']['data type']]; #create mecha title
    ax.set_title(string_title,fontproperties=FONT_titleFM); #set the title        
            
    ax.set_xlabel('Relative time through a day, aligned to 0 UT [hr]',fontproperties=FONT_axisLabelFM); #set the x axis label
    
    subfun_figFitterFast(fig); #fit the fig fast
    # fig.subplots_adjust(left = 0.090, right = 0.985, top = 0.96, bottom = 0.070); #sets padding to small numbers for minimal white space
    #fig.tight_layout(); #function for a tight layout, doesn't seem to do much here
    plt.show(); #req to make plot show up    
    
    #Start the AMPERE and OMNI AE plot
    fig, ax = plt.subplots(nrows=1, ncols=1); #use instead of fig because it inits an axis too (I think I dunno)
    figManager = plt.get_current_fig_manager(); #req to maximize
    figManager.window.showMaximized(); #force maximized
    
    #-----PLOT AMPERE-----
    ax.set_aspect('auto'); #Remove the aspect ratio from the basemap so it fills the screen better
    for i in range(0,AMPERE_integrate_stackerHolder.shape[1]):
        ax.plot( AMPERE_integrate_stackerTime/3600, AMPERE_integrate_stackerHolder[:,i] , linewidth=PLOT_lineWidthRegular, color=settings['plot']['color'][i] , label='Day '+str(i+1)); #plot
    #END FOR i
    ax.legend(); #make the legend show up
    
    xAxisTicks = np.arange(np.int64(np.floor(np.min(AMPERE_integrate_stackerTime/3600))),np.int64(np.ceil(np.max(AMPERE_integrate_stackerTime/3600)))+1,1); #sets the start hr, stop hr, and the step size between (in this case, 4 hr)
    ax.set_xticks(xAxisTicks); #set x axis ticks
    
#        ax[0].set_xticklabels([]); #if statement to remove x axis labels except for the last line
#        ax[0].tick_params(axis="x",direction="in");
    
    ax.set_xlim( np.min(xAxisTicks) , np.max(xAxisTicks) ); #set y axis limits
    
    ax.set_ylabel(settings['AMPERE']['labels'][settings['AMPERE']['data type']]+settings['AMPERE']['units'][settings['AMPERE']['data type']],fontproperties=FONT_axisLabelFM); #set the y axis label
    
    # ax[0].set_ylim( np.min(AMPERE_integrate) , 150000 ); #set y axis limits
    
    ax.grid(b=True, which='major', axis='both', color='xkcd:light grey'); #sets major axis grid lines to be on                
    
    if( AMPERE_integrateMethod == 0 ):
        string_title = '('+str(np.min(plotLatRange))+', '+str(np.max(plotLatRange))+') Lat, ('+str(np.min(plotLongRange))+', '+str(np.max(plotLongRange))+') Long Integrated'; #say how it was integrated
    if( AMPERE_integrateMethod == 1 ):
        string_title = '('+str(np.min(plotLatRange))+', 90) Lat, ('+str(np.min(plotLongRange))+', '+str(np.max(plotLongRange))+') Long Integrated'; #say how it was integrated
    if( AMPERE_integrateMethod == 2 ):
        string_title = '('+str(np.min(plotLatRange))+', '+str(AMPERE_integrateMethod_val)+') Lat, ('+str(np.min(plotLongRange))+', '+str(np.max(plotLongRange))+') Long Integrated'; #say how it was integrated
    if( AMPERE_integrateMethod == 3 ):
        if( (np.min(plotLatRange) >= 0) & (np.max(plotLatRange) >= 0) ):
            string_title = 'Northern Hemisphere Integrated'; #say how it was integrated
        else:
            string_title = 'Southern Hemisphere Integrated'; #say how it was integrated
        #END IF
    #END IF
    string_title = str(AMPERE_integrate_stackerDaysStacked)+' Days [Not Stacked] of '+string_title+' AMPERE '+settings['AMPERE']['labels'][settings['AMPERE']['data type']]; #create mecha title
    ax.set_title(string_title,fontproperties=FONT_titleFM); #set the title        
            
    ax.set_xlabel('Relative time through a day, aligned to 0 UT [hr]',fontproperties=FONT_axisLabelFM); #set the x axis label
    
    subfun_figFitterFast(fig); #fit the fig fast
    # fig.subplots_adjust(left = 0.090, right = 0.985, top = 0.96, bottom = 0.070); #sets padding to small numbers for minimal white space
    #fig.tight_layout(); #function for a tight layout, doesn't seem to do much here
    plt.show(); #req to make plot show up 
#END IF

if( FLG_AMPERE_integrate_stacker_FFT == 1 ):
    from subfun_filter import subfun_filter
    from subfun_spectra import subfun_spectra
    from subfun_figFitterFast import subfun_figFitterFast
    
    #---- Unpack -----
    settings_spectra = settings['spectra'];

    AMPERE_dataRate = np.copy(data['AMPERE']['data rate']).item(); #get the data rate
    #---AMPERE PREP - time Match & HP---
    if( np.abs(AMPERE_dataRate/60-6) > 0.05 ):
        sixMin_timeUnique_sec = np.arange(0,86400,AMPERE_dataRate); #sec, arange time stamps
        #Match the data in the 1st input (and its time in the 2nd input) to the time scale given in the 3rd input time and return that data and that data's highpassed form
        AMPERE_integrate_timeMatch, _, AMPERE_timeUnique_timeMatch = GRITI_TEC_avgPt_timeMatch(data['AMPERE']['integrated stacker'],data['AMPERE']['integrated stacker time']/60,sixMin_timeUnique_sec/60,(0,0),filter_cutoffPeriod=settings_spectra['filter cutoff period']);
        AMPERE_dataRate = 6*60; #record the new data rate
    else:
    #-----Highpass the data to keep the power within the period range we want-----
        AMPERE_integrate_timeMatch = data['AMPERE']['integrated stacker']; #set so no errors
        AMPERE_timeUnique_timeMatch = data['AMPERE']['integrated stacker time']; #set so no errors
    #END IF
    
    AMPERE_integrate_timeMatch_filt = subfun_filter( AMPERE_integrate_timeMatch, AMPERE_timeUnique_timeMatch, AMPERE_integrateFFT_filtMethod, settings_spectra, dataRate = AMPERE_dataRate); #filter
    
    Cxx_AMPERE, period_AMPERE = subfun_spectra( AMPERE_integrate_timeMatch_filt, AMPERE_timeUnique_timeMatch, 'FFT', settings_spectra, dataRate = AMPERE_dataRate); #get spectra
    
    Fs = 1/(AMPERE_dataRate/60); #min, misa time delta in freq form #OMNI_time_delta*24*60

    #PLOT IT UP
    warnings.filterwarnings("ignore", category=RuntimeWarning); #silences warnings about NaNs used in a logical comparisons #yolo
    
    #Start the AMPERE stacker FFT plot
    fig, ax = plt.subplots(); #use instead of fig because it inits an axis too (I think I dunno)
    figManager = plt.get_current_fig_manager(); #req to maximize
    figManager.window.showMaximized(); #force maximized
    
    ax.plot( period_AMPERE/60, Cxx_AMPERE ); #plot
#        ax.plot( OMNI_data_scargPeriod, np.tile(OMNI_data_scarggf,np.size(OMNI_data_scargPeriod)) , color="xkcd:grey" ); #plot
    
    ax.set_xlabel("Periods [min]"+' for Date Range '+str(dateRange[0,1])+'/'+str(dateRange[0,2])+ \
        '/'+str(dateRange[0,0])+' to '+str(dateRange[-1,1])+ '/'+str(dateRange[-1,2])+'/'+str(dateRange[-1,0])+ ' (M/D/Y)',fontproperties=FONT_axisLabelFM); #set the x axis label
    ax.set_ylabel('Normalized Power',fontproperties=FONT_axisLabelFM); #set the y axis label
    
    xAxisTicks = np.arange( 0, settings_spectra['period limit max']+10, 10); #sets the start hr, stop hr, and the step size between (in this case, 2 hr)
    ax.set_xticks(xAxisTicks); #set x axis ticks
    ax.set_xlim( (settings_spectra['period limit min'], settings_spectra['period limit max']) ); #set x axis limits

#        if( OMNI_data_scarggf < np.max(OMNI_data_scargPower[OMNI_data_scargPeriod<=plot_Period_Lim])+0.1*np.max(OMNI_data_scargPower[OMNI_data_scargPeriod<=plot_Period_Lim]) ):
#            ax.set_ylim( (0, np.max(OMNI_data_scargPower[OMNI_data_scargPeriod<=plot_Period_Lim])+0.1*np.max(OMNI_data_scargPower[OMNI_data_scargPeriod<=plot_Period_Lim]) ) ); #set x axis limits
#        else:
#            ax.set_ylim( (0, OMNI_data_scarggf+0.1*OMNI_data_scarggf ) ); #set x axis limits
#        #END IF 
    
    if( AMPERE_integrateMethod == 0 ):
        string_title = '('+str(np.min(plotLatRange))+', '+str(np.max(plotLatRange))+') Lat, ('+str(np.min(plotLongRange))+', '+str(np.max(plotLongRange))+') Long Integrated'; #say how it was integrated
    if( AMPERE_integrateMethod == 1 ):
        string_title = '('+str(np.min(plotLatRange))+', 90) Lat, ('+str(np.min(plotLongRange))+', '+str(np.max(plotLongRange))+') Long Integrated'; #say how it was integrated
    if( AMPERE_integrateMethod == 2 ):
        string_title = '('+str(np.min(plotLatRange))+', '+str(AMPERE_integrateMethod_val)+') Lat, ('+str(np.min(plotLongRange))+', '+str(np.max(plotLongRange))+') Long Integrated'; #say how it was integrated
    if( AMPERE_integrateMethod == 3 ):
        if( (np.min(plotLatRange) >= 0) & (np.max(plotLatRange) >= 0) ):
            string_title = 'Northern Hemisphere Integrated'; #say how it was integrated
        else:
            string_title = 'Southern Hemisphere Integrated'; #say how it was integrated
        #END IF
    #END IF
    string_title = str(AMPERE_integrate_stackerDaysStacked)+' Days Stacked of '+string_title+' AMPERE '+settings['AMPERE']['labels'][settings['AMPERE']['data type']]+' - FFT Power Spectra'; #create mecha title
    ax.set_title(string_title,fontproperties=FONT_titleFM); #set the title
    
    subfun_figFitterFast(fig); #fit the fig fast
    # fig.subplots_adjust(left = 0.050, right = 0.985, top = 0.96, bottom = 0.065); #sets padding to small numbers for minimal white space
    #fig.tight_layout(); #function for a tight layout, doesn't seem to do much here
    plt.show(); #req to make plot show up    

    warnings.filterwarnings("default", category=RuntimeWarning); #silences warnings about NaNs used in a logical comparisons #yolo
    
    #Start the AMPERE stacker per day FFT plot
    fig, ax = plt.subplots(); #use instead of fig because it inits an axis too (I think I dunno)
    figManager = plt.get_current_fig_manager(); #req to maximize
    figManager.window.showMaximized(); #force maximized
    
    for i in range(0,data['AMPERE']['integrated stacker per day'].shape[1]):
        AMPERE_integrate_stackerPerDay = data['AMPERE']['integrated stacker per day'][:,i]; #unpack
        AMPERE_integrate_stackerPerDay[np.isnan(AMPERE_integrate_stackerPerDay)] = 0; #force NaNs to 0
        AMPERE_integrate_timeMatch_filt = subfun_filter( AMPERE_integrate_stackerPerDay, AMPERE_timeUnique_timeMatch, AMPERE_integrateFFT_filtMethod, settings_spectra, dataRate = AMPERE_dataRate); #filter
        Cxx_AMPERE, period_AMPERE = subfun_spectra( AMPERE_integrate_timeMatch_filt, AMPERE_timeUnique_timeMatch, 'FFT', settings_spectra, dataRate = AMPERE_dataRate); #get spectra
        ax.plot( period_AMPERE/60, Cxx_AMPERE , color=settings['plot']['color'][i], label='Day '+str(i+1)); #plot
    #END FOR i
    ax.legend(); #make the legend show up
    
    ax.set_xlabel("Periods [min]"+' for Date Range '+str(dateRange[0,1])+'/'+str(dateRange[0,2])+ \
        '/'+str(dateRange[0,0])+' to '+str(dateRange[-1,1])+ '/'+str(dateRange[-1,2])+'/'+str(dateRange[-1,0])+ ' (M/D/Y)',fontproperties=FONT_axisLabelFM); #set the x axis label
    ax.set_ylabel('Normalized Power',fontproperties=FONT_axisLabelFM); #set the y axis label
    
    ax.set_xticks(xAxisTicks); #set x axis ticks
    ax.set_xlim( (settings_spectra['period limit min'], settings_spectra['period limit max']) ); #set x axis limits
    xAxisTicks = np.arange( 0, settings_spectra['period limit max']+10, 10); #sets the start hr, stop hr, and the step size between (in this case, 2 hr)
    
#        if( OMNI_data_scarggf < np.max(OMNI_data_scargPower[OMNI_data_scargPeriod<=plot_Period_Lim])+0.1*np.max(OMNI_data_scargPower[OMNI_data_scargPeriod<=plot_Period_Lim]) ):
#            ax.set_ylim( (0, np.max(OMNI_data_scargPower[OMNI_data_scargPeriod<=plot_Period_Lim])+0.1*np.max(OMNI_data_scargPower[OMNI_data_scargPeriod<=plot_Period_Lim]) ) ); #set x axis limits
#        else:
#            ax.set_ylim( (0, OMNI_data_scarggf+0.1*OMNI_data_scarggf ) ); #set x axis limits
#        #END IF 
    
    if( AMPERE_integrateMethod == 0 ):
        string_title = '('+str(np.min(plotLatRange))+', '+str(np.max(plotLatRange))+') Lat, ('+str(np.min(plotLongRange))+', '+str(np.max(plotLongRange))+') Long Integrated'; #say how it was integrated
    if( AMPERE_integrateMethod == 1 ):
        string_title = '('+str(np.min(plotLatRange))+', 90) Lat, ('+str(np.min(plotLongRange))+', '+str(np.max(plotLongRange))+') Long Integrated'; #say how it was integrated
    if( AMPERE_integrateMethod == 2 ):
        string_title = '('+str(np.min(plotLatRange))+', '+str(AMPERE_integrateMethod_val)+') Lat, ('+str(np.min(plotLongRange))+', '+str(np.max(plotLongRange))+') Long Integrated'; #say how it was integrated
    if( AMPERE_integrateMethod == 3 ):
        if( (np.min(plotLatRange) >= 0) & (np.max(plotLatRange) >= 0) ):
            string_title = 'Northern Hemisphere Integrated'; #say how it was integrated
        else:
            string_title = 'Southern Hemisphere Integrated'; #say how it was integrated
        #END IF
    #END IF
    string_title = str(AMPERE_integrate_stackerDaysStacked)+' Days [Not Stacked] of '+string_title+' AMPERE '+settings['AMPERE']['labels'][settings['AMPERE']['data type']]+' - FFT Power Spectra'; #create mecha title
    ax.set_title(string_title,fontproperties=FONT_titleFM); #set the title
    
    subfun_figFitterFast(fig); #fit the fig fast
    # fig.subplots_adjust(left = 0.050, right = 0.985, top = 0.96, bottom = 0.065); #sets padding to small numbers for minimal white space
    #fig.tight_layout(); #function for a tight layout, doesn't seem to do much here
    plt.show(); #req to make plot show up    

    warnings.filterwarnings("default", category=RuntimeWarning); #silences warnings about NaNs used in a logical comparisons #yolo
    
#END IF
    
if( FLG_AMPERE_integrate_andOMNI_AE_plot == 1 ):
    
    AMPERE_timeUnique_hr = (AMPERE_timeUnique - dateRange_dayNum_zeroHr[1]*86400); #hr, convert to hr with 0 hr at specified day
    
    if( np.mod(np.round(np.min(AMPERE_timeUnique_hr)),2) == 0 ):
        AMPERE_time_hr_axis_min = np.round(np.min(AMPERE_timeUnique_hr)); #is even, good to go
    else:
        AMPERE_time_hr_axis_min = np.round(np.min(AMPERE_timeUnique_hr))+1; #is odd, make even
    #END IF
    if( np.mod(np.round(np.max(AMPERE_timeUnique_hr)),2) == 0 ):
        AMPERE_time_hr_axis_max = np.round(np.max(AMPERE_timeUnique_hr)); #is even, good to go
    else:
        AMPERE_time_hr_axis_max = np.round(np.max(AMPERE_timeUnique_hr))-1; #is odd, make even
    #END IF
    
    OMNI_timeUnique_hr = (OMNI_timeUnique - dateRange_dayNum_zeroHr[1]*86400); #hr, convert to hr with 0 hr at specified day
    
    #OMNI plot prep
    OMNI_plot_label = OMNI_dictPlot[OMNI_dict[OMNI_plot_name]]; #get the label
    OMNI_plot_labelNoUnits = OMNI_plot_label[0:OMNI_plot_label.find('[')-1]; #remove the (units)
    
    #-----BEGIN THE PLOTTING!------
    if( np.min(data['AMPERE']['lat']) < 0 ):
        #that means there is southern hemisphere data
        pass;
    else:
        #otherwise only northern hemisphere data
        
        AMPERE_integrate = np.zeros( AMPERE_timeUnique_hr.size , dtype=np.float64); #prep integrated joule heating
        for i in range(AMPERE_timeUnique_hr.size):
            k = np.where(AMPERE_timeUnique[i] == data['AMPERE']['time'])[0]
            AMPERE_integrate[i] = np.sum(AMPERE_data[k,locAMPERE_jouleHeating]); #ergs/(cm^2*sec), get the Joule Heating for the current time stamp
        #END FOR i
        
        #Start the AMPERE and OMNI AE plot
        fig, ax = plt.subplots(nrows=2, ncols=1); #use instead of fig because it inits an axis too (I think I dunno)
        figManager = plt.get_current_fig_manager(); #req to maximize
        figManager.window.showMaximized(); #force maximized
        
        #-----PLOT AMPERE-----
        ax[0].set_aspect('auto'); #Remove the aspect ratio from the basemap so it fills the screen better
        ax[0].plot( AMPERE_timeUnique_hr, AMPERE_integrate , linewidth=PLOT_lineWidthRegular ); #plot
        
        if( (np.abs((np.min(AMPERE_timeUnique_hr)/24 + dateRange_dayNum_zeroHr[1]) - np.min(time_Ref))*24 >= 0.25) & ((time_Reference != 'Kp') & (time_Reference != 'AMPERE')) ): #as long as min Kp time is 15 min diff or more from the other time reference, plot where the time ref begins (not Kp tho)
            ax[0].plot( np.repeat( (np.min(time_Ref) - dateRange_dayNum_zeroHr[1]*86400) , 10) , np.linspace(np.min(AMPERE_integrate),np.max(AMPERE_integrate),num=10), linewidth=1.75, color='r'); #plot red lines showing ISR data time
        if( (np.abs((np.max(AMPERE_timeUnique_hr)/24 + dateRange_dayNum_zeroHr[1]) - np.max(time_Ref))*24 >= 0.25) & ((time_Reference != 'Kp') & (time_Reference != 'AMPERE')) ): #as long as max Kp time is 15 min diff or more from the other time reference, plot where the time ref ends (not Kp tho)
            ax[0].plot( np.repeat( (np.max(time_Ref) - dateRange_dayNum_zeroHr[1]*86400) , 10) , np.linspace(np.min(AMPERE_integrate),np.max(AMPERE_integrate),num=10), linewidth=1.75, color='r'); #plot red lines showing ISR data time
        #END IF
        
        xAxisTicks = np.arange(AMPERE_time_hr_axis_min,AMPERE_time_hr_axis_max+4,4); #sets the start hr, stop hr, and the step size between (in this case, 4 hr)
        ax[0].set_xticks(xAxisTicks); #set x axis ticks
        
#        ax[0].set_xticklabels([]); #if statement to remove x axis labels except for the last line
#        ax[0].tick_params(axis="x",direction="in");
        
        ax[0].set_xlim( AMPERE_time_hr_axis_min , AMPERE_time_hr_axis_max ); #set y axis limits
        
        ax[0].set_ylabel("Int. AMPERE JH [ergs/(cm^2*sec)]",fontproperties=FONT_axisLabelFM); #set the y axis label
        
        ax[0].set_ylim( np.min(AMPERE_integrate) , 150000 ); #set y axis limits
        
        ax[0].grid(b=True, which='major', axis='both', color='xkcd:light grey'); #sets major axis grid lines to be on                
        
        string_title = 'Integrated AMPERE Joule Heating in the Nothern Hemisphere & '+OMNI_plot_labelNoUnits+' for '+str(dateRange[0,1])+'/'+str(dateRange[0,2])+ \
        '/'+str(dateRange[0,0])+' to '+str(dateRange[-1,1])+ \
        '/'+str(dateRange[-1,2])+'/'+str(dateRange[-1,0])+ \
        ' (M/D/Y)'; #create mecha title
        ax[0].set_title(string_title,fontproperties=FONT_titleFM); #set the title
        
        #-----PLOT OMNI AE-----
        ax[1].set_aspect('auto'); #Remove the aspect ratio from the basemap so it fills the screen better
        ax[1].plot( OMNI_timeUnique_hr, OMNI_data[:,OMNI_dict[OMNI_plot_name]] , linewidth=PLOT_lineWidthRegular ); #plot
        
        if( (np.abs((np.min(AMPERE_timeUnique_hr)/24 + dateRange_dayNum_zeroHr[1]) - np.min(time_Ref))*24 >= 0.25) & ((time_Reference != 'Kp') & (time_Reference != 'AMPERE')) ): #as long as min Kp time is 15 min diff or more from the other time reference, plot where the time ref begins (not Kp tho)
            ax[1].plot( np.repeat( (np.min(time_Ref) - dateRange_dayNum_zeroHr[1]*86400) , 10) , np.linspace(np.min(AMPERE_integrate),np.max(AMPERE_integrate),num=10), linewidth=1.75, color='r'); #plot red lines showing ISR data time
        if( (np.abs((np.max(AMPERE_timeUnique_hr)/24 + dateRange_dayNum_zeroHr[1]) - np.max(time_Ref))*24 >= 0.25) & ((time_Reference != 'Kp') & (time_Reference != 'AMPERE')) ): #as long as max Kp time is 15 min diff or more from the other time reference, plot where the time ref ends (not Kp tho)
            ax[1].plot( np.repeat( (np.max(time_Ref) - dateRange_dayNum_zeroHr[1]*86400) , 10) , np.linspace(np.min(AMPERE_integrate),np.max(AMPERE_integrate),num=10), linewidth=1.75, color='r'); #plot red lines showing ISR data time
        #END IF
        
        ax[1].set_xticks(xAxisTicks); #set x axis ticks
        
        ax[1].set_xlim( AMPERE_time_hr_axis_min , AMPERE_time_hr_axis_max ); #set y axis limits
        
        ax[1].set_ylabel(OMNI_dictPlot[OMNI_dict[OMNI_plot_name]],fontproperties=FONT_axisLabelFM); #set the y axis label
        
        ax[1].set_ylim( np.min(OMNI_data[:,OMNI_dict[OMNI_plot_name]]) , np.max(OMNI_data[:,OMNI_dict[OMNI_plot_name]]) ); #set y axis limits
        
        ax[1].grid(b=True, which='major', axis='both', color='xkcd:light grey'); #sets major axis grid lines to be on                
                
        ax[1].set_xlabel('Time in UT (hr) - 0 Hr on '+dateRange_zeroHr_monthName+' '+str(dateRange_zeroHr[2])+dateRange_zeroHr_dayPostfix+' | Day '+str(dateRange_dayNum_zeroHr[1])+', '+str(dateRange_dayNum_zeroHr[0]),fontproperties=FONT_axisLabelFM); #set the x axis label
        
        fig.subplots_adjust(left = 0.070, right = 0.985, top = 0.96, bottom = 0.065); #sets padding to small numbers for minimal white space
        #fig.tight_layout(); #function for a tight layout, doesn't seem to do much here
        plt.show(); #req to make plot show up
    #END IF
    
#END IF
    

if( FLG_AMPERE_integrate_andOMNI_AE_plot_scargle == 1 ):

    AMPERE_timeUnique_hr = (AMPERE_timeUnique - dateRange_dayNum_zeroHr[1]*86400); #hr, convert to hr with 0 hr at specified day
    
    AMPERE_plot_scargle_label = AMPERE_plot_labels[np.where(AMPERE_plot_indexes == AMPERE_plot_scargle_index)[0][0]]; #get the label
    AMPERE_plot_scargle_label = AMPERE_plot_scargle_label[0:AMPERE_plot_scargle_label.find('[')-1]; #remove the (units)

    OMNI_timeUnique_hr = (OMNI_timeUnique - dateRange_dayNum_zeroHr[1]*86400); #hr, convert to hr with 0 hr at specified day
    
    OMNI_plot_scargle_label = OMNI_dictPlot[OMNI_dict[OMNI_plot_scargle_name]]; #get the label
    OMNI_plot_scargle_labelNoUnits = OMNI_plot_scargle_label[0:OMNI_plot_scargle_label.find('[')-1]; #remove the (units)
    
    #-----BEGIN THE PLOTTING!------
    if( np.min(data['AMPERE']['lat']) < 0 ):
        #that means there is southern hemisphere data
        pass;
    else:
        #otherwise only northern hemisphere data
        
        AMPERE_integrate = np.zeros( AMPERE_timeUnique_hr.size , dtype=np.float64); #prep integrated joule heating
        for i in range(AMPERE_timeUnique_hr.size):
            k = np.where(AMPERE_timeUnique[i] == data['AMPERE']['time'])[0]
            AMPERE_integrate[i] = np.sum(AMPERE_data[k,AMPERE_plot_scargle_index]); #ergs/(cm^2*sec), get the Joule Heating for the current time stamp
        #END FOR i
    
        if( AMPERE_integrate_highpassOption == 0 ): #only original data, no high-passed data
            
            #Start the AMPERE/OMNI scargle plot
            fig, ax = plt.subplots(nrows=2, ncols=1); #use instead of fig because it inits an axis too (I think I dunno)
            figManager = plt.get_current_fig_manager(); #req to maximize
            figManager.window.showMaximized(); #force maximized
            
            #-----Plot an AMPERE data index's spectrum-----            
            AMPERE_integrate_scargPeriod, AMPERE_integrate_scargPower, AMPERE_integrate_scarggf = subfun_lombscargle(AMPERE_timeUnique_hr , AMPERE_integrate); #scargle that data
            AMPERE_integrate_scargPeriod = AMPERE_integrate_scargPeriod*60; #min, adjust the period out from hrs to minutes (since hrs goes in)
            
            ax[0].plot( AMPERE_integrate_scargPeriod, AMPERE_integrate_scargPower , linewidth=PLOT_lineWidthRegular ); #plot
            ax[0].plot( AMPERE_integrate_scargPeriod, np.tile(AMPERE_integrate_scarggf,np.size(AMPERE_integrate_scargPeriod)) , color="xkcd:grey" ); #plot
            
            ax[0].set_ylabel(AMPERE_plot_scargle_label+' Normalized Power',fontproperties=FONT_axisLabelFM); #set the y axis label
            
            xAxisTicks = np.arange(0,plot_periodLim_max+10,10); #sets the start hr, stop hr, and the step size between (in this case, 4 hr)
            ax[0].set_xticks(xAxisTicks); #set x axis ticks
            
            ax[0].set_xlim( (0, plot_periodLim_max) ); #set x axis limits
            if( AMPERE_integrate_scarggf < np.max(AMPERE_integrate_scargPower[AMPERE_integrate_scargPeriod<=plot_periodLim_max])+0.1*np.max(AMPERE_integrate_scargPower[AMPERE_integrate_scargPeriod<=plot_periodLim_max]) ):
                ax[0].set_ylim( (0, np.max(AMPERE_integrate_scargPower[AMPERE_integrate_scargPeriod<=plot_periodLim_max])+0.1*np.max(AMPERE_integrate_scargPower[AMPERE_integrate_scargPeriod<=plot_periodLim_max]) ) ); #set x axis limits
            else:
                ax[0].set_ylim( (0, AMPERE_integrate_scarggf+0.1*AMPERE_integrate_scarggf ) ); #set x axis limits
            #END IF
            
            ax[0].grid(b=True, which='major', axis='x', color='xkcd:light grey'); #sets major axis grid lines to be on 
            
            string_title = AMPERE_plot_scargle_label+' and '+OMNI_plot_scargle_labelNoUnits+' - Lomb-Scargle Periodogram'; #create mecha title
            ax[0].set_title(string_title,fontproperties=FONT_titleFM); #set the title
            
            #-----Plot an OMNI data index's spectrum-----            
            OMNI_data_scargPeriod, OMNI_data_scargPower, OMNI_data_scarggf = subfun_lombscargle(OMNI_timeUnique_hr , OMNI_data[:,OMNI_dict[OMNI_plot_scargle_name]]); #scargle that data
            OMNI_data_scargPeriod = OMNI_data_scargPeriod*60; #min, adjust the period out from hrs to minutes (since hrs goes in)
                        
            ax[1].plot( OMNI_data_scargPeriod, OMNI_data_scargPower , linewidth=PLOT_lineWidthRegular ); #plot
            ax[1].plot( OMNI_data_scargPeriod, np.tile(OMNI_data_scarggf,np.size(OMNI_data_scargPeriod)) , color="xkcd:grey" ); #plot
            
            ax[1].set_xlabel("Periods (min)"+' for Date Range '+str(dateRange[0,1])+'/'+str(dateRange[0,2])+ \
                '/'+str(dateRange[0,0])+' to '+str(dateRange[-1,1])+ '/'+str(dateRange[-1,2])+'/'+str(dateRange[-1,0])+ ' (M/D/Y)',fontproperties=FONT_axisLabelFM); #set the x axis label
            ax[1].set_ylabel(OMNI_plot_scargle_labelNoUnits+' Normalized Power',fontproperties=FONT_axisLabelFM); #set the y axis label
            
            ax[1].set_xticks(xAxisTicks); #set x axis ticks
            
            ax[1].set_xlim( (0, plot_periodLim_max) ); #set x axis limits
            if( OMNI_data_scarggf < np.max(OMNI_data_scargPower[OMNI_data_scargPeriod<=plot_periodLim_max])+0.1*np.max(OMNI_data_scargPower[OMNI_data_scargPeriod<=plot_periodLim_max]) ):
                ax[1].set_ylim( (0, np.max(OMNI_data_scargPower[OMNI_data_scargPeriod<=plot_periodLim_max])+0.1*np.max(OMNI_data_scargPower[OMNI_data_scargPeriod<=plot_periodLim_max]) ) ); #set x axis limits
            else:
                ax[1].set_ylim( (0, OMNI_data_scarggf+0.1*OMNI_data_scarggf ) ); #set x axis limits
            #END IF      
            
            ax[1].grid(b=True, which='major', axis='x', color='xkcd:light grey'); #sets major axis grid lines to be on 
            
            fig.subplots_adjust(left = 0.070, right = 0.985, top = 0.96, bottom = 0.065); #sets padding to small numbers for minimal white space
            #fig.tight_layout(); #function for a tight layout, doesn't seem to do much here
            plt.show(); #req to make plot show up    
            
        elif( AMPERE_integrate_highpassOption == 1 ): #combines original data scargle and high-passed data scargle
            from subfun_highpass import subfun_highpass
            #~~~~~HIGH-PASSED ONE~~~~~       
        
            #Start the AMPERE & OMNI scargle plot
            fig, ax = plt.subplots(nrows=2,ncols=1); #use instead of fig because it inits an axis too (I think I dunno)
            figManager = plt.get_current_fig_manager(); #req to maximize
            figManager.window.showMaximized(); #force maximized
                     
            #-----Plot an AMPERE data index's spectrum-----      
            AMPERE_integrate_hp = subfun_highpass(AMPERE_timeUnique_hr,AMPERE_integrate,filter_cutoffPeriod=filter_cutoffPeriod); #high-pass that data
            
            AMPERE_integrate_scargPeriod, AMPERE_integrate_scargPower, AMPERE_integrate_scarggf = subfun_lombscargle(AMPERE_timeUnique_hr , AMPERE_integrate_hp); #scargle that data
            AMPERE_integrate_scargPeriod = AMPERE_integrate_scargPeriod*60; #min, adjust the period out from hrs to minutes (since hrs goes in)
            
            ax[0].plot( AMPERE_integrate_scargPeriod, AMPERE_integrate_scargPower , linewidth=PLOT_lineWidthRegular ); #plot
            ax[0].plot( AMPERE_integrate_scargPeriod, np.tile(AMPERE_integrate_scarggf,np.size(AMPERE_integrate_scargPeriod)) , color="xkcd:grey" ); #plot
            
            ax[0].set_ylabel(AMPERE_plot_scargle_label+' Normalized Power',fontproperties=FONT_axisLabelFM); #set the y axis label
            
            xAxisTicks = np.arange(0,plot_periodLim_max+10,10); #sets the start hr, stop hr, and the step size between (in this case, 4 hr)
            ax[0].set_xticks(xAxisTicks); #set x axis ticks
            
            ax[0].set_xlim( (0, plot_periodLim_max) ); #set x axis limits
            if( AMPERE_integrate_scarggf < np.max(AMPERE_integrate_scargPower[AMPERE_integrate_scargPeriod<=plot_periodLim_max])+0.1*np.max(AMPERE_integrate_scargPower[AMPERE_integrate_scargPeriod<=plot_periodLim_max]) ):
                ax[0].set_ylim( (0, np.max(AMPERE_integrate_scargPower[AMPERE_integrate_scargPeriod<=plot_periodLim_max])+0.1*np.max(AMPERE_integrate_scargPower[AMPERE_integrate_scargPeriod<=plot_periodLim_max]) ) ); #set x axis limits
            else:
                ax[0].set_ylim( (0, AMPERE_integrate_scarggf+0.1*AMPERE_integrate_scarggf ) ); #set x axis limits
            #END IF
            
            ax[0].grid(b=True, which='major', axis='x', color='xkcd:light grey'); #sets major axis grid lines to be on 
            
            string_title = AMPERE_plot_scargle_label+' and '+OMNI_plot_scargle_label+' w/ High-pass Cutoff Period of '+str(filter_cutoffPeriod)+' hrs - Lomb-Scargle Periodogram'; #create mecha title
            ax[0].set_title(string_title,fontproperties=FONT_titleFM); #set the title
            
            #-----Plot an OMNI data index's spectrum-----       
            OMNI_data_hp = subfun_highpass(OMNI_timeUnique_hr,OMNI_data[:,OMNI_dict[OMNI_plot_scargle_name]],filter_cutoffPeriod=filter_cutoffPeriod); #high-pass that data
            
            OMNI_data_scargPeriod, OMNI_data_scargPower, OMNI_data_scarggf = subfun_lombscargle(OMNI_timeUnique_hr , OMNI_data_hp); #scargle that data
            OMNI_data_scargPeriod = OMNI_data_scargPeriod*60; #min, adjust the period out from hrs to minutes (since hrs goes in)
                        
            ax[1].plot( OMNI_data_scargPeriod, OMNI_data_scargPower , linewidth=PLOT_lineWidthRegular ); #plot
            ax[1].plot( OMNI_data_scargPeriod, np.tile(OMNI_data_scarggf,np.size(OMNI_data_scargPeriod)) , color="xkcd:grey" ); #plot
            
            ax[1].set_xlabel("Periods (min)"+' for Date Range '+str(dateRange[0,1])+'/'+str(dateRange[0,2])+ \
                '/'+str(dateRange[0,0])+' to '+str(dateRange[-1,1])+ '/'+str(dateRange[-1,2])+'/'+str(dateRange[-1,0])+ ' (M/D/Y)',fontproperties=FONT_axisLabelFM); #set the x axis label
            ax[1].set_ylabel(OMNI_plot_scargle_label+' Normalized Power',fontproperties=FONT_axisLabelFM); #set the y axis label
        
            ax[1].set_xticks(xAxisTicks); #set x axis ticks
            
            ax[1].set_xlim( (0, plot_periodLim_max) ); #set x axis limits
            if( OMNI_data_scarggf < np.max(OMNI_data_scargPower[OMNI_data_scargPeriod<=plot_periodLim_max])+0.1*np.max(OMNI_data_scargPower[OMNI_data_scargPeriod<=plot_periodLim_max]) ):
                ax[1].set_ylim( (0, np.max(OMNI_data_scargPower[OMNI_data_scargPeriod<=plot_periodLim_max])+0.1*np.max(OMNI_data_scargPower[OMNI_data_scargPeriod<=plot_periodLim_max]) ) ); #set x axis limits
            else:
                ax[1].set_ylim( (0, OMNI_data_scarggf+0.1*OMNI_data_scarggf ) ); #set x axis limits
            #END IF     
            
            ax[1].grid(b=True, which='major', axis='x', color='xkcd:light grey'); #sets major axis grid lines to be on                
            
            fig.subplots_adjust(left = 0.070, right = 0.985, top = 0.96, bottom = 0.065); #sets padding to small numbers for minimal white space
            #fig.tight_layout(); #function for a tight layout, doesn't seem to do much here
            plt.show(); #req to make plot show up   
        #END IF
    #END IF
#END IF
   

#****************************************************************Magnetometer Times****************************************************************
if( FLG_Mag_viewAll_magF == 1 ):
    from scipy.signal import savgol_filter
    from subfun_strstr import strstr
    
    if( settings['Mag']['keo set stations'] != 1 ):
        siteNames = data['Mag']['site names']; #get the site names
    else:
        siteNames = settings['Mag']['keo set stations names']; #set the site names to whatever the user had
    #END IF
    removeList = []; #prep
    for j in range(0,len(siteNames)):
        if( ~((data['Mag'][siteNames[j]]['lat'] >= np.min(settings['Mag']['lat range'])) & \
                (data['Mag'][siteNames[j]]['lat'] <= np.max(settings['Mag']['lat range'])) & \
                (data['Mag'][siteNames[j]]['long'] >= np.min(settings['Mag']['long range'])) & \
                (data['Mag'][siteNames[j]]['long'] <= np.max(settings['Mag']['long range']))) ):
            removeList.append(siteNames[j]); #prep for removal b/c not within the range we want
        #END IF
    #END FOR j
    #solving lists takes a lot of slowww lists ohw ell
    for j in range(0,len(removeList)):
        siteNames.remove(removeList[j]); #remove the stuff we don't need
    #END FOR j
    siteNamesIndex = np.where(np.in1d(data['Mag']['site names'],siteNames))[0]; #get indexes [keeps site coloring consistent even if all are not in use]
    
    #Start the Mag time series plot
    fig, ax = plt.subplots(nrows=1,ncols=1); #use instead of fig because it inits an axis too (I think I dunno)
    figManager = plt.get_current_fig_manager(); #req to maximize
    figManager.window.showMaximized(); #force maximized
    
    #Remove the aspect ratio from the basemap so it fills the screen better
    ax.set_aspect('auto');
    
    pHolder = []; #holds some plot refs
    pLegendTitles = []; #holds the plot names for the legend
    for j in range(0,len(siteNames)):
        currTime = ((np.float64(data['Mag'][siteNames[j]]['dayNumF'])+np.float64(data['Mag'][siteNames[j]]['secF'])/86400) - dates['date range zero hr dayNum'][1])*24; #hr, per site just in case
        
        #filter function here
        temp_deltaMagF = subfun_filter( data['Mag'][siteNames[j]]['magF'], data['Mag'][siteNames[j]]['secF'], settings['Mag']['delta method'], settings['spectra'], dataRate = data['Mag'][siteNames[j]]['dataRateF'], reduceWindow = 0); #filter using the all-powerful filter function
        
        pTemp, = ax.plot( currTime, temp_deltaMagF, linewidth=settings['plot']['line width']['double plus'], color=settings['plot']['color'][siteNamesIndex[j]] ); #plot
        pHolder.append(pTemp); #record plot ref
        pLegendTitles.append(siteNames[j]+' '+str(siteNamesIndex[j])); #record the site names
    #END FOR j
    
    string_titleTemp = ''; #prep
    if( strstr(settings['Mag']['delta method'],'mean').size > 0 ):
        string_titleTemp += '0 Mean Mag'; #set the specific word to describe the data
    if( strstr(settings['Mag']['delta method'],'savgol').size > 0 ):
        if( string_titleTemp != '' ):
            string_titleTemp += ' & '; #add on an ampersand
        #END IF
        string_titleTemp += 'Delta-Mag'; #set the specific word to describe the data
    else: #otherwise do nothing
        string_titleTemp += 'Mag'; #set the specific word to describe the data
    #END IF
    string_title = string_titleTemp+' for '+str(dates['date range full'][0,1])+'/'+str(dates['date range full'][0,2])+ \
        '/'+str(dates['date range full'][0,0])+' to '+str(dates['date range full'][-1,1])+ \
        '/'+str(dates['date range full'][-1,2])+'/'+str(dates['date range full'][-1,0])+ \
        ' (M/D/Y)'; #create mecha title
    ax.set_title(string_title,fontproperties=FONT_titleFM); #set the title
    ax.set_xlabel('Time in UT [hr] - 0 Hr on '+dates['date range zero hr month name']+' '+str(dates['date range zero hr'][2]) + \
                  dates['date range zero hr day post fix']+' | Day '+str(dates['date range zero hr dayNum'][1])+', ' + \
                  str(dates['date range zero hr dayNum'][0]),fontproperties=FONT_axisLabelFM); #set the x axis label
    ax.set_ylabel('Mag Field [nT]',fontproperties=FONT_axisLabelFM); #set the y axis label
    
    if( np.mod(np.min(data['Mag']['timeUniqueF_hr']),2) == 0 ):
        time_axis_min = np.min(data['Mag']['timeUniqueF_hr']); #is even, good to go
    else:
        time_axis_min = np.min(data['Mag']['timeUniqueF_hr'])+1; #is odd, make even
    #END IF
    
    if( np.mod(np.max(data['Mag']['timeUniqueF_hr']),2) == 0 ):
        time_axis_max = np.max(data['Mag']['timeUniqueF_hr']); #is even, good to go
    else:
        time_axis_max = np.max(data['Mag']['timeUniqueF_hr'])-1; #is odd, make even
    #END IF
    xAxisTicks = np.arange(time_axis_min,time_axis_max+4,4); #sets the start hr, stop hr, and the step size between (in this case, 4 hr)
    ax.set_xticks(xAxisTicks); #set x axis ticks
    ax.set_xlim( time_axis_min , time_axis_max ); #set x axis limits
    
    ax.legend(pHolder,pLegendTitles,loc='upper left');
    
#    yAxisTicks = ; #creates y ticks automagically
#    ax.set_yticks(yAxisTicks); #set x axis ticks
    # ax.set_ylim( 0 , np.max(Kp_data)+0.5 ); #set y axis limits
    
    fig.subplots_adjust(left = 0.065, right = 0.985, top = 0.96, bottom = 0.075); #sets padding to small numbers for minimal white space
    #fig.tight_layout(); #function for a tight layout, doesn't seem to do much here
    plt.show(); #req to make plot show up
    
    #PLOT IT UP
    cntr = 0; #start cntr
    for arbiter in range(0,np.int64(np.ceil(len(siteNames)/6))):
        if( (np.abs(cntr - len(siteNames)) >= 6) & (np.remainder(np.abs(cntr - len(siteNames)),4) != 0) ):
            fig, ax = plt.subplots(nrows=2, ncols=3); #use instead of fig because it inits an axis too (I think I dunno)
            xAxisTicks = np.arange(time_axis_min,time_axis_max+8,8); #sets the start hr, stop hr, and the step size between (in this case, 4 hr)
        elif( np.abs(cntr - len(siteNames)) >= 4 ):
            fig, ax = plt.subplots(nrows=2, ncols=2); #use instead of fig because it inits an axis too (I think I dunno)
            xAxisTicks = np.arange(time_axis_min,time_axis_max+8,8); #sets the start hr, stop hr, and the step size between (in this case, 4 hr)
        elif( np.abs(cntr - len(siteNames)) >= 2 ):
            fig, ax = plt.subplots(nrows=1, ncols=2); #use instead of fig because it inits an axis too (I think I dunno)
            xAxisTicks = np.arange(time_axis_min,time_axis_max+8,8); #sets the start hr, stop hr, and the step size between (in this case, 4 hr)
        elif( np.abs(cntr - len(siteNames)) == 1 ):
            fig, ax = plt.subplots(nrows=1, ncols=1); #use instead of fig because it inits an axis too (I think I dunno)
            xAxisTicks = np.arange(time_axis_min,time_axis_max+4,4); #sets the start hr, stop hr, and the step size between (in this case, 4 hr)
        #END IF
        figManager = plt.get_current_fig_manager(); #req to maximize
        figManager.window.showMaximized(); #force maximized
        
        if( np.abs(cntr - len(siteNames)) >= 4 ):
            for i in range(0,ax.shape[0]): #helps automagically plot
                for j in range(0,ax.shape[1]): #helps automagically plot
                    if( cntr < len(siteNames) ):
                        #Remove the aspect ratio from the basemap so it fills the screen better
                        ax[i,j].set_aspect('auto');
                        
                        #---PLOT HERE---
                        currTime = ((np.float64(data['Mag'][siteNames[cntr]]['dayNumF'])+np.float64(data['Mag'][siteNames[cntr]]['secF'])/86400) - dates['date range zero hr dayNum'][1])*24; #hr, per site just in case
                        
                        #filter function here
                        temp_deltaMagF = subfun_filter( data['Mag'][siteNames[cntr]]['magF'], data['Mag'][siteNames[cntr]]['secF'], settings['Mag']['delta method'], settings['spectra'], dataRate = data['Mag'][siteNames[cntr]]['dataRateF'], reduceWindow = 0); #filter using the all-powerful filter function
        
                        pTemp, = ax[i,j].plot( currTime, temp_deltaMagF, linewidth=settings['plot']['line width']['double plus'], color=settings['plot']['color'][siteNamesIndex[cntr]] ); #plot
                            
                        #---SET AXIS LIMITS HERE---
                        ax[i,j].set_xlim( time_axis_min , time_axis_max ); #set x axis limits
                        ax[i,j].set_xticks(xAxisTicks); #set x axis ticks
                        
                        #---SET TITLES AND AXIS LABELS HERE---
                        string_title = string_titleTemp+' '+siteNames[cntr]+' '+str(siteNamesIndex[cntr]); #create mecha title
                        ax[i,j].set_title(string_title,fontproperties=FONT_titleFM); #set the title
                        if( (i == (ax.shape[0]-1) ) & (j == (ax.shape[1]-1)//2) ):
                            ax[i,j].set_xlabel('Time in UT [hr] - 0 Hr on '+dates['date range zero hr month name']+' '+str(dates['date range zero hr'][2]) + \
                                dates['date range zero hr day post fix']+' | Day '+str(dates['date range zero hr dayNum'][1])+', ' + \
                                str(dates['date range zero hr dayNum'][0]),fontproperties=FONT_axisLabelFM); #set the x axis label
                        #END IF
                        if( j == 0 ):
                            ax[i,j].set_ylabel('Mag Field [nT]',fontproperties=FONT_axisLabelFM); #set the y axis label
                        #END IF
                    #END IF
                    cntr += 1; #for counting continuously
                #END FOR j
            #END FOR i
        elif( np.abs(cntr - len(siteNames)) >= 2 ):
            for i in range(0,ax.shape[0]): #helps automagically plot
                if( cntr < len(siteNames) ):
                    #Remove the aspect ratio from the basemap so it fills the screen better
                    ax[i].set_aspect('auto');
                    
                    #---PLOT HERE---
                    currTime = ((np.float64(data['Mag'][siteNames[cntr]]['dayNumF'])+np.float64(data['Mag'][siteNames[cntr]]['secF'])/86400) - dates['date range zero hr dayNum'][1])*24; #hr, per site just in case
                    #filter function here
                    temp_deltaMagF = subfun_filter( data['Mag'][siteNames[cntr]]['magF'], data['Mag'][siteNames[cntr]]['secF'], settings['Mag']['delta method'], settings['spectra'], dataRate = data['Mag'][siteNames[cntr]]['dataRateF'], reduceWindow = 0); #filter using the all-powerful filter function
        
                    pTemp, = ax[i].plot( currTime, temp_deltaMagF, linewidth=settings['plot']['line width']['double plus'], color=settings['plot']['color'][siteNamesIndex[cntr]] ); #plot
                        
                    #---SET AXIS LIMITS HERE---
                    ax[i].set_xlim( time_axis_min , time_axis_max ); #set x axis limits
                    ax[i].set_xticks(xAxisTicks); #set x axis ticks
                    
                    #---SET TITLES AND AXIS LABELS HERE---
                    string_title = string_titleTemp+' '+siteNames[cntr]+' '+str(siteNamesIndex[cntr]); #create mecha title
                    ax[i].set_title(string_title,fontproperties=FONT_titleFM); #set the title
                    ax[i].set_xlabel('Time in UT [hr] - 0 Hr on '+dates['date range zero hr month name']+' '+str(dates['date range zero hr'][2]) + \
                        dates['date range zero hr day post fix']+' | Day '+str(dates['date range zero hr dayNum'][1])+', ' + \
                        str(dates['date range zero hr dayNum'][0]),fontproperties=FONT_axisLabelFM); #set the x axis label
                    if( i == 0 ):
                        ax[i].set_ylabel('Mag Field [nT]',fontproperties=FONT_axisLabelFM); #set the y axis label
                    #END IF
                #END IF
                cntr += 1; #for counting continuously
            #END FOR i
        elif( np.abs(cntr - len(siteNames)) == 1 ):
            if( cntr < len(siteNames) ):
                #Remove the aspect ratio from the basemap so it fills the screen better
                ax.set_aspect('auto');
                
                #---PLOT HERE---
                currTime = ((np.float64(data['Mag'][siteNames[cntr]]['dayNumF'])+np.float64(data['Mag'][siteNames[cntr]]['secF'])/86400) - dates['date range zero hr dayNum'][1])*24; #hr, per site just in case
                #filter function here
                temp_deltaMagF = subfun_filter( data['Mag'][siteNames[cntr]]['magF'], data['Mag'][siteNames[cntr]]['secF'], settings['Mag']['delta method'], settings['spectra'], dataRate = data['Mag'][siteNames[cntr]]['dataRateF'], reduceWindow = 0); #filter using the all-powerful filter function
        
                pTemp, = ax.plot( currTime, temp_deltaMagF, linewidth=settings['plot']['line width']['double plus'], color=settings['plot']['color'][siteNamesIndex[cntr]] ); #plot
                    
                #---SET AXIS LIMITS HERE---
                ax.set_xlim( time_axis_min , time_axis_max ); #set x axis limits
                ax.set_xticks(xAxisTicks); #set x axis ticks
                
                #---SET TITLES AND AXIS LABELS HERE---
                string_title = string_titleTemp+' '+siteNames[cntr]+' '+str(siteNamesIndex[cntr]); #create mecha title
                ax.set_title(string_title,fontproperties=FONT_titleFM); #set the title

                ax.set_xlabel('Time in UT [hr] - 0 Hr on '+dates['date range zero hr month name']+' '+str(dates['date range zero hr'][2]) + \
                    dates['date range zero hr day post fix']+' | Day '+str(dates['date range zero hr dayNum'][1])+', ' + \
                    str(dates['date range zero hr dayNum'][0]),fontproperties=FONT_axisLabelFM); #set the x axis label

                ax.set_ylabel('Mag Field [nT]',fontproperties=FONT_axisLabelFM); #set the y axis label
            #END IF
            cntr += 1; #for counting continuously         
        #END IF
        
        #final plot adjusting stuff
        fig.subplots_adjust(left = 0.065, right = 0.985, top = 0.96, bottom = 0.075 , hspace = 0.175, wspace = 0.275); #sets padding to small numbers for minimal white space
        # fig.tight_layout(); #function for a tight layout, doesn't seem to do much here
        plt.show(); #req to make plot show up
    
#END IF


if( FLG_Mag_viewAll_magF_FFT == 1 ):
    from scipy import signal
    from scipy.signal import savgol_filter
    
    if( settings['Mag']['keo set stations'] != 1 ):
        siteNames = data['Mag']['site names']; #get the site names
    else:
        siteNames = settings['Mag']['keo set stations names']; #set the site names to whatever the user had
    #END IF
    removeList = []; #prep
    for j in range(0,len(siteNames)):
        if( ~((data['Mag'][siteNames[j]]['lat'] >= np.min(settings['Mag']['lat range'])) & \
                (data['Mag'][siteNames[j]]['lat'] <= np.max(settings['Mag']['lat range'])) & \
                (data['Mag'][siteNames[j]]['long'] >= np.min(settings['Mag']['long range'])) & \
                (data['Mag'][siteNames[j]]['long'] <= np.max(settings['Mag']['long range']))) ):
            removeList.append(siteNames[j]); #prep for removal b/c not within the range we want
        #END IF
    #END FOR j
    #solving lists takes a lot of slowww lists ohw ell
    for j in range(0,len(removeList)):
        siteNames.remove(removeList[j]); #remove the stuff we don't need
    #END FOR j
    siteNamesIndex = np.where(np.in1d(data['Mag']['site names'],siteNames))[0]; #get indexes [keeps site coloring consistent even if all are not in use]
    
    time_range = np.array( ((time_Ref[0]-dateRange_dayNum_zeroHr[1]*86400) , (time_Ref[-1]-dateRange_dayNum_zeroHr[1]*86400)) ); #make a time range based on the reference time
    time_rangeRound = np.int64(np.floor(np.abs(time_range))*(time_range/np.abs(time_range))); #get the absolute hours - absolute shennanigans are to get floor to floor -11.3 -> -11 and not -12
    thruTime_num = np.int64((np.diff(time_rangeRound).item()-thruTime_width)/thruTime_step)+1; #number of times the time_rangeRound can be split into the required width and step size
    thruTime = np.zeros( (thruTime_num,2) ); #prep array
    for i in range(0,thruTime_num):
        thruTime[i,0] = time_rangeRound[0]+i*thruTime_step; #get the starting time
        thruTime[i,1] = thruTime[i,0] + thruTime_width; #get the ending time
    #END FOR i
    
    thruTime_spectral = [[] for i in range(0,len(siteNames))]; #prep a holder for the spectral info
    thruTime_freq = [[] for i in range(0,len(siteNames))]; #prep a holder for the spectral info
    for i in range(0,len(siteNames)):
        #OMNI
        thruTime_spectral[i] = np.zeros([thruTime_num,np.int64(settings_spectra['nfft']['6min']/2+1)]); #preallocate in the list
        thruTime_freq[i] = np.zeros([thruTime_num,np.int64(settings_spectra['nfft']['6min']/2+1)]); #preallocate in the list
    #END FOR i
    
    #---MAG---
    magF_delta_timeMatch = [[] for j in range(0,len(siteNames))]; #prep a holder
    magF_timeUnique_timeMatch = [[] for j in range(0,len(siteNames))]; #prep a holder
    for j in range(0,len(siteNames)):
        if( np.abs(data['Mag'][siteNames[j]]['dataRateF']/60-6) > 0.05 ):
            sixMin_timeUnique_min = np.arange(0,dateRange_dayNum_full.shape[0]*24*60,6); #-time_cutout_range_delay_OMNI*60; #min, arange time stamps
            sixMin_timeUnique = sixMin_timeUnique_min/60/24+dateRange_dayNum_full[0,1]; #days, get the right day time stamps
            #adjust MAG
            #filter function here
            temp_deltaMagF = subfun_filter( data['Mag'][siteNames[j]]['magF'], data['Mag'][siteNames[j]]['secF'], settings['Mag']['delta method'], settings['spectra'], dataRate = data['Mag'][siteNames[j]]['dataRateF'], reduceWindow = 0); #filter using the all-powerful filter function
        
            magF_delta_timeMatch[j] = temp_deltaMagF; #set whatever method was used for adjustments
            magF_timeUnique_timeMatch[j] = np.float64(data['Mag'][siteNames[j]]['dayNumF']) + np.float64(data['Mag'][siteNames[j]]['secF'])/86400; #days, get unique times (v useful) 
            magF_delta_timeMatch[j], _, magF_timeUnique_timeMatch[j] = GRITI_TEC_avgPt_timeMatch(magF_delta_timeMatch[j],magF_timeUnique_timeMatch[j],sixMin_timeUnique,dateRange_dayNum_zeroHr,filter_cutoffPeriod=settings_spectra['filter cutoff period']);
        else:
            #fix so it works good
            #filter function here
            temp_deltaMagF = subfun_filter( data['Mag'][siteNames[j]]['magF'], data['Mag'][siteNames[j]]['secF'], settings['Mag']['delta method'], settings['spectra'], dataRate = data['Mag'][siteNames[j]]['dataRateF'], reduceWindow = 0); #filter using the all-powerful filter function
        
            magF_delta_timeMatch[j] = temp_deltaMagF; #set whatever method was used for adjustments
            magF_timeUnique_timeMatch[j] = np.float64(data['Mag'][siteNames[j]]['dayNumF']) + np.float64(data['Mag'][siteNames[j]]['secF'])/86400; #days, get unique times (v useful) #set so no errors
        #END IF
    #END FOR j
    
    Fs = 1/6; #set the freq to be 1/6 min b/c it's forced to be that
    for j in range(0,len(siteNames)):
        #MAG NOW
        
        for i in range(0,thruTime_num):
            time_cutout_indexes = np.array( ( np.where(np.min(np.abs( (magF_timeUnique_timeMatch[j]-dateRange_dayNum_zeroHr[1]*86400) - np.min(thruTime[i,:]) )) == np.abs( (magF_timeUnique_timeMatch[j]-dateRange_dayNum_zeroHr[1]*86400) - np.min(thruTime[i,:]) ) )[0][0] , \
                np.where(np.min(np.abs( (magF_timeUnique_timeMatch[j]-dateRange_dayNum_zeroHr[1]*86400) - np.max(thruTime[i,:]) )) == np.abs( (magF_timeUnique_timeMatch[j]-dateRange_dayNum_zeroHr[1]*86400) - np.max(thruTime[i,:]) ) )[0][0] ) ); #get the indexes for that time cutout range
            
            magF_delta_timeMatch_cutOut = magF_delta_timeMatch[j][time_cutout_indexes[0]:time_cutout_indexes[1]+1];
            currTime_cutOut = magF_timeUnique_timeMatch[j][time_cutout_indexes[0]:time_cutout_indexes[1]+1];
            
            pwr_Mag = np.sqrt(1/magF_delta_timeMatch_cutOut.size*np.sum(magF_delta_timeMatch_cutOut**2)); #estimate power of signal
            
            #TEC STUFF
            [freqs_Mag,Cxx_Mag] = signal.welch(1/pwr_Mag*magF_delta_timeMatch_cutOut ,window=settings_spectra['window'],noverlap=settings_spectra['noverlap'],nfft=settings_spectra['nfft']['6min'],fs=Fs);
            
            thruTime_spectral[j][i,:] = Cxx_Mag; #record
            thruTime_freq[j][i,:] = freqs_Mag; #record
        #END FOR i
    #END FOR j

    #PLOT IT UP
    warnings.filterwarnings("ignore", category=RuntimeWarning); #silences warnings about NaNs used in a logical comparisons #yolo
    FLG_sameColorLimits = 0; #if 0 different, if 1 samesies
    string_titleTemp = ''; #prep
    if( strstr(settings['Mag']['delta method'],'mean').size > 0 ):
        string_titleTemp += '0 Mean Mag'; #set the specific word to describe the data
    if( strstr(settings['Mag']['delta method'],'savgol').size > 0 ):
        if( string_titleTemp != '' ):
            string_titleTemp += ' & '; #add on an ampersand
        #END IF
        string_titleTemp += 'Delta-Mag'; #set the specific word to describe the data
    else: #otherwise do nothing
        string_titleTemp += 'Mag'; #set the specific word to describe the data
    #END IF
    xAxisTicks = np.arange( np.round(np.min(1/freqs_Mag)/20)*20, settings_spectra['period limit max']+20, 20); #sets the start hr, stop hr, and the step size between (in this case, 2 hr)
    cntr = 0; #start cntr
    for arbiter in range(0,np.int64(np.ceil(len(siteNames)/6))):
        if( (np.abs(cntr - len(siteNames)) >= 6) & (np.remainder(np.abs(cntr - len(siteNames)),4) != 0) ):
            fig, ax = plt.subplots(nrows=2, ncols=3); #use instead of fig because it inits an axis too (I think I dunno)
        elif( np.abs(cntr - len(siteNames)) >= 4 ):
            fig, ax = plt.subplots(nrows=2, ncols=2); #use instead of fig because it inits an axis too (I think I dunno)
        elif( np.abs(cntr - len(siteNames)) >= 2 ):
            fig, ax = plt.subplots(nrows=1, ncols=2); #use instead of fig because it inits an axis too (I think I dunno)
        elif( np.abs(cntr - len(siteNames)) == 1 ):
            fig, ax = plt.subplots(nrows=1, ncols=1); #use instead of fig because it inits an axis too (I think I dunno)
        #END IF
        figManager = plt.get_current_fig_manager(); #req to maximize
        figManager.window.showMaximized(); #force maximized
        
        # if( np.max(thruTime_spectral[:,:,1/freqs_Mag <= settings_spectra['period limit max']]) > 200 ):
        #     rounder = 50; #set to round to every 50
        # else:
        #     rounder = 25; #set to round to every 25
        # #END IF
        # vMax = np.ceil(np.max(thruTime_spectral[:,:,1/freqs_Mag <= settings_spectra['period limit max']])/rounder)*rounder; #get the overall max - FLG_sameColorLimits=0 overrides this
        
        if( np.abs(cntr - len(siteNames)) >= 4 ):
            for i in range(0,ax.shape[0]): #helps automagically plot
                for j in range(0,ax.shape[1]): #helps automagically plot
                    if( cntr < len(siteNames) ):
                        if( FLG_sameColorLimits == 0 ):
                            if( np.max(thruTime_spectral[cntr][:,:]) > 200 ):
                                rounder = 50; #set to round to every 50
                            elif( np.max(thruTime_spectral[cntr][:,:]) < 0.5 ):
                                rounder = 0.5; #set to round to every 50
                            else:
                                rounder = 25; #set to round to every 25
                            #END IF
                            vMax = np.ceil(np.max(thruTime_spectral[cntr][:,:])/rounder)*rounder; #get the max for the plot itself
                        #END IF
                        #prep colorbar
                        divider = make_axes_locatable(ax[i,j]); #prep to add an axis
                        cax = divider.append_axes('right', size='2.0%', pad=0.15); #make a color bar axis
                        #Remove the aspect ratio from the basemap so it fills the screen better
                        ax[i,j].set_aspect('auto');
                        
                        tempTime = np.copy(thruTime[:,0]);
                        # if( (i == 0) & (j == 1) ):
                        #     tempTime = tempTime + time_cutout_range_delay_AMPERE; #shift by this
                        # #END IF
                        
                        pltHelprX, pltHelprY = np.meshgrid( tempTime, 1/thruTime_freq[cntr][0,:]);
                        #gotta catch inf
                        pltHelprY[np.isinf(pltHelprY)] = np.max(pltHelprY[~np.isinf(pltHelprY)])*2; #remove the infs
                        im = ax[i,j].pcolormesh(pltHelprX, pltHelprY,  thruTime_spectral[cntr][:,:].T , \
                            vmin=0, vmax=vMax, cmap='nipy_spectral'); # pseudocolor plot "stretched" to the grid
                        cbar = fig.colorbar(im, cax=cax, orientation='vertical'); #create a colorbar using the prev. defined cax
                        # cax.yaxis.set_major_formatter(tick.FormatStrFormatter('%.1f')); #force a rounded format
                        cbar.ax.tick_params(labelsize=FONT_axisTick);
                        cbar.mappable.set_clim(vmin=0, vmax=vMax);
                        # cax.yaxis.set_ticks(np.linspace(np.min(TEC_plotLimValu),np.max(TEC_plotLimValu),11)); #create useful tick marks
                        ax[i,j].set_title('Power Spectra for '+string_titleTemp+' - '+str(thruTime_width)+' hr width', \
                            fontproperties=FONT_titleFM);
                        ax[i,j].set_yticks(xAxisTicks); #set y axis ticks
                        ax[i,j].set_ylim( (np.min(1/thruTime_freq[cntr][0,:]), settings_spectra['period limit max']/60) ); #set the axis limit
                        ax[i,j].set_xlim( (np.min(thruTime[:,0]), np.max(thruTime[:,0])) ); #set the axis limit
                        ax[i,j].set_xticks(np.arange( np.min(thruTime[:,0]), np.max(thruTime[:,0]), 8 )); #set y axis ticks
                        
                        if( (i == (ax.shape[0]-1) ) & (j == (ax.shape[1]-1)//2) ):
                            ax[i,j].set_xlabel('Time in UT [hr] - 0 Hr on '+dateRange_zeroHr_monthName+ \
                                ' '+str(dateRange_zeroHr[2])+dateRange_zeroHr_dayPostfix+' | Day '+ \
                                str(dateRange_dayNum_zeroHr[1])+', '+str(dateRange_dayNum_zeroHr[0]),fontproperties=FONT_axisLabelFM);
                        #END IF
                        if( j == 0 ):
                            ax[i,j].set_ylabel('Periods [min]',fontproperties=FONT_axisLabelFM);
                        elif( j == (ax.shape[1] - 1) ):
                            cbar.set_label('Arb. Power'); #tabel the colorbar
                            cax.yaxis.label.set_font_properties(FONT_axisLabelFM);
                        #END IF
                        ax[i,j].set_title(string_titleTemp+' '+siteNames[cntr]+' ['+str(siteNamesIndex[cntr])+']', fontproperties=FONT_titleFM);
                        # ax[i,j].set_title(AMPERE_plot_label_noUnits+' offset by '+str(time_cutout_range_delay_AMPERE)+' hrs', fontproperties=FONT_titleFM);
                        #END IF
                    #END IF
                    cntr += 1; #for counting continuously
                #END FOR j
            #END FOR i
        elif( np.abs(cntr - len(siteNames)) >= 2 ):
            for i in range(0,ax.shape[0]): #helps automagically plot
                if( cntr < len(siteNames) ):
                    if( FLG_sameColorLimits == 0 ):
                        if( np.max(thruTime_spectral[cntr][:,:]) > 200 ):
                            rounder = 50; #set to round to every 50
                        elif( np.max(thruTime_spectral[cntr][:,:]) < 0.5 ):
                            rounder = 0.5; #set to round to every 50
                        else:
                            rounder = 25; #set to round to every 25
                        #END IF
                        vMax = np.ceil(np.max(thruTime_spectral[cntr][:,:])/rounder)*rounder; #get the max for the plot itself
                    #END IF
                    #prep colorbar
                    divider = make_axes_locatable(ax[i]); #prep to add an axis
                    cax = divider.append_axes('right', size='2.0%', pad=0.15); #make a color bar axis
                    #Remove the aspect ratio from the basemap so it fills the screen better
                    ax[i].set_aspect('auto');
                    
                    tempTime = np.copy(thruTime[:,0]);
                    # if( (i == 0) & (j == 1) ):
                    #     tempTime = tempTime + time_cutout_range_delay_AMPERE; #shift by this
                    # #END IF
                    
                    pltHelprX, pltHelprY = np.meshgrid( tempTime, 1/thruTime_freq[cntr][0,:]);
                    #gotta catch inf
                    pltHelprY[np.isinf(pltHelprY)] = np.max(pltHelprY[~np.isinf(pltHelprY)])*2; #remove the infs
                    im = ax[i].pcolormesh(pltHelprX, pltHelprY,  thruTime_spectral[cntr][:,:].T , \
                        vmin=0, vmax=vMax, cmap='nipy_spectral'); # pseudocolor plot "stretched" to the grid
                    cbar = fig.colorbar(im, cax=cax, orientation='vertical'); #create a colorbar using the prev. defined cax
                    # cax.yaxis.set_major_formatter(tick.FormatStrFormatter('%.1f')); #force a rounded format
                    cbar.ax.tick_params(labelsize=FONT_axisTick);
                    cbar.mappable.set_clim(vmin=0, vmax=vMax);
                    # cax.yaxis.set_ticks(np.linspace(np.min(TEC_plotLimValu),np.max(TEC_plotLimValu),11)); #create useful tick marks
                    ax[i].set_title('Power Spectra for '+string_titleTemp+' - '+str(thruTime_width)+' hr width', \
                        fontproperties=FONT_titleFM);
                    ax[i].set_yticks(xAxisTicks); #set y axis ticks
                    ax[i].set_ylim( (np.min(1/thruTime_freq[cntr][0,:]), settings_spectra['period limit max']/60) ); #set the axis limit
                    ax[i].set_xlim( (np.min(thruTime[:,0]), np.max(thruTime[:,0])) ); #set the axis limit
                    ax[i].set_xticks(np.arange( np.min(thruTime[:,0]), np.max(thruTime[:,0]), 8 )); #set y axis ticks
                    
                    ax[i].set_xlabel('Time in UT [hr] - 0 Hr on '+dateRange_zeroHr_monthName+ \
                        ' '+str(dateRange_zeroHr[2])+dateRange_zeroHr_dayPostfix+' | Day '+ \
                        str(dateRange_dayNum_zeroHr[1])+', '+str(dateRange_dayNum_zeroHr[0]),fontproperties=FONT_axisLabelFM);
                            
                    if( i == 0 ):
                        ax[i].set_ylabel('Periods [min]',fontproperties=FONT_axisLabelFM);
                    elif( i == (ax.shape[0] - 1) ):
                        cbar.set_label('Arb. Power'); #tabel the colorbar
                        cax.yaxis.label.set_font_properties(FONT_axisLabelFM);
                    #END IF
                    ax[i].set_title(string_titleTemp+' '+siteNames[cntr]+' ['+str(siteNamesIndex[cntr])+']', fontproperties=FONT_titleFM);
                    # ax[i].set_title(AMPERE_plot_label_noUnits+' offset by '+str(time_cutout_range_delay_AMPERE)+' hrs', fontproperties=FONT_titleFM);
                    #END IF
                #END IF
                cntr += 1; #for counting continuously
            #END FOR i
        elif( np.abs(cntr - len(siteNames)) == 1 ):
            if( cntr < len(siteNames) ):
                if( FLG_sameColorLimits == 0 ):
                    if( np.max(thruTime_spectral[cntr][:,:]) > 200 ):
                        rounder = 50; #set to round to every 50
                    elif( np.max(thruTime_spectral[cntr][:,:]) < 0.5 ):
                        rounder = 0.5; #set to round to every 50
                    else:
                        rounder = 25; #set to round to every 25
                    #END IF
                    vMax = np.ceil(np.max(thruTime_spectral[cntr][:,:])/rounder)*rounder; #get the max for the plot itself
                #END IF
                #prep colorbar
                divider = make_axes_locatable(ax); #prep to add an axis
                cax = divider.append_axes('right', size='2.0%', pad=0.15); #make a color bar axis
                #Remove the aspect ratio from the basemap so it fills the screen better
                ax.set_aspect('auto');
                
                tempTime = np.copy(thruTime[:,0]);
                # if( (i == 0) & (j == 1) ):
                #     tempTime = tempTime + time_cutout_range_delay_AMPERE; #shift by this
                # #END IF
                
                pltHelprX, pltHelprY = np.meshgrid( tempTime, 1/thruTime_freq[cntr][0,:]);
                #gotta catch inf
                pltHelprY[np.isinf(pltHelprY)] = np.max(pltHelprY[~np.isinf(pltHelprY)])*2; #remove the infs
                im = ax.pcolormesh(pltHelprX, pltHelprY,  thruTime_spectral[cntr][:,:].T , \
                    vmin=0, vmax=vMax, cmap='nipy_spectral'); # pseudocolor plot "stretched" to the grid
                cbar = fig.colorbar(im, cax=cax, orientation='vertical'); #create a colorbar using the prev. defined cax
                # cax.yaxis.set_major_formatter(tick.FormatStrFormatter('%.1f')); #force a rounded format
                cbar.ax.tick_params(labelsize=FONT_axisTick);
                cbar.mappable.set_clim(vmin=0, vmax=vMax);
                # cax.yaxis.set_ticks(np.linspace(np.min(TEC_plotLimValu),np.max(TEC_plotLimValu),11)); #create useful tick marks
                ax.set_title('Power Spectra for '+string_titleTemp+' - '+str(thruTime_width)+' hr width', \
                    fontproperties=FONT_titleFM);
                ax.set_yticks(xAxisTicks); #set y axis ticks
                ax.set_ylim( (np.min(1/thruTime_freq[cntr][0,:]), settings_spectra['period limit max']/60) ); #set the axis limit
                ax.set_xlim( (np.min(thruTime[:,0]), np.max(thruTime[:,0])) ); #set the axis limit
                ax.set_xticks(np.arange( np.min(thruTime[:,0]), np.max(thruTime[:,0]), 8 )); #set y axis ticks
                
                ax.set_xlabel('Time in UT [hr] - 0 Hr on '+dateRange_zeroHr_monthName+ \
                    ' '+str(dateRange_zeroHr[2])+dateRange_zeroHr_dayPostfix+' | Day '+ \
                    str(dateRange_dayNum_zeroHr[1])+', '+str(dateRange_dayNum_zeroHr[0]),fontproperties=FONT_axisLabelFM);
                    
                ax.set_ylabel('Periods [min]',fontproperties=FONT_axisLabelFM);
                
                cbar.set_label('Arb. Power'); #tabel the colorbar
                cax.yaxis.label.set_font_properties(FONT_axisLabelFM);

                ax.set_title(string_titleTemp+' '+siteNames[cntr]+' ['+str(siteNamesIndex[cntr])+']', fontproperties=FONT_titleFM);
                # ax.set_title(AMPERE_plot_label_noUnits+' offset by '+str(time_cutout_range_delay_AMPERE)+' hrs', fontproperties=FONT_titleFM);
                #END IF
            #END IF
            cntr += 1; #for counting continuously         
        #END IF
        
        #final plot adjusting stuff
        fig.subplots_adjust(left = 0.060, right = 0.945, top = 0.96, bottom = 0.075 , hspace = 0.175, wspace = 0.275); #sets padding to small numbers for minimal white space
        # fig.tight_layout(); #function for a tight layout, doesn't seem to do much here
        plt.show(); #req to make plot show up
    #END FOR arbiter
    warnings.filterwarnings("default", category=RuntimeWarning); #silences warnings about NaNs used in a logical comparisons #yolo
    
#END IF

if( FLG_Mag_geoPlot == 1 ):
    import cartopy as cartopy
    import matplotlib.pyplot as plt
    import matplotlib.ticker as mticker
    # from cartopy.mpl.gridliner import LONGITUDE_FORMATTER, LATITUDE_FORMATTER
    
    def strike(text): #from https://stackoverflow.com/questions/25244454/python-create-strikethrough-strikeout-overstrike-string-type @pdw
        result = ''
        for c in text:
            result = result + c + '\u0336'
        return result
    #END DEF
    
    #---PREP TO PLOT HERE---
    if( settings['Mag']['keo set stations'] != 1 ):
        siteNames = data['Mag']['site names']; #get the site names
    else:
        siteNames = settings['Mag']['keo set stations names']; #set the site names to whatever the user had
    #END IF
    removeList = []; #prep
    for j in range(0,len(siteNames)):
        if( ~((data['Mag'][siteNames[j]]['lat'] >= np.min(settings['Mag']['lat range'])) & \
                (data['Mag'][siteNames[j]]['lat'] <= np.max(settings['Mag']['lat range'])) & \
                (data['Mag'][siteNames[j]]['long'] >= np.min(settings['Mag']['long range'])) & \
                (data['Mag'][siteNames[j]]['long'] <= np.max(settings['Mag']['long range']))) ):
            removeList.append(siteNames[j]); #prep for removal b/c not within the range we want
        #END IF
    #END FOR j
    #solving lists takes a lot of slowww lists ohw ell
    for j in range(0,len(removeList)):
        siteNames.remove(removeList[j]); #remove the stuff we don't need
    #END FOR j
    siteNamesIndex = np.where(np.in1d(data['Mag']['site names'],siteNames))[0]; #get indexes [keeps site coloring consistent even if all are not in use]
    
    siteLocs = np.zeros( (2, len(siteNames)) ); #preallocate
    for j in range(0,len(siteNames)):
        siteLocs[0,j] = data['Mag'][siteNames[j]]['lat'];
        siteLocs[1,j] = data['Mag'][siteNames[j]]['long'];
    #END FOR j
    
    map_plotLatRange = settings['Mag']['lat range'];
    map_plotLongRange = settings['Mag']['long range'];
    
    #plot help with autotick calculating
    map_long_autoTick = (np.max(map_plotLongRange) - np.min(map_plotLongRange))/25; #tries to split the longitude range into 25 parts (based off of 360/15+1)
    if( map_long_autoTick > 14 ):
        map_long_autoTick = 30; #sets the tick setting to 15 arcdegrees per tick
    elif( map_long_autoTick > 10 ):
        map_long_autoTick = 15; #sets the tick setting to 15 arcdegrees per tick
    elif( map_long_autoTick > 5 ):
        map_long_autoTick = 10; #sets the tick setting to 10 arcdegrees per tick
    elif( map_long_autoTick > 2 ):
        map_long_autoTick = 5; #sets the tick setting to 5 arcdegrees per tick
    elif( map_long_autoTick > 1 ):
        map_long_autoTick = 2; #sets the tick setting to 5 arcdegrees per tick
    elif( map_long_autoTick >= 0.6 ): #0.6 because 15/25 = 0.6, so there will be enough 1 arcdeg ticks
        map_long_autoTick = 1; #sets the tick setting to 1 arcdegree per tick
    else:
        map_long_autoTick = (np.max(map_plotLongRange) - np.min(map_plotLongRange))/15; #just goes for it if it's a super tiny range
    #END IF
    map_lat_autoTick = (np.max(map_plotLatRange) - np.min(map_plotLatRange))/13; #tries to split the latitude range into 13 parts (based off of 180/15+1)
    if( map_lat_autoTick > 10 ):
        map_lat_autoTick = 15; #sets the tick setting to 15 arcdegrees per tick
    elif( map_lat_autoTick > 5 ):
        map_lat_autoTick = 10; #sets the tick setting to 10 arcdegrees per tick
    elif( map_lat_autoTick > 2 ):
        map_lat_autoTick = 5; #sets the tick setting to 5 arcdegrees per tick
    elif( map_lat_autoTick > 1 ):
        map_lat_autoTick = 2; #sets the tick setting to 2 arcdegrees per tick
    elif( map_lat_autoTick > 0.75 ): #0.75 because 10/13 = 0.76something and it sounded good for enough 1 arcdeg ticks
        map_lat_autoTick = 1; #sets the tick setting to 1 arcdegree per tick
    else:
        map_lat_autoTick = (np.max(map_plotLatRange) - np.min(map_plotLatRange))/13; #just goes for it if it's a super tiny range
    #END IF

    #---START TO PLOT HERE---
    fig = plt.figure(); #use instead of fig because it inits an axis too (I think I dunno)
    figManager = plt.get_current_fig_manager(); #req to maximize
    figManager.window.showMaximized(); #force maximized
    
    ax = fig.add_subplot(1,1,1, projection=settings['map']['projection']);
    # divider = make_axes_locatable(ax[0]); #prep to add an axis
    # dividerKeo = make_axes_locatable(ax[1]); #prep to add an axis
    ax.set_aspect('auto');
    
    #---ADD GRID LINES, SET PLOTTING AREA---
    gl = ax.gridlines(linewidth=1, color='black', alpha=0.5, linestyle='--', draw_labels=True); #draw some well-described gridlines
    gl.xlabels_top = False; #turn off all, let ticks be handled by set_xticks
    gl.xlabels_bottom = False; #turn off all, let ticks be handled by set_xticks
    gl.ylabels_right = False; #turn off all, let ticks be handled by set_yticks
    gl.ylabels_left = False; #turn off all, let ticks be handled by set_yticks
    gl.xlocator = mticker.FixedLocator(np.arange(np.min(map_plotLongRange),np.max(map_plotLongRange)+map_long_autoTick,map_long_autoTick)); #this works ok, but be consistent use set_xticks
    gl.ylocator = mticker.FixedLocator(np.arange(np.min(map_plotLatRange),np.max(map_plotLatRange)+map_lat_autoTick,map_lat_autoTick)); #this doesn't plot -90 and 90 labels, but is req to get the gridlines right
    ax.set_xticks(np.arange(np.min(map_plotLongRange),np.max(map_plotLongRange)+map_long_autoTick,map_long_autoTick),crs=settings['map']['projection']); #gotta plot ticks with this to get -90 and 90
    ax.set_yticks(np.arange(np.min(map_plotLatRange),np.max(map_plotLatRange)+map_lat_autoTick,map_lat_autoTick),crs=settings['map']['projection']); #gotta plot ticks with this to get -90 and 90
    # gl.xformatter = LONGITUDE_FORMATTER
    # gl.yformatter = LATITUDE_FORMATTER
    # gl.xlabel_style = {'color': 'red', 'weight': 'bold'}
    ax.set_extent(map_plotLongRange + map_plotLatRange); #set the plot extent, set at end - x and y ticks can extend plot area so this'll reign it in
    
    #---DRAW SOME COASTLINES, MAYBE COLOR IN SOME STUFF---
    bbox = ax.get_window_extent().transformed(fig.dpi_scale_trans.inverted()); #get info on the size of the plot area to know what geographic scale to use
    mapper_resolution = np.max( [np.abs(map_plotLatRange[0]-map_plotLatRange[1])/bbox.height , np.abs(map_plotLongRange[0]-map_plotLongRange[1])/bbox.width] ); #degc, max extent covered in the plot
    if( mapper_resolution > 20 ): #arbitrary numbers
        mapper_resolution = '110m'; #the resolution to use for plotting geographical features
    elif( mapper_resolution > 0.5 ): #arbitrary numbers
        mapper_resolution = '50m'; #the resolution to use for plotting geographical features
    else:
        #otherwise if the deg/in for the plot is super small use the highest detail possible
        mapper_resolution = '10m'; #the resolution to use for plotting geographical features
    #END IF
    if( settings['map']['world color'] == True ):
        ax.add_feature(cartopy.feature.NaturalEarthFeature('physical', 'land', mapper_resolution, edgecolor='face', facecolor=settings['map']['land color'], alpha=0.75)); #idk what these calls really mean
        ax.add_feature(cartopy.feature.NaturalEarthFeature('physical', 'ocean', mapper_resolution, edgecolor='face', facecolor=settings['map']['water color'], alpha=0.75)); #idk what these calls really mean
    #END IF
    ax.coastlines(resolution=mapper_resolution, color='xkcd:black'); #draw the coastlines
    #reinforce axis limits after this drawing stuff
    ax.set_xlim(map_plotLongRange); #set x limits
    ax.set_ylim(map_plotLatRange); #set y limits
    
    
    #---ACTUALLY PLOT REAL STUFF HERE---
    sN = []; #prep empty list of text handles
    mN = []; #prep empty list of text handles
    for j in range(0,len(siteNames)):
        mN.append( ax.plot( siteLocs[1,j], siteLocs[0,j], color=settings['plot']['color'][siteNamesIndex[j]], marker=settings['map']['marker type'], markersize=settings['map']['marker size'], linewidth=0, zorder=50, transform=settings['map']['projection'] ) ); #plot the sites
        sN.append( ax.text(siteLocs[1,j],siteLocs[0,j],siteNames[j]+'\n  '+str(siteNamesIndex[j])+'', zorder=55, transform=settings['map']['projection']) ); #write name of site
    #END FOR j
    if( settings['Mag']['keo set stations'] == 1 ):
        sitesRedacted = np.setxor1d(data['Mag']['site names'],settings['Mag']['keo set stations names']);
        siteNamesIndex = np.where(np.in1d(data['Mag']['site names'],sitesRedacted))[0]; #get indexes [keeps site coloring consistent even if all are not in use]
        sNR = []; #prep empty list of text handles
        mNR = []; #prep empty list of text handles
        for j in range(0,len(sitesRedacted)):
            mNR.append( ax.plot( data['Mag'][sitesRedacted[j]]['long'], data['Mag'][sitesRedacted[j]]['lat'], color=settings['plot']['color'][siteNamesIndex[j]], marker=settings['map']['marker type'], markersize=settings['map']['marker size'], linewidth=0, zorder=50, transform=settings['map']['projection'] ) ); #plot the sites
            sNR.append( ax.text( data['Mag'][sitesRedacted[j]]['long'], data['Mag'][sitesRedacted[j]]['lat'], strike(sitesRedacted[j])+'\n  '+str(siteNamesIndex[j])+'', zorder=55, transform=settings['map']['projection'], c='xkcd:grey') ); #write name of site
        #END FOR j
    #END IF
    ax.set_title('NR Canada Magnetic Observatories',fontproperties=FONT_titleFM); #set the title
    
    #---FINALIZE PLOTTING---
    fig.subplots_adjust(left = 0.045, right = 0.980, top = 0.96, bottom = 0.065); #sets padding to small numbers for minimal white space
    #fig.tight_layout(); #function for a tight layout, doesn't seem to do much here
    plt.show(); #req to make plot show up
#END IF


if( FLG_Mag_keo == 1 ):
    (data['Mag']['keo'], data['Mag']['keo time'], data['Mag']['keo time hr'], \
    settings['Mag']['keo angle'],settings['Mag']['keo width'], \
    settings['Mag']['keo plot range chunks'],settings['Mag']['keo plot range name']) = \
        GRITI_Mag_keo(data,dates,settings,FLG_disablePlot=0);
    #call the mecha function that runs the keo alg and makes a plot showing the averaging area [FLG_normalize makes each site normalized to each other - the magnitude reduces as latitude drops]
#END IF

if( FLG_Mag_keo_plot == 1 ):
    #-----Plot TEC results as a Keogram-----
    GRITI_Mag_keo_plot(data, dates, settings);
    #call the mecha function that plots the keo'd Mag data
#END IF


#****************************************************************Machine Learning Times****************************************************************
if( FLG_magicks == 1 ):
    #Runs on PyTorch cause that's what people said was easier
    # import torch
    # import torch.nn as nn
    # import torch.nn.parallel
    # import torch.optim as optim
    # import torch.utils.data
    # from torch.autograd import Variable
    pass; #nothing here yet
#END IF

      
#****************************************************************MOVIE ANALYSIS****************************************************************
#!!! Make Animated Gif of TEC with Time - Fixed Dot Version !!!
if(FLG_enable_movieCreation == 1): #if the flag for this is on, do it!

    print('\nAnalysis: Starting Movie Making\n');
    tic = time.time(); #time some stuff
    
    import matplotlib.animation as manimation
    from GRITI_movieMaker_subfun_dataGridder import GRITI_movieMaker_subfun_dataGridder
    from matplotlib.ticker import FormatStrFormatter
    from matplotlib.colors import ListedColormap
    from GRITI_movieMaker_subfun_dayniteCalc import GRITI_movieMaker_subfun_dayniteCalc
        
    #----------------------CALCULATE SUNRISE SUNSET TIMES----------------------
    #SECOND STEP: CALC LOCAL SUNRISE/SUNSET TIMES
    #calcs done in UT/GMT
    # based on calc steps in https://www.mathworks.com/examples/matlab/community/21093-estimating-sunrise-and-sunset
    #Preallocate
    dayNite_Grid_size = 1000; #number to subdivide grid into
    dayNite_sunrise = np.zeros( (dayNite_Grid_size,dayNite_Grid_size,dateRange_dayNum_full.shape[0]) ,dtype=np.float64); #hr UT, prep sunrise time for each day in the lat/long grid
    dayNite_sunset = np.zeros( (dayNite_Grid_size,dayNite_Grid_size,dateRange_dayNum_full.shape[0]) ,dtype=np.float64); #hr UT, prep sunset time for each day in the lat/long grid
    [dayNite_Grid_Long,dayNite_Grid_Lat] = np.meshgrid(np.linspace(np.min(plotLongRange),np.max(plotLongRange),dayNite_Grid_size),np.linspace(np.min(plotLatRange),np.max(plotLatRange),dayNite_Grid_size)); #degc, make two matrixes that have all the corresponding points in a lat/long grid
    dayNite_long_corrected = 4*(dayNite_Grid_Long); #calc corrected longitude, for sunrise/sunset time
    
    for i in range(0,dateRange_dayNum_full.shape[0]):
    
        dayNite_B = 360*(dateRange_dayNum_full[i,1] - 81)/365*np.pi/180; #rad, some sort of angle based on days and stuff
        dayNite_EoT_corrected = 9.87*np.sin(2*dayNite_B) - 7.53*np.cos(dayNite_B) - 1.5*np.sin(dayNite_B); #eq for Time Correction
        dayNite_solar_corrected = dayNite_long_corrected + np.tile(dayNite_EoT_corrected,(dayNite_Grid_size,dayNite_Grid_size) ); #min, solar time correction - for noon
    
        dayNite_solar_declination = np.arcsin(np.sin(23.45*np.pi/180)*np.sin(360*(dateRange_dayNum_full[i,1] - 81)/365*np.pi/180)); #rad, solar declination
    
        dayNite_temp = -np.tan(dayNite_Grid_Lat*np.pi/180)*np.tan(dayNite_solar_declination); #calc some mid step
    #     dayNite_temp( dayNite_temp >= 1 ) = dayNite_temp( dayNite_temp >= 1 ) - -2*(1 - dayNite_temp( dayNite_temp >= 1 )); #attempt a flip
    #     dayNite_temp( dayNite_temp <= -1) = dayNite_temp( dayNite_temp <= -1) + -2*(1 + dayNite_temp( dayNite_temp <= -1) ); #attempt a flip
        k = (dayNite_temp[:,0] <= -1) | (dayNite_temp[:,0] >= 1); #prep to replace these
    #     kF = find(k == 1,1,'first');
        
        dayNite_sunrise[:,:,i] = 12 - np.real(np.arccos(dayNite_temp)*180/np.pi)/15 - dayNite_solar_corrected/60; #hr UT, sunrise time
    #     for(j = 1:dayNite_Grid_size) %interpolation didn't work - too precipitous
    #         dayNite_sunrise(k,j,i) = interp1(1:1:(kF-1),dayNite_sunrise(~k,j,i),kF:1:dayNite_Grid_size,'spline','extrap'); %interp for each long set (calc oofs out at specific lat)
    #     end
        dayNite_sunset[:,:,i] = 12 + np.real(np.arccos(dayNite_temp)*180/np.pi)/15 - dayNite_solar_corrected/60; #hr UT, sunrise time
        #Accurate to like 10 minutes or whatever (breaks at high latitudes...)
        
        dayNite_sunrise[k,:,i] = np.nan; #remove data that we can't calc with this alg
        dayNite_sunset[k,:,i] = np.nan; #remove data that we can't calc with this alg
        
        dayNite_sunrise[:,:,i] = dayNite_sunrise[:,:,i] + dateRange_zeroHr_hrs[i]; #adjust to make it align to the hourly schedule
        dayNite_sunset[:,:,i] = dayNite_sunset[:,:,i] + dateRange_zeroHr_hrs[i]; #adjust to make it align to the hourly schedule
    #EMD FOR i
    
    #yo I straight up just transpose and reshape in different ways till it works how I want, matlab's is so much easier
    dayNite_sunrise =  np.reshape(dayNite_sunrise.transpose(2,1,0), (dayNite_Grid_size*dateRange_dayNum_full.shape[0], dayNite_Grid_size) ).T; #reshape into one big thing since each day's 6 AM sunrise or whatever is now per-day (+/-24 etc)
    dayNite_sunset = np.reshape(dayNite_sunset.transpose(2,1,0), (dayNite_Grid_size*dateRange_dayNum_full.shape[0], dayNite_Grid_size) ).T; #reshape into one big thing since each day's 6 AM sunrise or whatever is now per-day (+/-24 etc)
    dayNite_Grid_Lat = np.tile(dayNite_Grid_Lat, (1, dateRange_dayNum_full.shape[0]) ); #copy this to match above 1:1
    dayNite_Grid_Long = np.tile(dayNite_Grid_Long, (1, dateRange_dayNum_full.shape[0]) ); #copy this to match above 1:1
    
    #------------------------CREATE THE FIGURE WE WILL USE---------------------
    
    if( (gif_Type == 0) | (gif_Type == 1) ): #creates figure with 1 plot (geomap)
    
        fig, ax = plt.subplots(figsize = gif_figureSize/gif_figurePPI); #use instead of fig because it inits an axis too (I think I dunno)
        figManager = plt.get_current_fig_manager(); #req to maximize
        figManager.window.showMaximized(); #force maximized
        divider = make_axes_locatable(ax); #prep to add an axis
        cax = divider.append_axes('right', size='2.0%', pad=0.35); #make a color bar axis
        cax.yaxis.label.set_font_properties(FONT_axisLabelFM);
        
        #mill for square Mercator style
        #robin for oval shape
        geoMap = Basemap(projection=geoMap_projectionStyle, lat_0=np.mean(plotLatRange), lon_0=np.mean(plotLongRange), #projection type, and I think lat_0/lon_0 are the centers?
            resolution = 'i', area_thresh = 10000, ax=ax, #resolutions I know are l, i, h - i seems good. area_thresh being big prevents it drawing lil lakes, 0.1 makes everything
            llcrnrlon=np.float32(plotLongRange[0]), llcrnrlat=np.float32(plotLatRange[0]), #lower left corner lat/long - MUST BE FLOAT cause CODED BY THE BEST
            urcrnrlon=np.float32(plotLongRange[1]), urcrnrlat=np.float32(plotLatRange[1])); #upper right corner lat/long - MUST BE FLOAT cause CODED BY THE BEST
        
        geoMap.drawcoastlines(zorder=25); #always on top
        if( gif_ContinentFill == 1 ): #color in stuff if this is on
            #geoMap.drawcountries();
            #geoMap.drawmapboundary();
            geoMap.fillcontinents(color=gif_ContientColor,lake_color=gif_ContinentWaterColor,zorder=1);
            geoMap.drawmapboundary(fill_color=gif_ContinentWaterColor,zorder=0);
        #END IF
        
        #Remove the aspect ratio from the basemap so it fills the screen better
        ax.set_aspect('auto');
        
        #np.linspace(startlat,endlat,5) # 5 = number of "ticks"
        geoMap.drawmeridians( np.round(np.arange(np.floor(np.min(plotLongRange)),np.ceil(np.max(plotLongRange))+1,plotLongRange_autoTick),2), 
            labels=[True,False,False,True], labelstyle='+/-', dashes=[6,15000], color='black' ); #adds the labels but keeps the lines invisible
        geoMap.drawparallels(np.round(np.arange(np.floor(np.min(plotLatRange)),np.ceil(np.max(plotLatRange))+1,plotLatRange_autoTick),2), 
            labels=[True,False,True,False], labelstyle='+/-', dashes=[6,15000], color='black' ); #adds the labels but keeps the lines invisible
        #dashes[6,15000] seems to be enough to keep the repeating dash from happening on a world plot (I think it's how wide a dash is and the dash spacing). 900 was good for 22 degc longitude, for ref.
        #labels=[left,right,top,bottom] is the order. true/false to turn them on and off. not sure why there's a top/bottom for the parallels but w/e people do it
        
        string_title = 'Prep Title'; #create mecha title
        ax.set_title(string_title,fontproperties=FONT_titleFM); #set the title
        
        fig.subplots_adjust(left = 0.035, right = 0.95, top = 0.96, bottom = 0.03); #sets padding to small numbers for minimal white space
        #fig.tight_layout(); #function for a tight layout, doesn't seem to do much here
        plt.show(); #req to make plot show up
        
        #update gif_figureSize to now be the size of the movie plot (it'll be smaller if there are other plots on the screen)
        bbox = ax.get_window_extent().transformed(fig.dpi_scale_trans.inverted()); #get the size of the movie plot currently
        width, height = bbox.width, bbox.height; #break out the width/height in inches or something
        gif_figureSize = np.int64(np.round(np.array( (width*fig.dpi, height*fig.dpi) ))); #save that size, convert from inches to pixels using DPI
        
    elif( (gif_Type == 2) | (gif_Type == 3) ): #creates figure with 2 plots (TEC on top, RTI on bottom)
    
        fig, ax = plt.subplots(figsize = gif_figureSize/gif_figurePPI,nrows=2, ncols=1); #use instead of fig because it inits an axis too (I think I dunno)
        figManager = plt.get_current_fig_manager(); #req to maximize
        figManager.window.showMaximized(); #force maximized
        divider = make_axes_locatable(ax[0]); #prep to add an axis (top one is TEC so it gets it)
        cax = divider.append_axes('right', size='2.0%', pad=0.35); #make a color bar axis
        cax.yaxis.label.set_font_properties(FONT_axisLabelFM);
        divider2 = make_axes_locatable(ax[1]); #prep to add an axis (bottom is ISR so it gets one too)
        cax2 = divider2.append_axes('right', size='2.0%', pad=0.35); #make a color bar axis
        cax2.yaxis.label.set_font_properties(FONT_axisLabelFM);
        
        #mill for square Mercator style
        #robin for oval shape
        geoMap = Basemap(projection=geoMap_projectionStyle, lat_0=np.mean(plotLatRange), lon_0=np.mean(plotLongRange), #projection type, and I think lat_0/lon_0 are the centers?
            resolution = 'i', area_thresh = 10000, ax=ax[0], #resolutions I know are l, i, h - i seems good. area_thresh being big prevents it drawing lil lakes, 0.1 makes everything
            llcrnrlon=np.float32(plotLongRange[0]), llcrnrlat=np.float32(plotLatRange[0]), #lower left corner lat/long - MUST BE FLOAT cause CODED BY THE BEST
            urcrnrlon=np.float32(plotLongRange[1]), urcrnrlat=np.float32(plotLatRange[1])); #upper right corner lat/long - MUST BE FLOAT cause CODED BY THE BEST
        
        geoMap.drawcoastlines(zorder=25); #always on top
        if( gif_ContinentFill == 1 ): #color in stuff if this is on
            #geoMap.drawcountries();
            #geoMap.drawmapboundary();
            geoMap.fillcontinents(color=gif_ContientColor,lake_color=gif_ContinentWaterColor,zorder=1);
            geoMap.drawmapboundary(fill_color=gif_ContinentWaterColor,zorder=0);
        #END IF
        
        #Remove the aspect ratio from the basemap so it fills the screen better
        ax[0].set_aspect('auto');
        ax[1].set_aspect('auto');
        
        #np.linspace(startlat,endlat,5) # 5 = number of "ticks"
        geoMap.drawmeridians( np.round(np.arange(np.floor(np.min(plotLongRange)),np.ceil(np.max(plotLongRange))+1,plotLongRange_autoTick),2), 
            labels=[True,False,False,True], labelstyle='+/-', dashes=[6,15000], color='black' ); #adds the labels but keeps the lines invisible
        geoMap.drawparallels(np.round(np.arange(np.floor(np.min(plotLatRange)),np.ceil(np.max(plotLatRange))+1,plotLatRange_autoTick),2), 
            labels=[True,False,True,False], labelstyle='+/-', dashes=[6,15000], color='black' ); #adds the labels but keeps the lines invisible
        #dashes[6,15000] seems to be enough to keep the repeating dash from happening on a world plot (I think it's how wide a dash is and the dash spacing). 900 was good for 22 degc longitude, for ref.
        #labels=[left,right,top,bottom] is the order. true/false to turn them on and off. not sure why there's a top/bottom for the parallels but w/e people do it
        
        string_title = 'Prep Title'; #create mecha title
        ax[0].set_title(string_title,fontproperties=FONT_titleFM); #set the upper title
        ax[1].set_title(string_title,fontproperties=FONT_titleFM); #set the lower title
        
        fig.subplots_adjust(left = 0.040, right = 0.95, top = 0.96, bottom = 0.055, hspace = 0.15); #sets padding to small numbers for minimal white space
        #fig.tight_layout(); #function for a tight layout, doesn't seem to do much here
        plt.show(); #req to make plot show up   
        
        #update gif_figureSize to now be the size of the movie plot (it'll be smaller if there are other plots on the screen)
        bbox = ax[0].get_window_extent().transformed(fig.dpi_scale_trans.inverted()); #get the size of the movie plot currently
        width, height = bbox.width, bbox.height; #break out the width/height in inches or something
        gif_figureSize = np.int64(np.round(np.array( (width*fig.dpi, height*fig.dpi) ))); #save that size, convert from inches to pixels using DPI
        
    if( (gif_Type == 4) | (gif_Type == 5) ): #creates figure with 1 plot (geomap) and 2 colorbars (left is AMPERE)
    
        fig, ax = plt.subplots(figsize = gif_figureSize/gif_figurePPI); #use instead of fig because it inits an axis too (I think I dunno)
        figManager = plt.get_current_fig_manager(); #req to maximize
        figManager.window.showMaximized(); #force maximized
        divider = make_axes_locatable(ax); #prep to add an axis

        #mill for square Mercator style
        #robin for oval shape
        #npstere/spstere for polar
        if( geoMap_projectionStyle_polar == 1):
            cax = divider.append_axes('right', size='1.5%', pad=0.80); #make a color bar axis
            cax.yaxis.label.set_font_properties(FONT_axisLabelFM);
            cax2 = divider.append_axes('left', size='1.5%', pad=0.80); #make a color bar axis
            cax2.yaxis.label.set_font_properties(FONT_axisLabelFM);
            
            geoMap = Basemap(projection=geoMap_projectionStyle,boundinglat=np.min(plotLatRange),lon_0=np.mean(plotLongRange),
                resolution = 'i', area_thresh = 10000, ax=ax, round=True);
            if( gif_dayNiteLine == 1 ): # == 2 is OK as it's better than my rough calcs
                gif_dayNiteLine = 0; #override, they do weird things on polar
                gif_dayNiteText = 0; #override, they do weird things on polar
            #END IF
                #np.linspace(startlat,endlat,5) # 5 = number of "ticks"
            geoMap.drawmeridians( np.round(np.arange(np.floor(np.min(plotLongRange)),np.ceil(np.max(plotLongRange))+1,30),0), 
                labels=[0,0,0,0], labelstyle='+/-', color='black' ); #adds the labels but keeps the lines invisible
            geoMap.drawparallels(np.round(np.arange(90,np.min(plotLatRange),-15),0), 
                labels=[0,0,0,0], labelstyle='+/-', color='black' ); #adds the labels but keeps the lines invisible
            #dashes[6,15000] seems to be enough to keep the repeating dash from happening on a world plot (I think it's how wide a dash is and the dash spacing). 900 was good for 22 degc longitude, for ref.
            #labels=[left,right,top,bottom] is the order. true/false to turn them on and off. not sure why there's a top/bottom for the parallels but w/e people do it
            
            for j in np.arange(0,360,30): #longitude labels
                x = (1.05*0.5*np.sin(np.deg2rad(j)))+0.5; #geoMap coordinate 
                y = (1.05*0.5*np.cos(np.deg2rad(j+180)))+0.5;
                if( j > 180 ):
                    angle = j-360; #deg, flip to negative
                else:
                    angle = j; #deg, angle is OK
                #END IF
                if( angle == 180):
                    y = y - 0.01; #small nudge, cause this one is too close
                #END IF
                if( angle == -60):
                    x = x - 0.003; #small nudge, cause this one is too close
                #END IF
                ax.text(x,y,str(angle)+'\N{DEGREE SIGN}',transform=ax.transAxes,horizontalalignment='center',verticalalignment='center',fontproperties=FONT_axisTickFM)
            #END FOR j
            latPts = np.roll(np.arange(90,np.min(plotLatRange),-15),-1); #degc, latitude points to note (this extra work is to replace the 90 w/ the last latitude value)
            latPts[-1] = np.min(plotLatRange); #degc, last is the final latitude value
            latPts_mapped = geoMap(np.tile(180,(4,)),latPts); #convert to geoMap values
            for j in range(0,latPts.size): #latitude labels
                x = latPts_mapped[0][j]/latPts_mapped[1][-1] + 0.025; #geoMap coordinate 
                y = latPts_mapped[1][j]/latPts_mapped[1][-1] - 0.0085; #geoMap coordinate 
                ax.text(x,y,str(latPts[j])+'\N{DEGREE SIGN}',transform=ax.transAxes,horizontalalignment='center',verticalalignment='center',fontproperties=FONT_axisTickFM)
                #ax.text(x,y,str(latPts[j])+'\N{DEGREE SIGN}',horizontalalignment='center',verticalalignment='center',fontproperties=FONT_axisTickFM)
            #END FOR j

            #Remove the aspect ratio from the basemap so it fills the screen better
            ax.set_aspect('equal');
            geoCircle = geoMap.drawmapboundary(linewidth=2, color='k'); #polar circle is clipped, so this draws it then makes sure it isn't
            geoCircle.set_clip_on(False); #prevent weird things where the circle is clipped off
            
            string_title = 'Prep Title'; #create mecha title
            ax.set_title(string_title,fontproperties=FONT_titleFM,y=1.035); #set the title
            
            fig.subplots_adjust(left = 0.04, right = 0.95, top = 0.92, bottom = 0.045); #sets padding to small numbers for minimal white space
        elif(geoMap_projectionStyle_polar == 2):
            cax = divider.append_axes('right', size='1.5%', pad=0.80); #make a color bar axis
            cax.yaxis.label.set_font_properties(FONT_axisLabelFM);
            cax2 = divider.append_axes('left', size='1.5%', pad=0.80); #make a color bar axis
            cax2.yaxis.label.set_font_properties(FONT_axisLabelFM);
            
            geoMap = Basemap(projection=geoMap_projectionStyle,boundinglat=np.max(plotLatRange),lon_0=np.mean(plotLongRange),
                 resolution = 'i', area_thresh = 10000, ax=ax, round=True);
            if( gif_dayNiteLine == 1 ): # == 2 is OK as it's better than my rough calcs
                gif_dayNiteLine = 0; #override, they do weird things on polar
                gif_dayNiteText = 0; #override, they do weird things on polar
            #END IF
            #np.linspace(startlat,endlat,5) # 5 = number of "ticks"
            geoMap.drawmeridians( np.round(np.arange(np.floor(np.min(plotLongRange)),np.ceil(np.max(plotLongRange))+1,30),2), 
                labels=[True,True,True,True], labelstyle='+/-', color='black' ); #adds the labels but keeps the lines invisible
            geoMap.drawparallels(np.round(np.arange(-90,np.max(plotLatRange),15),0), 
                labels=[True,True,True,True], labelstyle='+/-', color='black' ); #adds the labels but keeps the lines invisible
            #dashes[6,15000] seems to be enough to keep the repeating dash from happening on a world plot (I think it's how wide a dash is and the dash spacing). 900 was good for 22 degc longitude, for ref.
            #labels=[left,right,top,bottom] is the order. true/false to turn them on and off. not sure why there's a top/bottom for the parallels but w/e people do it
        
            for j in np.arange(0,360,30): #longitude labels
                x = (1.05*0.5*np.sin(np.deg2rad(j)))+0.5; #geoMap coordinate 
                y = (1.05*0.5*np.cos(np.deg2rad(j+180)))+0.5;
                if( j > 180 ):
                    angle = j-360; #deg, flip to negative
                else:
                    angle = j; #deg, angle is OK
                #END IF
                if( angle == 180):
                    y = y - 0.01; #small nudge, cause this one is too close
                #END IF
                if( angle == -60):
                    x = x - 0.003; #small nudge, cause this one is too close
                #END IF
                ax.text(x,y,str(angle)+'\N{DEGREE SIGN}',transform=ax.transAxes,horizontalalignment='center',verticalalignment='center',fontproperties=FONT_axisTickFM)
            #END FOR j
            latPts = np.roll(np.arange(-90,np.max(plotLatRange),15),-1); #degc, latitude points to note (this extra work is to replace the 90 w/ the last latitude value)
            latPts[-1] = np.max(plotLatRange); #degc, last is the final latitude value
            latPts_mapped = geoMap(np.tile(180,(4,)),latPts); #convert to geoMap values
            for j in range(0,latPts.size): #latitude labels
                x = latPts_mapped[0][j]/latPts_mapped[1][-1] + 0.025; #geoMap coordinate 
                y = latPts_mapped[1][j]/latPts_mapped[1][-1] - 0.0085; #geoMap coordinate 
                ax.text(x,y,str(latPts[j])+'\N{DEGREE SIGN}',transform=ax.transAxes,horizontalalignment='center',verticalalignment='center',fontproperties=FONT_axisTickFM)
                #ax.text(x,y,str(latPts[j])+'\N{DEGREE SIGN}',horizontalalignment='center',verticalalignment='center',fontproperties=FONT_axisTickFM)
            #END FOR j
            
            #Remove the aspect ratio from the basemap so it fills the screen better
            ax.set_aspect('equal');
            geoCircle = geoMap.drawmapboundary(linewidth=2, color='k'); #polar circle is clipped, so this draws it then makes sure it isn't
            geoMap.set_clip_on(False); #prevent weird things where the circle is clipped off
            
            string_title = 'Prep Title'; #create mecha title
            ax.set_title(string_title,fontproperties=FONT_titleFM); #set the title
            
            fig.subplots_adjust(left = 0.04, right = 0.95, top = 0.96, bottom = 0.045); #sets padding to small numbers for minimal white space
        else:
            cax = divider.append_axes('right', size='1.5%', pad=0.35); #make a color bar axis
            cax.yaxis.label.set_font_properties(FONT_axisLabelFM);
            cax2 = divider.append_axes('left', size='1.5%', pad=0.65); #make a color bar axis
            cax2.yaxis.label.set_font_properties(FONT_axisLabelFM);
            
            geoMap = Basemap(projection=geoMap_projectionStyle, lat_0=np.mean(plotLatRange), lon_0=np.mean(plotLongRange), #projection type, and I think lat_0/lon_0 are the centers?
                resolution = 'i', area_thresh = 10000, ax=ax, #resolutions I know are l, i, h - i seems good. area_thresh being big prevents it drawing lil lakes, 0.1 makes everything
                llcrnrlon=np.float32(plotLongRange[0]), llcrnrlat=np.float32(plotLatRange[0]), #lower left corner lat/long - MUST BE FLOAT cause CODED BY THE BEST
                urcrnrlon=np.float32(plotLongRange[1]), urcrnrlat=np.float32(plotLatRange[1])); #upper right corner lat/long - MUST BE FLOAT cause CODED BY THE BEST
        
            #np.linspace(startlat,endlat,5) # 5 = number of "ticks"
            geoMap.drawmeridians( np.round(np.arange(np.floor(np.min(plotLongRange)),np.ceil(np.max(plotLongRange))+1,plotLongRange_autoTick),2), 
                labels=[True,False,False,True], labelstyle='+/-', dashes=[6,15000], color='black' ); #adds the labels but keeps the lines invisible
            geoMap.drawparallels(np.round(np.arange(np.floor(np.min(plotLatRange)),np.ceil(np.max(plotLatRange))+1,plotLatRange_autoTick),2), 
                labels=[True,False,True,False], labelstyle='+/-', dashes=[6,15000], color='black' ); #adds the labels but keeps the lines invisible
            #dashes[6,15000] seems to be enough to keep the repeating dash from happening on a world plot (I think it's how wide a dash is and the dash spacing). 900 was good for 22 degc longitude, for ref.
            #labels=[left,right,top,bottom] is the order. true/false to turn them on and off. not sure why there's a top/bottom for the parallels but w/e people do it
            
            #Remove the aspect ratio from the basemap so it fills the screen better
            ax.set_aspect('auto');
            
            string_title = 'Prep Title'; #create mecha title
            ax.set_title(string_title,fontproperties=FONT_titleFM); #set the title
            
            fig.subplots_adjust(left = 0.04, right = 0.95, top = 0.96, bottom = 0.045); #sets padding to small numbers for minimal white space
        #END IF 
        
        geoMap.drawcoastlines(zorder=25); #always on top
        if( gif_ContinentFill == 1 ): #color in stuff if this is on
            #geoMap.drawcountries();
            #geoMap.drawmapboundary();
            geoMap.fillcontinents(color=gif_ContientColor,lake_color=gif_ContinentWaterColor,zorder=1);
            geoMap.drawmapboundary(fill_color=gif_ContinentWaterColor,zorder=0);
        #END IF
        
        #fig.tight_layout(); #function for a tight layout, doesn't seem to do much here
        plt.show(); #req to make plot show up
        
        #update gif_figureSize to now be the size of the movie plot (it'll be smaller if there are other plots on the screen)
        bbox = ax.get_window_extent().transformed(fig.dpi_scale_trans.inverted()); #get the size of the movie plot currently
        width, height = bbox.width, bbox.height; #break out the width/height in inches or something
        gif_figureSize = np.int64(np.round(np.array( (width*fig.dpi, height*fig.dpi) ))); #save that size, convert from inches to pixels using DPI
        
    if( (gif_Type == 6) ): #creates figure with 1 plot (geomap) and 2 colorbars (left is AMPERE) and smaller plot next to geomap as well for a keogram or something
        fig = plt.figure(figsize = gif_figureSize/gif_figurePPI); #use fig because we gotta init an axis later
        figManager = plt.get_current_fig_manager(); #req to maximize
        figManager.window.showMaximized(); #force maximized
        ax = [plt.subplot2grid((1, 3), (0, 0), colspan=2,fig=fig) , plt.subplot2grid((7, 3), (2, 2),rowspan=3, colspan=1,fig=fig) ]; #init an axis
        #the subplot2grid is weird, 2nd one makes a 7x3 grid and puts a subplot that spans 3 of the 7 rows 2 rows down and in the 3rd column
        #1st one does a 1x3 grid and puts a subplot that spans 2 columns in the 1st column - they don't overlap, but we get weird sizes

        divider = make_axes_locatable(ax[0]); #prep to add an axis
        dividerKeo = make_axes_locatable(ax[1]); #prep to add an axis

        #mill for square Mercator style
        #robin for oval shape
        #npstere/spstere for polar
        if( geoMap_projectionStyle_polar == 1):
            cax = divider.append_axes('right', size='1.5%', pad=0.80); #make a color bar axis
            cax.yaxis.label.set_font_properties(FONT_axisLabelFM);
            cax2 = divider.append_axes('left', size='1.5%', pad=0.80); #make a color bar axis
            cax2.yaxis.label.set_font_properties(FONT_axisLabelFM);
            
            geoMap = Basemap(projection=geoMap_projectionStyle,boundinglat=np.min(plotLatRange),lon_0=np.mean(plotLongRange),
                resolution = 'i', area_thresh = 10000, ax=ax[0], round=True);
            if( gif_dayNiteLine == 1 ): # == 2 is OK as it's better than my rough calcs
                gif_dayNiteLine = 0; #override, they do weird things on polar
                gif_dayNiteText = 0; #override, they do weird things on polar
            #END IF
                #np.linspace(startlat,endlat,5) # 5 = number of "ticks"
            geoMap.drawmeridians( np.round(np.arange(np.floor(np.min(plotLongRange)),np.ceil(np.max(plotLongRange))+1,30),0), 
                labels=[0,0,0,0], labelstyle='+/-', color='black' ); #adds the labels but keeps the lines invisible
            geoMap.drawparallels(np.round(np.arange(90,np.min(plotLatRange),-15),0), 
                labels=[0,0,0,0], labelstyle='+/-', color='black' ); #adds the labels but keeps the lines invisible
            #dashes[6,15000] seems to be enough to keep the repeating dash from happening on a world plot (I think it's how wide a dash is and the dash spacing). 900 was good for 22 degc longitude, for ref.
            #labels=[left,right,top,bottom] is the order. true/false to turn them on and off. not sure why there's a top/bottom for the parallels but w/e people do it
            
            for j in np.arange(0,360,30): #longitude labels
                x = (1.05*0.5*np.sin(np.deg2rad(j)))+0.5; #geoMap coordinate 
                y = (1.05*0.5*np.cos(np.deg2rad(j+180)))+0.5;
                if( j > 180 ):
                    angle = j-360; #deg, flip to negative
                else:
                    angle = j; #deg, angle is OK
                #END IF
                if( angle == 180):
                    y = y - 0.01; #small nudge, cause this one is too close
                #END IF
                if( angle == -60):
                    x = x - 0.003; #small nudge, cause this one is too close
                #END IF
                ax[0].text(x,y,str(angle)+'\N{DEGREE SIGN}',transform=ax[0].transAxes,horizontalalignment='center',verticalalignment='center',fontproperties=FONT_axisTickFM)
            #END FOR j
            latPts = np.roll(np.arange(90,np.min(plotLatRange),-15),-1); #degc, latitude points to note (this extra work is to replace the 90 w/ the last latitude value)
            latPts[-1] = np.min(plotLatRange); #degc, last is the final latitude value
            latPts_mapped = geoMap(np.tile(180,(latPts.size,)),latPts); #convert to geoMap values
            for j in range(0,latPts.size): #latitude labels
                x = latPts_mapped[0][j]/latPts_mapped[1][-1] + 0.025; #geoMap coordinate 
                y = latPts_mapped[1][j]/latPts_mapped[1][-1] - 0.0085; #geoMap coordinate 
                ax[0].text(x,y,str(latPts[j])+'\N{DEGREE SIGN}',transform=ax[0].transAxes,horizontalalignment='center',verticalalignment='center',fontproperties=FONT_axisTickFM)
                #ax.text(x,y,str(latPts[j])+'\N{DEGREE SIGN}',horizontalalignment='center',verticalalignment='center',fontproperties=FONT_axisTickFM)
            #END FOR j

            #Remove the aspect ratio from the basemap so it fills the screen better
            ax[0].set_aspect('equal');
            geoCircle = geoMap.drawmapboundary(linewidth=2, color='k'); #polar circle is clipped, so this draws it then makes sure it isn't
            geoCircle.set_clip_on(False); #prevent weird things where the circle is clipped off
            
            string_title = 'Prep Title'; #create mecha title
            ax[0].set_title(string_title,fontproperties=FONT_titleFM,y=1.035); #set the title
            
            fig.subplots_adjust(left = 0.02, right = 0.94, top = 0.92, bottom = 0.045); #sets padding to small numbers for minimal white space
        elif(geoMap_projectionStyle_polar == 2):
            cax = divider.append_axes('right', size='1.5%', pad=0.80); #make a color bar axis
            cax.yaxis.label.set_font_properties(FONT_axisLabelFM);
            cax2 = divider.append_axes('left', size='1.5%', pad=0.80); #make a color bar axis
            cax2.yaxis.label.set_font_properties(FONT_axisLabelFM);
            
            geoMap = Basemap(projection=geoMap_projectionStyle,boundinglat=np.max(plotLatRange),lon_0=np.mean(plotLongRange),
                 resolution = 'i', area_thresh = 10000, ax=ax[0], round=True);
            if( gif_dayNiteLine == 1 ): # == 2 is OK as it's better than my rough calcs
                gif_dayNiteLine = 0; #override, they do weird things on polar
                gif_dayNiteText = 0; #override, they do weird things on polar
            #END IF
            #np.linspace(startlat,endlat,5) # 5 = number of "ticks"
            geoMap.drawmeridians( np.round(np.arange(np.floor(np.min(plotLongRange)),np.ceil(np.max(plotLongRange))+1,30),2), 
                labels=[True,True,True,True], labelstyle='+/-', color='black' ); #adds the labels but keeps the lines invisible
            geoMap.drawparallels(np.round(np.arange(-90,np.max(plotLatRange),15),0), 
                labels=[True,True,True,True], labelstyle='+/-', color='black' ); #adds the labels but keeps the lines invisible
            #dashes[6,15000] seems to be enough to keep the repeating dash from happening on a world plot (I think it's how wide a dash is and the dash spacing). 900 was good for 22 degc longitude, for ref.
            #labels=[left,right,top,bottom] is the order. true/false to turn them on and off. not sure why there's a top/bottom for the parallels but w/e people do it
        
            for j in np.arange(0,360,30): #longitude labels
                x = (1.05*0.5*np.sin(np.deg2rad(j)))+0.5; #geoMap coordinate 
                y = (1.05*0.5*np.cos(np.deg2rad(j+180)))+0.5;
                if( j > 180 ):
                    angle = j-360; #deg, flip to negative
                else:
                    angle = j; #deg, angle is OK
                #END IF
                if( angle == 180):
                    y = y - 0.01; #small nudge, cause this one is too close
                #END IF
                if( angle == -60):
                    x = x - 0.003; #small nudge, cause this one is too close
                #END IF
                ax[0].text(x,y,str(angle)+'\N{DEGREE SIGN}',transform=ax[0].transAxes,horizontalalignment='center',verticalalignment='center',fontproperties=FONT_axisTickFM)
            #END FOR j
            latPts = np.roll(np.arange(-90,np.max(plotLatRange),15),-1); #degc, latitude points to note (this extra work is to replace the 90 w/ the last latitude value)
            latPts[-1] = np.max(plotLatRange); #degc, last is the final latitude value
            latPts_mapped = geoMap(np.tile(180,(latPts.size,)),latPts); #convert to geoMap values
            for j in range(0,latPts.size): #latitude labels
                x = latPts_mapped[0][j]/latPts_mapped[1][-1] + 0.025; #geoMap coordinate 
                y = latPts_mapped[1][j]/latPts_mapped[1][-1] - 0.0085; #geoMap coordinate 
                ax[0].text(x,y,str(latPts[j])+'\N{DEGREE SIGN}',transform=ax[0].transAxes,horizontalalignment='center',verticalalignment='center',fontproperties=FONT_axisTickFM)
                #ax.text(x,y,str(latPts[j])+'\N{DEGREE SIGN}',horizontalalignment='center',verticalalignment='center',fontproperties=FONT_axisTickFM)
            #END FOR j
            
            #Remove the aspect ratio from the basemap so it fills the screen better
            ax[0].set_aspect('equal');
            geoCircle = geoMap.drawmapboundary(linewidth=2, color='k'); #polar circle is clipped, so this draws it then makes sure it isn't
            geoMap.set_clip_on(False); #prevent weird things where the circle is clipped off
            
            string_title = 'Prep Title'; #create mecha title
            ax[0].set_title(string_title,fontproperties=FONT_titleFM); #set the title
            
            fig.subplots_adjust(left = 0.02, right = 0.94, top = 0.96, bottom = 0.045); #sets padding to small numbers for minimal white space
        else:
            cax = divider.append_axes('right', size='1.5%', pad=0.35); #make a color bar axis
            cax.yaxis.label.set_font_properties(FONT_axisLabelFM);
            cax2 = divider.append_axes('left', size='1.5%', pad=0.65); #make a color bar axis
            cax2.yaxis.label.set_font_properties(FONT_axisLabelFM);
            
            geoMap = Basemap(projection=geoMap_projectionStyle, lat_0=np.mean(plotLatRange), lon_0=np.mean(plotLongRange), #projection type, and I think lat_0/lon_0 are the centers?
                resolution = 'i', area_thresh = 10000, ax=ax[0], #resolutions I know are l, i, h - i seems good. area_thresh being big prevents it drawing lil lakes, 0.1 makes everything
                llcrnrlon=np.float32(plotLongRange[0]), llcrnrlat=np.float32(plotLatRange[0]), #lower left corner lat/long - MUST BE FLOAT cause CODED BY THE BEST
                urcrnrlon=np.float32(plotLongRange[1]), urcrnrlat=np.float32(plotLatRange[1])); #upper right corner lat/long - MUST BE FLOAT cause CODED BY THE BEST
        
            #np.linspace(startlat,endlat,5) # 5 = number of "ticks"
            geoMap.drawmeridians( np.round(np.arange(np.floor(np.min(plotLongRange)),np.ceil(np.max(plotLongRange))+1,np.int64(plotLongRange_autoTick*2)),2), 
                labels=[True,False,False,True], labelstyle='+/-', dashes=[6,15000], color='black' ); #adds the labels but keeps the lines invisible
            geoMap.drawparallels(np.round(np.arange(np.floor(np.min(plotLatRange)),np.ceil(np.max(plotLatRange))+1,plotLatRange_autoTick),2), 
                labels=[True,False,True,False], labelstyle='+/-', dashes=[6,15000], color='black' ); #adds the labels but keeps the lines invisible
            #dashes[6,15000] seems to be enough to keep the repeating dash from happening on a world plot (I think it's how wide a dash is and the dash spacing). 900 was good for 22 degc longitude, for ref.
            #labels=[left,right,top,bottom] is the order. true/false to turn them on and off. not sure why there's a top/bottom for the parallels but w/e people do it
            
            #Remove the aspect ratio from the basemap so it fills the screen better
            ax[0].set_aspect('auto');
            
            string_title = 'Prep Title'; #create mecha title
            ax[0].set_title(string_title,fontproperties=FONT_titleFM); #set the title
            
            fig.subplots_adjust(left = 0.04, right = 0.95, top = 0.96, bottom = 0.045); #sets padding to small numbers for minimal white space
        #END IF
        
        #now draw some coastlines
        geoMap.drawcoastlines(zorder=25); #always on top
        if( gif_ContinentFill == 1 ): #color in stuff if this is on
            #geoMap.drawcountries();
            #geoMap.drawmapboundary();
            geoMap.fillcontinents(color=gif_ContientColor,lake_color=gif_ContinentWaterColor,zorder=1);
            geoMap.drawmapboundary(fill_color=gif_ContinentWaterColor,zorder=0);
        #END IF
        
        #now for the other plot (dividerKeo, ax[1])
        #Remove the aspect ratio from the basemap so it fills the screen better
        ax[1].set_aspect('auto');
        
        string_title = 'Prep Title'; #create mecha title
        ax[1].set_title(string_title,fontproperties=FONT_titleFM); #set the title
        caxKeo = dividerKeo.append_axes('right', size='3%', pad=0.30); #make a color bar axis
        
        caxKeo.yaxis.label.set_font_properties(FONT_axisLabelFM);
        
        #fig.tight_layout(); #function for a tight layout, doesn't seem to do much here
        plt.show(); #req to make plot show up
        
        #update gif_figureSize to now be the size of the movie plot (it'll be smaller if there are other plots on the screen)
        bbox = ax[0].get_window_extent().transformed(fig.dpi_scale_trans.inverted()); #get the size of the movie plot currently
        width, height = bbox.width, bbox.height; #break out the width/height in inches or something
        gif_figureSize = np.int64(np.round(np.array( (width*fig.dpi, height*fig.dpi) ))); #save that size, convert from inches to pixels using DPI
        
    if( (gif_Type == 7) ): #creates figure with 1 plot (geomap) and 2 colorbars (left is AMPERE) and smaller plot next to geomap as well for a keogram or something
        fig = plt.figure(figsize = gif_figureSize/gif_figurePPI); #use fig because we gotta init an axis later
        figManager = plt.get_current_fig_manager(); #req to maximize
        figManager.window.showMaximized(); #force maximized
        ax = [plt.subplot2grid((1, 3), (0, 0), colspan=2,fig=fig) , plt.subplot2grid((9, 3), (0, 2),rowspan=4, colspan=1,fig=fig), plt.subplot2grid((9, 3), (5, 2),rowspan=4, colspan=1,fig=fig) ]; #init an axis
        #the subplot2grid is weird, 2nd one makes a 7x3 grid and puts a subplot that spans 3 of the 7 rows 0 rows down and in the 3rd column, 3rd does similar but 5 rows down
        #1st one does a 1x3 grid and puts a subplot that spans 2 columns in the 1st column - they don't overlap, but we get weird sizes

        divider = make_axes_locatable(ax[0]); #prep to add an axis
        dividerKeo = make_axes_locatable(ax[1]); #prep to add an axis
        dividerKeo2 = make_axes_locatable(ax[2]); #prep to add an axis

        #mill for square Mercator style
        #robin for oval shape
        #npstere/spstere for polar
        if( geoMap_projectionStyle_polar == 1):
            cax = divider.append_axes('right', size='1.5%', pad=0.60); #make a color bar axis
            cax.yaxis.label.set_font_properties(FONT_axisLabelFM);
            cax2 = divider.append_axes('left', size='1.5%', pad=0.60); #make a color bar axis
            cax2.yaxis.label.set_font_properties(FONT_axisLabelFM);
            
            geoMap = Basemap(projection=geoMap_projectionStyle,boundinglat=np.min(plotLatRange),lon_0=np.mean(plotLongRange),
                resolution = 'i', area_thresh = 10000, ax=ax[0], round=True);
            if( gif_dayNiteLine == 1 ): # == 2 is OK as it's better than my rough calcs
                gif_dayNiteLine = 0; #override, they do weird things on polar
                gif_dayNiteText = 0; #override, they do weird things on polar
            #END IF
                #np.linspace(startlat,endlat,5) # 5 = number of "ticks"
            geoMap.drawmeridians( np.round(np.arange(np.floor(np.min(plotLongRange)),np.ceil(np.max(plotLongRange))+1,30),0), 
                labels=[0,0,0,0], labelstyle='+/-', color='black' ); #adds the labels but keeps the lines invisible
            geoMap.drawparallels(np.round(np.arange(90,np.min(plotLatRange),-15),0), 
                labels=[0,0,0,0], labelstyle='+/-', color='black' ); #adds the labels but keeps the lines invisible
            #dashes[6,15000] seems to be enough to keep the repeating dash from happening on a world plot (I think it's how wide a dash is and the dash spacing). 900 was good for 22 degc longitude, for ref.
            #labels=[left,right,top,bottom] is the order. true/false to turn them on and off. not sure why there's a top/bottom for the parallels but w/e people do it
            
            for j in np.arange(0,360,30): #longitude labels
                x = (1.05*0.5*np.sin(np.deg2rad(j)))+0.5; #geoMap coordinate 
                y = (1.05*0.5*np.cos(np.deg2rad(j+180)))+0.5;
                if( j > 180 ):
                    angle = j-360; #deg, flip to negative
                else:
                    angle = j; #deg, angle is OK
                #END IF
                if( angle == 180):
                    y = y - 0.01; #small nudge, cause this one is too close
                #END IF
                if( angle == -60):
                    x = x - 0.003; #small nudge, cause this one is too close
                #END IF
                ax[0].text(x,y,str(angle)+'\N{DEGREE SIGN}',transform=ax[0].transAxes,horizontalalignment='center',verticalalignment='center',fontproperties=FONT_axisTickFM)
            #END FOR j
            latPts = np.roll(np.arange(90,np.min(plotLatRange),-15),-1); #degc, latitude points to note (this extra work is to replace the 90 w/ the last latitude value)
            latPts[-1] = np.min(plotLatRange); #degc, last is the final latitude value
            latPts_mapped = geoMap(np.tile(180,(latPts.size,)),latPts); #convert to geoMap values
            for j in range(0,latPts.size): #latitude labels
                x = latPts_mapped[0][j]/latPts_mapped[1][-1] + 0.025; #geoMap coordinate 
                y = latPts_mapped[1][j]/latPts_mapped[1][-1] - 0.0085; #geoMap coordinate 
                ax[0].text(x,y,str(latPts[j])+'\N{DEGREE SIGN}',transform=ax[0].transAxes,horizontalalignment='center',verticalalignment='center',fontproperties=FONT_axisTickFM)
                #ax.text(x,y,str(latPts[j])+'\N{DEGREE SIGN}',horizontalalignment='center',verticalalignment='center',fontproperties=FONT_axisTickFM)
            #END FOR j

            #Remove the aspect ratio from the basemap so it fills the screen better
            ax[0].set_aspect('equal');
            geoCircle = geoMap.drawmapboundary(linewidth=2, color='k'); #polar circle is clipped, so this draws it then makes sure it isn't
            geoCircle.set_clip_on(False); #prevent weird things where the circle is clipped off
            
            string_title = 'Prep Title'; #create mecha title
            ax[0].set_title(string_title,fontproperties=FONT_titleFM,y=1.035); #set the title
            
            fig.subplots_adjust(left = 0.02, right = 0.94, top = 0.935, bottom = 0.072); #sets padding to small numbers for minimal white space
        elif(geoMap_projectionStyle_polar == 2):
            cax = divider.append_axes('right', size='1.5%', pad=0.60); #make a color bar axis
            cax.yaxis.label.set_font_properties(FONT_axisLabelFM);
            cax2 = divider.append_axes('left', size='1.5%', pad=0.60); #make a color bar axis
            cax2.yaxis.label.set_font_properties(FONT_axisLabelFM);
            
            geoMap = Basemap(projection=geoMap_projectionStyle,boundinglat=np.max(plotLatRange),lon_0=np.mean(plotLongRange),
                 resolution = 'i', area_thresh = 10000, ax=ax[0], round=True);
            if( gif_dayNiteLine == 1 ): # == 2 is OK as it's better than my rough calcs
                gif_dayNiteLine = 0; #override, they do weird things on polar
                gif_dayNiteText = 0; #override, they do weird things on polar
            #END IF
            #np.linspace(startlat,endlat,5) # 5 = number of "ticks"
            geoMap.drawmeridians( np.round(np.arange(np.floor(np.min(plotLongRange)),np.ceil(np.max(plotLongRange))+1,30),2), 
                labels=[True,True,True,True], labelstyle='+/-', color='black' ); #adds the labels but keeps the lines invisible
            geoMap.drawparallels(np.round(np.arange(-90,np.max(plotLatRange),15),0), 
                labels=[True,True,True,True], labelstyle='+/-', color='black' ); #adds the labels but keeps the lines invisible
            #dashes[6,15000] seems to be enough to keep the repeating dash from happening on a world plot (I think it's how wide a dash is and the dash spacing). 900 was good for 22 degc longitude, for ref.
            #labels=[left,right,top,bottom] is the order. true/false to turn them on and off. not sure why there's a top/bottom for the parallels but w/e people do it
        
            for j in np.arange(0,360,30): #longitude labels
                x = (1.05*0.5*np.sin(np.deg2rad(j)))+0.5; #geoMap coordinate 
                y = (1.05*0.5*np.cos(np.deg2rad(j+180)))+0.5;
                if( j > 180 ):
                    angle = j-360; #deg, flip to negative
                else:
                    angle = j; #deg, angle is OK
                #END IF
                if( angle == 180):
                    y = y - 0.01; #small nudge, cause this one is too close
                #END IF
                if( angle == -60):
                    x = x - 0.003; #small nudge, cause this one is too close
                #END IF
                ax[0].text(x,y,str(angle)+'\N{DEGREE SIGN}',transform=ax[0].transAxes,horizontalalignment='center',verticalalignment='center',fontproperties=FONT_axisTickFM)
            #END FOR j
            latPts = np.roll(np.arange(-90,np.max(plotLatRange),15),-1); #degc, latitude points to note (this extra work is to replace the 90 w/ the last latitude value)
            latPts[-1] = np.max(plotLatRange); #degc, last is the final latitude value
            latPts_mapped = geoMap(np.tile(180,(latPts.size,)),latPts); #convert to geoMap values
            for j in range(0,latPts.size): #latitude labels
                x = latPts_mapped[0][j]/latPts_mapped[1][-1] + 0.025; #geoMap coordinate 
                y = latPts_mapped[1][j]/latPts_mapped[1][-1] - 0.0085; #geoMap coordinate 
                ax[0].text(x,y,str(latPts[j])+'\N{DEGREE SIGN}',transform=ax[0].transAxes,horizontalalignment='center',verticalalignment='center',fontproperties=FONT_axisTickFM)
                #ax.text(x,y,str(latPts[j])+'\N{DEGREE SIGN}',horizontalalignment='center',verticalalignment='center',fontproperties=FONT_axisTickFM)
            #END FOR j
            
            #Remove the aspect ratio from the basemap so it fills the screen better
            ax[0].set_aspect('equal');
            geoCircle = geoMap.drawmapboundary(linewidth=2, color='k'); #polar circle is clipped, so this draws it then makes sure it isn't
            geoMap.set_clip_on(False); #prevent weird things where the circle is clipped off
            
            string_title = 'Prep Title'; #create mecha title
            ax[0].set_title(string_title,fontproperties=FONT_titleFM,y=1.035); #set the title
            
            fig.subplots_adjust(left = 0.02, right = 0.94, top = 0.96, bottom = 0.063); #sets padding to small numbers for minimal white space
        else:
            cax = divider.append_axes('right', size='1.5%', pad=0.15); #make a color bar axis
            cax.yaxis.label.set_font_properties(FONT_axisLabelFM);
            cax2 = divider.append_axes('left', size='1.5%', pad=0.90); #make a color bar axis
            cax2.yaxis.label.set_font_properties(FONT_axisLabelFM);
            
            geoMap = Basemap(projection=geoMap_projectionStyle, lat_0=np.mean(plotLatRange), lon_0=np.mean(plotLongRange), #projection type, and I think lat_0/lon_0 are the centers?
                resolution = 'i', area_thresh = 10000, ax=ax[0], #resolutions I know are l, i, h - i seems good. area_thresh being big prevents it drawing lil lakes, 0.1 makes everything
                llcrnrlon=np.float32(plotLongRange[0]), llcrnrlat=np.float32(plotLatRange[0]), #lower left corner lat/long - MUST BE FLOAT cause CODED BY THE BEST
                urcrnrlon=np.float32(plotLongRange[1]), urcrnrlat=np.float32(plotLatRange[1])); #upper right corner lat/long - MUST BE FLOAT cause CODED BY THE BEST
        
            #np.linspace(startlat,endlat,5) # 5 = number of "ticks"
            geoMap.drawmeridians( np.round(np.arange(np.floor(np.min(plotLongRange)),np.ceil(np.max(plotLongRange))+1,np.int64(plotLongRange_autoTick*2)),2), 
                labels=[True,False,False,True], labelstyle='+/-', dashes=[6,15000], color='black' ); #adds the labels but keeps the lines invisible
            geoMap.drawparallels(np.round(np.arange(np.floor(np.min(plotLatRange)),np.ceil(np.max(plotLatRange))+1,plotLatRange_autoTick),2), 
                labels=[True,False,True,False], labelstyle='+/-', dashes=[6,15000], color='black' ); #adds the labels but keeps the lines invisible
            #dashes[6,15000] seems to be enough to keep the repeating dash from happening on a world plot (I think it's how wide a dash is and the dash spacing). 900 was good for 22 degc longitude, for ref.
            #labels=[left,right,top,bottom] is the order. true/false to turn them on and off. not sure why there's a top/bottom for the parallels but w/e people do it
            
            #Remove the aspect ratio from the basemap so it fills the screen better
            ax[0].set_aspect('auto');
            
            string_title = 'Prep Title'; #create mecha title
            ax[0].set_title(string_title,fontproperties=FONT_titleFM); #set the title
            
            fig.subplots_adjust(wspace=0.30); #pads the wspace to keep the labels from overlapping
            fig.subplots_adjust(left = 0.045, right = 0.947, top = 0.96, bottom = 0.065); #sets padding to small numbers for minimal white space
        #END IF
        
        #now draw some coastlines
        geoMap.drawcoastlines(zorder=25); #always on top
        if( gif_ContinentFill == 1 ): #color in stuff if this is on
            #geoMap.drawcountries();
            #geoMap.drawmapboundary();
            geoMap.fillcontinents(color=gif_ContientColor,lake_color=gif_ContinentWaterColor,zorder=1);
            geoMap.drawmapboundary(fill_color=gif_ContinentWaterColor,zorder=0);
        #END IF
        
        #now for the other plot (dividerKeo, ax[1])
        #Remove the aspect ratio from the basemap so it fills the screen better
        ax[1].set_aspect('auto');
        
        string_title = 'Prep Title'; #create mecha title
        ax[1].set_title(string_title,fontproperties=FONT_titleFM); #set the title
        caxKeo = dividerKeo.append_axes('right', size='3%', pad=0.30); #make a color bar axis
        
        caxKeo.yaxis.label.set_font_properties(FONT_axisLabelFM);
                
        #now for the other other plot (dividerKeo2, ax[2])
        #Remove the aspect ratio from the basemap so it fills the screen better
        ax[2].set_aspect('auto');
        
        string_title = 'Prep Title'; #create mecha title
        ax[2].set_title(string_title,fontproperties=FONT_titleFM); #set the title
        caxKeo2 = dividerKeo2.append_axes('right', size='3%', pad=0.30); #make a color bar axis
        
        caxKeo2.yaxis.label.set_font_properties(FONT_axisLabelFM);
        
        #fig.tight_layout(); #function for a tight layout, doesn't seem to do much here
        plt.draw(); #req to make plot size be right
        plt.show(); #req to make plot show up
        
        #update gif_figureSize to now be the size of the movie plot (it'll be smaller if there are other plots on the screen)
        bbox = ax[0].get_window_extent().transformed(fig.dpi_scale_trans.inverted()); #get the size of the movie plot currently
        width, height = bbox.width, bbox.height; #break out the width/height in inches or something
        gif_figureSize = np.int64(np.round(np.array( (width*fig.dpi, height*fig.dpi) ))); #save that size, convert from inches to pixels using DPI
        
    elif( (gif_Type == 8) ): #creates figure with 2 plots (TEC on top, time series on bottom)
        
        fig, ax = plt.subplots(figsize = gif_figureSize/gif_figurePPI,nrows=2, ncols=1); #use instead of fig because it inits an axis too (I think I dunno)
        figManager = plt.get_current_fig_manager(); #req to maximize
        figManager.window.showMaximized(); #force maximized
        divider = make_axes_locatable(ax[0]); #prep to add an axis (top one is TEC so it gets it)
        cax = divider.append_axes('right', size='1.5%', pad=0.35); #make a color bar axis
        cax.yaxis.label.set_font_properties(FONT_axisLabelFM);
        
        #mill for square Mercator style
        #robin for oval shape
        geoMap = Basemap(projection=geoMap_projectionStyle, lat_0=np.mean(plotLatRange), lon_0=np.mean(plotLongRange), #projection type, and I think lat_0/lon_0 are the centers?
            resolution = 'i', area_thresh = 10000, ax=ax[0], #resolutions I know are l, i, h - i seems good. area_thresh being big prevents it drawing lil lakes, 0.1 makes everything
            llcrnrlon=np.float32(plotLongRange[0]), llcrnrlat=np.float32(plotLatRange[0]), #lower left corner lat/long - MUST BE FLOAT cause CODED BY THE BEST
            urcrnrlon=np.float32(plotLongRange[1]), urcrnrlat=np.float32(plotLatRange[1])); #upper right corner lat/long - MUST BE FLOAT cause CODED BY THE BEST
        
        geoMap.drawcoastlines(zorder=25); #always on top
        if( gif_ContinentFill == 1 ): #color in stuff if this is on
            #geoMap.drawcountries();
            #geoMap.drawmapboundary();
            geoMap.fillcontinents(color=gif_ContientColor,lake_color=gif_ContinentWaterColor,zorder=1);
            geoMap.drawmapboundary(fill_color=gif_ContinentWaterColor,zorder=0);
        #END IF
        
        #Remove the aspect ratio from the basemap so it fills the screen better
        ax[0].set_aspect('auto');
        ax[1].set_aspect('auto');
        
        #np.linspace(startlat,endlat,5) # 5 = number of "ticks"
        geoMap.drawmeridians( np.round(np.arange(np.floor(np.min(plotLongRange)),np.ceil(np.max(plotLongRange))+1,plotLongRange_autoTick),2), 
            labels=[True,False,False,True], labelstyle='+/-', dashes=[6,15000], color='black' ); #adds the labels but keeps the lines invisible
        geoMap.drawparallels(np.round(np.arange(np.floor(np.min(plotLatRange)),np.ceil(np.max(plotLatRange))+1,plotLatRange_autoTick),2), 
            labels=[True,False,True,False], labelstyle='+/-', dashes=[6,15000], color='black' ); #adds the labels but keeps the lines invisible
        #dashes[6,15000] seems to be enough to keep the repeating dash from happening on a world plot (I think it's how wide a dash is and the dash spacing). 900 was good for 22 degc longitude, for ref.
        #labels=[left,right,top,bottom] is the order. true/false to turn them on and off. not sure why there's a top/bottom for the parallels but w/e people do it
        
        string_title = 'Prep Title'; #create mecha title
        ax[0].set_title(string_title,fontproperties=FONT_titleFM); #set the upper title
        ax[1].set_title(string_title,fontproperties=FONT_titleFM); #set the lower title
        
        fig.subplots_adjust(left = 0.045, right = 0.945, top = 0.96, bottom = 0.065, hspace = 0.15); #sets padding to small numbers for minimal white space
        #fig.tight_layout(); #function for a tight layout, doesn't seem to do much here
        plt.show(); #req to make plot show up  
        
        #update gif_figureSize to now be the size of the movie plot (it'll be smaller if there are other plots on the screen)
        bbox = ax[0].get_window_extent().transformed(fig.dpi_scale_trans.inverted()); #get the size of the movie plot currently
        width, height = bbox.width, bbox.height; #break out the width/height in inches or something
        gif_figureSize = np.int64(np.round(np.array( (width*fig.dpi, height*fig.dpi) ))); #save that size, convert from inches to pixels using DPI
        
    if( (gif_Type == 9) ): #creates figure with 1 plot (geomap) and 2 colorbars (left is AMPERE) AND 1 plot time series (OMNI data)
    
        fig, ax = plt.subplots(figsize = gif_figureSize/gif_figurePPI,nrows=2, ncols=1); #use instead of fig because it inits an axis too (I think I dunno)
        figManager = plt.get_current_fig_manager(); #req to maximize
        figManager.window.showMaximized(); #force maximized
        divider = make_axes_locatable(ax[0]); #prep to add an axis
        cax = divider.append_axes('right', size='1.5%', pad=0.35); #make a color bar axis
        cax.yaxis.label.set_font_properties(FONT_axisLabelFM);
        cax2 = divider.append_axes('left', size='1.5%', pad=0.85); #make a color bar axis
        cax2.yaxis.label.set_font_properties(FONT_axisLabelFM);
        
        #mill for square Mercator style
        #robin for oval shape
        geoMap = Basemap(projection=geoMap_projectionStyle, lat_0=np.mean(plotLatRange), lon_0=np.mean(plotLongRange), #projection type, and I think lat_0/lon_0 are the centers?
            resolution = 'i', area_thresh = 10000, ax=ax[0], #resolutions I know are l, i, h - i seems good. area_thresh being big prevents it drawing lil lakes, 0.1 makes everything
            llcrnrlon=np.float32(plotLongRange[0]), llcrnrlat=np.float32(plotLatRange[0]), #lower left corner lat/long - MUST BE FLOAT cause CODED BY THE BEST
            urcrnrlon=np.float32(plotLongRange[1]), urcrnrlat=np.float32(plotLatRange[1])); #upper right corner lat/long - MUST BE FLOAT cause CODED BY THE BEST
        
        geoMap.drawcoastlines(zorder=25); #always on top
        if( gif_ContinentFill == 1 ): #color in stuff if this is on
            #geoMap.drawcountries();
            #geoMap.drawmapboundary();
            geoMap.fillcontinents(color=gif_ContientColor,lake_color=gif_ContinentWaterColor,zorder=1);
            geoMap.drawmapboundary(fill_color=gif_ContinentWaterColor,zorder=0);
        #END IF
        
        #Remove the aspect ratio from the basemap so it fills the screen better
        ax[0].set_aspect('auto');
        ax[1].set_aspect('auto');
        
        #np.linspace(startlat,endlat,5) # 5 = number of "ticks"
        geoMap.drawmeridians( np.round(np.arange(np.floor(np.min(plotLongRange)),np.ceil(np.max(plotLongRange))+1,plotLongRange_autoTick),2), 
            labels=[True,False,False,True], labelstyle='+/-', dashes=[6,15000], color='black' ); #adds the labels but keeps the lines invisible
        geoMap.drawparallels(np.round(np.arange(np.floor(np.min(plotLatRange)),np.ceil(np.max(plotLatRange))+1,plotLatRange_autoTick),2), 
            labels=[True,False,True,False], labelstyle='+/-', dashes=[6,15000], color='black' ); #adds the labels but keeps the lines invisible
        #dashes[6,15000] seems to be enough to keep the repeating dash from happening on a world plot (I think it's how wide a dash is and the dash spacing). 900 was good for 22 degc longitude, for ref.
        #labels=[left,right,top,bottom] is the order. true/false to turn them on and off. not sure why there's a top/bottom for the parallels but w/e people do it
        
        string_title = 'Prep Title'; #create mecha title
        ax[0].set_title(string_title,fontproperties=FONT_titleFM); #set the upper title
        ax[1].set_title(string_title,fontproperties=FONT_titleFM); #set the lower title
        
        fig.subplots_adjust(left = 0.045, right = 0.945, top = 0.96, bottom = 0.065, hspace = 0.15); #sets padding to small numbers for minimal white space
        #fig.tight_layout(); #function for a tight layout, doesn't seem to do much here
        plt.show(); #req to make plot show up
        
        #update gif_figureSize to now be the size of the movie plot (it'll be smaller if there are other plots on the screen)
        bbox = ax[0].get_window_extent().transformed(fig.dpi_scale_trans.inverted()); #get the size of the movie plot currently
        width, height = bbox.width, bbox.height; #break out the width/height in inches or something
        gif_figureSize = np.int64(np.round(np.array( (width*fig.dpi, height*fig.dpi) ))); #save that size, convert from inches to pixels using DPI
    #END IF
        
        
    plt.rcParams['animation.ffmpeg_path'] = ffmpegLocale; #sets where the ffmpeg path is
    
    #---------------------FORCE GRID TO HAVE SQUARE GRID POINTS----------------
    #I don't know if it's a great idea. But it works
#    gif_Grid_TotalGrids = (plotLatRange[-1] - plotLatRange[0])*(plotLongRange[-1] - plotLongRange[0])*gif_Grid_Div; #get an estimate for how many pixels we want   
    gif_Grid_Lat_Spaces = (plotLatRange[-1] - plotLatRange[0])*np.sqrt(gif_Grid_Div); #get the lat degrees
    gif_Grid_Long_Spaces = (plotLongRange[-1] - plotLongRange[0])*np.sqrt(gif_Grid_Div); #get the long degrees
    gif_Grid_AdjustmentRatio = gif_figureSize[0]/gif_figureSize[1]; #get the adjustment ratio needed
    gif_Grid_TotalGrids = gif_Grid_Lat_Spaces*gif_Grid_Long_Spaces; #get total grid points
    if( gif_Grid_Long_Spaces > gif_Grid_Lat_Spaces):
        #adjust long spaces since it's the bigger number
        gif_Grid_Long_Spaces = gif_Grid_Lat_Spaces*gif_Grid_AdjustmentRatio; #make it square (make it be lat spaces) then apply the ratio
        gif_Grid_TotalGrids_Adj = gif_Grid_Lat_Spaces*gif_Grid_Long_Spaces; #get the adjusted total
        gif_Grid_TotalGrids_RatioSqrt = np.sqrt(gif_Grid_TotalGrids/gif_Grid_TotalGrids_Adj); #get the ratio of total grids, take sqrt b/c of how we'll adjust lat/long spaces
        gif_Grid_Long_Spaces = np.int64(np.round(gif_Grid_Long_Spaces*gif_Grid_TotalGrids_RatioSqrt)); #make gif grid total be about the right size
        gif_Grid_Lat_Spaces = np.int64(np.round(gif_Grid_Lat_Spaces*gif_Grid_TotalGrids_RatioSqrt)); #make gif grid total be about the right size
    else:
        #adjust lat spaces since it's the bigger number
        gif_Grid_Lat_Spaces = gif_Grid_Long_Spaces/gif_Grid_AdjustmentRatio; #make it square (make it be long spaces) then apply the ratio
        gif_Grid_TotalGrids_Adj = gif_Grid_Lat_Spaces*gif_Grid_Long_Spaces; #get the adjusted total
        gif_Grid_TotalGrids_RatioSqrt = np.sqrt(gif_Grid_TotalGrids/gif_Grid_TotalGrids_Adj); #get the ratio of total grids, take sqrt b/c of how we'll adjust lat/long spaces
        gif_Grid_Long_Spaces = np.int64(np.round(gif_Grid_Long_Spaces*gif_Grid_TotalGrids_RatioSqrt)); #make gif grid total be about the right size
        gif_Grid_Lat_Spaces = np.int64(np.round(gif_Grid_Lat_Spaces*gif_Grid_TotalGrids_RatioSqrt)); #make gif grid total be about the right size
    #END IF
    
    
    #old method, wasn't working for me
#    gif_Grid_TotalGrids = gif_Grid_Lat_Spaces*gif_Grid_Long_Spaces; #et total grid points
#    if( gif_figureSize[0] < gif_figureSize[1] ): #gif_figureSize[0] X is less than gif_figureSize[1] Y - which means that to square it Y grid needs to go up while X goes down (to maintain total grid number)
#        gif_Grid_AdjustmentRatio = gif_figureSize[0]/gif_figureSize[1]; #get the adjustment ratio needed
#        gif_Grid_Lat_Spaces = np.round(gif_Grid_Lat_Spaces/gif_Grid_AdjustmentRatio); #apply the ratio by boosting Y
#        gif_Grid_Long_Spaces = np.round(gif_Grid_Long_Spaces*gif_Grid_AdjustmentRatio); #apply the ratio by reducing X
#        gif_Grid_TotalGrids_Adj = gif_Grid_Lat_Spaces*gif_Grid_Long_Spaces; #get new adjusted grid points
#        if( gif_Grid_TotalGrids != gif_Grid_TotalGrids_Adj ): #if adjusted sizes doesn't have the same number as the orig, fix it
#            gif_Grid_TotalGrids_Delta = gif_Grid_TotalGrids_Adj - gif_Grid_TotalGrids; #get delta between two numbers
#            gif_Grid_TotalGrids_LatNearness = np.abs(np.abs(gif_Grid_TotalGrids_Delta) - gif_Grid_Lat_Spaces); #find how close lat can fix the delta
#            gif_Grid_TotalGrids_LongNearness = np.abs(np.abs(gif_Grid_TotalGrids_Delta) - gif_Grid_Long_Spaces); #find how close long can fix the delta
#            if( gif_Grid_TotalGrids_LatNearness < gif_Grid_TotalGrids_LongNearness ):
#                if( gif_Grid_TotalGrids_Delta > 0 ): #if delta is positive, then need to reduce spaces to get it down
#                    gif_Grid_Long_Spaces = gif_Grid_Long_Spaces - 1; #reduce the number of long spaces so total decreases to latSpace*(longSpace-1) (adj by 1 latSpace essentially)
#                else: #if delta is negative, then need to increase spaces to get it up
#                    gif_Grid_Long_Spaces = gif_Grid_Long_Spaces + 1; #inrease the number of long spaces so total increases to latSpace*(longSpace-1) (adj by 1 latSpace essentially)
#                #END IF
#            else:
#                if( gif_Grid_TotalGrids_Delta > 0 ): #if delta is positive, then need to reduce spaces to get it down
#                    gif_Grid_Lat_Spaces = gif_Grid_Lat_Spaces - 1; #reduce the number of lat spaces so total decreases to (latSpace-1)*longSpace (adj by 1 longSpace essentially)
#                else: #if delta is negative, then need to increase spaces to get it up
#                    gif_Grid_Lat_Spaces = gif_Grid_Lat_Spaces + 1; #inrease the number of lat spaces so total increases to (latSpace+1)*longSpace (adj by 1 longSpace essentially)
#                #END IF
#            #END IF
#        #END IF
#    else: #otherwise gif_figureSize[1] Y is less than gif_figureSize[0] X - which means that to square it X grid needs to go up while Y goes down (to maintain total grid number)
#        gif_Grid_AdjustmentRatio = gif_figureSize[0]/gif_figureSize[1]; #get the adjustment ratio needed
#        gif_Grid_Lat_Spaces = np.round(gif_Grid_Lat_Spaces*gif_Grid_AdjustmentRatio); #apply the ratio by reducing Y
#        gif_Grid_Long_Spaces = np.round(gif_Grid_Long_Spaces/gif_Grid_AdjustmentRatio); #apply the ratio by boosting X
#        gif_Grid_TotalGrids_Adj = gif_Grid_Lat_Spaces*gif_Grid_Long_Spaces; #get new adjusted grid points
#        if( gif_Grid_TotalGrids != gif_Grid_TotalGrids_Adj ): #if adjusted sizes doesn't have the same number as the orig, fix it
#            gif_Grid_TotalGrids_Delta = gif_Grid_TotalGrids_Adj - gif_Grid_TotalGrids; #get delta between two numbers
#            gif_Grid_TotalGrids_LatNearness = np.abs(np.abs(gif_Grid_TotalGrids_Delta) - gif_Grid_Lat_Spaces); #find how close lat can fix the delta
#            gif_Grid_TotalGrids_LongNearness = np.abs(np.abs(gif_Grid_TotalGrids_Delta) - gif_Grid_Long_Spaces); #find how close long can fix the delta
#            if( gif_Grid_TotalGrids_LatNearness < gif_Grid_TotalGrids_LongNearness ):
#                if( gif_Grid_TotalGrids_Delta > 0 ): #if delta is positive, then need to reduce spaces to get it down
#                    gif_Grid_Long_Spaces = gif_Grid_Long_Spaces - 1; #reduce the number of long spaces so total decreases to latSpace*(longSpace-1) (adj by 1 latSpace essentially)
#                else: #if delta is negative, then need to increase spaces to get it up
#                    gif_Grid_Long_Spaces = gif_Grid_Long_Spaces + 1; #inrease the number of long spaces so total increases to latSpace*(longSpace-1) (adj by 1 latSpace essentially)
#                #END IF
#            else:
#                if( gif_Grid_TotalGrids_Delta > 0 ): #if delta is positive, then need to reduce spaces to get it down
#                    gif_Grid_Lat_Spaces = gif_Grid_Lat_Spaces - 1; #reduce the number of lat spaces so total decreases to (latSpace-1)*longSpace (adj by 1 longSpace essentially)
#                else: #if delta is negative, then need to increase spaces to get it up
#                    gif_Grid_Lat_Spaces = gif_Grid_Lat_Spaces + 1; #inrease the number of lat spaces so total increases to (latSpace+1)*longSpace (adj by 1 longSpace essentially)
#                #END IF
#            #END IF
#        #END IF
#    #END IF
#    gif_Grid_Lat_Spaces = np.int64(gif_Grid_Lat_Spaces); #convert to int to be sure
#    gif_Grid_Long_Spaces = np.int64(gif_Grid_Long_Spaces); #convert to int to be sure
    
    #----------------------PRIME THE LAT/LONG GRID-----------------------------
    gif_Grid_Lat = np.linspace(np.min(plotLatRange),np.max(plotLatRange),gif_Grid_Lat_Spaces+1); #degc, create lat points (+1 lets us use delta to edge wanted range - yields correct # of spaces)
    gif_Grid_Long = np.linspace(np.min(plotLongRange),np.max(plotLongRange),gif_Grid_Long_Spaces+1); #degc, create long points (+1 lets us use delta to edge wanted range - yields correct # of spaces)
    gif_Grid_Lat_Delta = np.abs(gif_Grid_Lat[1] - gif_Grid_Lat[0]); #degc, lat delta
    gif_Grid_Long_Delta = np.abs(gif_Grid_Long[1] - gif_Grid_Long[0]); #degc, long delta
    
    #---------------------PRIME THE TIME LIMIT RANGE---------------------------
    if( gif_timeLim == 1 ):
        gif_timeRange = np.zeros(2,dtype=np.int64); #preallocate
        gif_timeRange[0] = np.where( np.abs(np.min(gif_timeLimRange) - (TEC_timeUnique-dateRange_dayNum_zeroHr[1]*86400)) == np.min(np.abs(np.min(gif_timeLimRange) - (TEC_timeUnique-dateRange_dayNum_zeroHr[1]*86400))) )[0]; #get index where min is closest for the time step
        gif_timeRange[1] = np.where( np.abs(np.max(gif_timeLimRange) - (TEC_timeUnique-dateRange_dayNum_zeroHr[1]*86400)) == np.min(np.abs(np.max(gif_timeLimRange) - (TEC_timeUnique-dateRange_dayNum_zeroHr[1]*86400))) )[0]; #get index where max is closest for the time step
    else:
        gif_timeRange = np.array([0,TEC_timeUnique.size]); #set to max time if gif_timeLim isn't on
    #END IF
    
    #---------------------PRIME THE POLAR CIRCULAR STUFF-----------------------
    if( geoMap_projectionStyle_polar >= 1):
        #Constants needed
        ReAdj = Re*1000*np.pi/180; #convert Re to meters, toss in the pi/180 conversion needed for degrees as well
    
        #THIS IS FOR ROTATING THE EARTH (from ref J2000)
        #J2000 is
        #January 1, 2000, 11:58:55.816
        #Good luck
        dateRange_J2000 = np.zeros( (2,2) ); #preallocate
        dateRange_J2000[0,0] = 2000; #put in J2000's defining stuff
        dateRange_J2000[0,1] = 1; #put in J2000's defining stuff
        dateRange_J2000[1,0] = dateRange_dayNum_zeroHr[0]; #get the year number for the reference day
        dateRange_J2000[1,1] = dateRange_dayNum_zeroHr[1]; #get the day number for the reference day
        [_,dateRange_J2000] = subfun_dateORdayNum_to_fullRange(dateRange_J2000); #get the days involved
        secRange_J2000 = 3600*24*(dateRange_J2000.shape[0]-1) - (11*3600+58*60+55.816); #sec since J2000 epoch of Jan 1st, 2000 @ 11:58:55.816 from https://en.wikipedia.org/wiki/Equinox_(celestial_coordinates)#J2000.0
        # used full hour since that's what days do, made sense promise
        # Mean angular velocity of Earth (7.292115*10^-5) is from http://hpiers.obspm.fr/eop-pc/models/constants.html    
        radRange_J2000_EmpiricalConst = -156.42; #deg, found from seeing what it was and what it was supposed to be in stellarium
        radRange_J2000 = (secRange_J2000 + (TEC_timeUnique[gif_timeRange[0]:gif_timeRange[1]] - dateRange_dayNum_zeroHr[1]*86400)*3600)*-7.292115*10**-5; #rad, converts time since J2000 to radians covered since J2000 through earth's angular velocity
        radRange_J2000 = radRange_J2000 + radRange_J2000_EmpiricalConst*np.pi/180; #adjustment
        # i = find( min(abs((timeUnique - dateRange_zeroHr(2))*24 - 10)) == abs((timeUnique - dateRange_zeroHr(2))*24 - 10) );
        # radRange_J2000(i)*180/pi
        #Reports 84.93 deg, should be longMillstone -71.49 deg from using stellarium at 13:00 EDT (17 UT) where sun is directly overhead (more or less) - add -156.42 deg to fix
        #more accurate would be to relocate to equator I guess
        #Couldn't find where earth was pointing with J2000 with reference to the sun easily so yolo
        radRange_J2000 = np.mod(radRange_J2000,2*np.pi) - np.pi; #converts to -180 to 180
        # mod brings it down to 0<=angle<=2*pi b/c cyclic trig
        # - pi brings it down to -pi<=angle<=pi to help with understanding what it is
        #***************MAKE THIS NOT EMPIRICAL SOMEDAY******************** CLOSE!
    #END IF
    
    #----------------------PREP FOR MOVIE MAKING-------------------------------
    if( os.path.isdir(gif_Save_Locale) == 0 ): #check if TEC folder exists
        #if not, make it
        os.makedirs(gif_Save_Locale);
        print("NOTA BENE: Moving Making Function - Created plot directory: "+gif_Save_Locale+"\n");
    #END IF
    os.chdir(gif_Save_Locale); #move to the movie save folder
    
    #need to do same frame for a while to make it good
    gif_DesiredFPS = np.round(1/gif_DesiredFrameTime); #frames/sec, desired frames per sec from the frame time (how long a frame is on the screen)
    
    if( gif_MP4 == 1 ): #supports choosing video or GIF (video only right now)
        gif_vidFrameRate = 30; #set FPS to 30 to start off
        if( gif_Type == 0 | gif_Type == 1 | gif_Type == 2 | gif_Type == 3 | gif_Type == 5 | gif_Type == 6 | gif_Type == 7 | gif_Type == 8 | gif_Type == 9): #supports doubling frame rate for the movies not using time-averaging (they do their own thing)
            if( ( TEC_timeUnique.size/30 > gif_DesiredMaxRunTime ) & ( gif_FLGdisableFPSShift == 0 ) ): #try to keep run time down
                gif_vidFrameRate = 60; #set the FPS to 60
            #END IF
        #END IF
    else:
        pass; #nothing special now
    #END IF
        
    #------------------------Initialize Video------------------------------
    #same for all gif types
    FFMpegWriter = manimation.writers['ffmpeg'];
    if( gif_MP4 == 1 ):
        gif_writer = FFMpegWriter(fps=gif_vidFrameRate, codec="h264", bitrate=25000); #create a movie writer
        #extra stuff , codec="h264", extra_args=["-y"]
        gif_Name = gif_Name+".mp4"; #add the file ending
    else: #otherwise it is a gif
        gif_writer = FFMpegWriter(fps=gif_vidFrameRate, codec="gif", bitrate=25000); #create a movie writer
        gif_Name = gif_Name+".gif"; #add the file ending
    #END IF
    
    #gif_ScreenSize = fig.get_size_inches(); #gets the horizontal x vertical in inches (seems to be pixels really?)
    gif_PPI = fig.dpi; #the gif_writer.saving wants a PPI (it calls it DPI - same thing just wrong name)
        
        
    #-------------Multiple Movie Algs for Difference Scenarios-----------------
    #================================================================= GIF TYPE 0 =================================================================
    if(gif_Type == 0): #moving gif implementation (scatter points)
        
        with gif_writer.saving(fig, gif_Name, gif_PPI): #figure to save, file name, and PPI (DPI in documentation)
        
            #-------------------------Start Making Pictures------------------------
            for i in range(0,TEC_timeUnique.size):
        
                #----------------Corral the data to the right place----------------
                k =  np.where( data['TEC']['time'] == TEC_timeUnique[i])[0]; #gets during a time period
                
                #----------------------------Tack on Title-------------------------
                string_title = 'TEC Global Plot, Time =  '+'{0:.2f}'.format(np.round((TEC_timeUnique[i]-dateRange_dayNum_zeroHr[1]*86400),2))+\
                    ', 0 UT on '+dateRange_zeroHr_monthName+' '+str(dateRange_zeroHr[2])+', '+str(dateRange_dayNum_zeroHr[0]); #create mecha title
                
                ax.set_title(string_title,fontproperties=FONT_titleFM); #set the title, properties always needed
                    
                #-------------------Starting the Plotting--------------------------
                if( i == 0 ): #first run preps axes, color bars, etc.
                    
                    TEC_latLongMapped = geoMap(data['TEC']['long'][k],data['TEC']['lat'][k]); #convert the lat/long arcdeg to the current map coordinates
                    
                    #Do the TEC plotting
                    imTEC = ax.scatter(TEC_latLongMapped[0],TEC_latLongMapped[1],s=gif_Scatter_Point_Size_TEC,c=data['TEC']['dTEC'][k],cmap='jet', vmin=-TEC_plotLimValu, vmax=TEC_plotLimValu, zorder=5);
                    cbar = fig.colorbar(imTEC, cax=cax, orientation='vertical'); #create a colorbar using the prev. defined cax
                    cax.yaxis.set_ticks(np.linspace(-TEC_plotLimValu,TEC_plotLimValu,5)); #create useful tick marks
                    cax.yaxis.set_major_formatter(FormatStrFormatter('%.2f')); #force a rounded format
                    cbar.set_label("delta-vTEC [TECU]"); #tabel the colorbar
                    cbar.ax.tick_params(labelsize=FONT_axisTick);
                    cbar.mappable.set_clim(vmin=-TEC_plotLimValu, vmax=TEC_plotLimValu);
    
                    if( gif_dayNiteLine == 1 ):
                        fig.canvas.flush_events(); #this is req. to get get_window_extent() to get the current window size
                        #Plot the sunrise/sunset terminators
                        dayNite_temp = np.abs(dayNite_sunrise - (TEC_timeUnique[i]-dateRange_dayNum_zeroHr[1]*86400)) <= 10/3600; #gets the sunrise locations that are within 10 sec of the current TEC time (2 min had way too many hits, zigzags)
                        hLgd_FLG_day = np.sum(dayNite_temp); #plotting flag, shows when legend is active
                        #constants will use all the time - only for plotting of day/nite line so minor importance
                        bbox = ax.get_window_extent().transformed(fig.dpi_scale_trans.inverted()); #get the plot dimensions
                        plot_ratio = bbox.width/bbox.height; #get the plot ratio, will use it to fix up the angle
                        dayNite_textRotationLenOrig = 35; #length to go up and down the sunrise/sunset line to estimate an angle
                        dayNite_savgolFiltLenOrig = 101; #set it as a constant to start off
                        dayNite_textLatAbs = (np.max(plotLatRange)-np.min(plotLatRange))*.9 + np.min(plotLatRange); #calc like 80% of the max latitude
                        if( hLgd_FLG_day > 0 ): #only do work if it is there
                            #calc all that day/nite stuff in one function to keep it from getting cluttered
                            dayNite_Lat_line, dayNite_Long_line, dayNite_Lat_text, dayNite_Long_text, dayNite_textRotation = GRITI_movieMaker_subfun_dayniteCalc(0,np.sum(dayNite_temp),dayNite_Grid_Long[dayNite_temp],dayNite_Grid_Lat[dayNite_temp],dayNite_textLatAbs,plot_ratio,dayNite_savgolFiltLenOrig,dayNite_textRotationLenOrig);
                            dayNite_latLongMapped = geoMap(dayNite_Long_line,dayNite_Lat_line); #convert the lat/long arcdeg to the current map coordinates
                            imDayNite_day = ax.plot(dayNite_latLongMapped[0],dayNite_latLongMapped[1],color='g',linewidth=1.75,zorder=6); #plots a line to show the sunrise time
                            if( gif_dayNiteText == 1 ):
                                dayNite_latLongMapped = geoMap(dayNite_Long_text,dayNite_Lat_text); #convert the lat/long arcdeg to the current map coordinates
                                textDayNite_day = ax.text(dayNite_latLongMapped[0], dayNite_latLongMapped[1], "Sunrise", rotation=dayNite_textRotation, color='g', fontsize=FONT_axisTick, zorder=6);
                            #END IF
                        #END IF
                        
                        dayNite_temp = np.abs(dayNite_sunset - (TEC_timeUnique[i]-dateRange_dayNum_zeroHr[1]*86400)) <= 10/3600; #gets the sunset locations that are within 10 sec of the current TEC time (2 min had way too many hits, zigzags)
                        hLgd_FLG_nite = np.sum(dayNite_temp); #plotting flag, shows when legend is active
                        if( hLgd_FLG_nite > 0 ): #only do work if it is there
                            #calc all that day/nite stuff in one function to keep it from getting cluttered
                            dayNite_Lat_line, dayNite_Long_line, dayNite_Lat_text, dayNite_Long_text, dayNite_textRotation = GRITI_movieMaker_subfun_dayniteCalc(1,np.sum(dayNite_temp),dayNite_Grid_Long[dayNite_temp],dayNite_Grid_Lat[dayNite_temp],dayNite_textLatAbs,plot_ratio,dayNite_savgolFiltLenOrig,dayNite_textRotationLenOrig);
                            dayNite_latLongMapped = geoMap(dayNite_Long_line,dayNite_Lat_line); #convert the lat/long arcdeg to the current map coordinates
                            imDayNite_nite = ax.plot(dayNite_latLongMapped[0],dayNite_latLongMapped[1],color='b',linewidth=1.75,zorder=6); #plots a line to show the sunset time
                            if( gif_dayNiteText == 1 ):
                                dayNite_latLongMapped = geoMap(dayNite_Long_text,dayNite_Lat_text); #convert the lat/long arcdeg to the current map coordinates
                                textDayNite_nite = ax.text(dayNite_latLongMapped[0], dayNite_latLongMapped[1], "Sunset", rotation=dayNite_textRotation, color='b', fontsize=FONT_axisTick, zorder=6);
                            #EMD IF
                        #END IF
                    #END IF
                    
                    #Now drawing line of interest
    #                imMillstone = plot(fig1Axes,longMillstone,latMillstone,gif_Millstone_Marker,'Color',gif_Millstone_Marker_Color,'MarkerSize',gif_Millstone_Marker_Size); #plots a point with a red big *
                    
                    Millstone_latLongMapped = geoMap(longMillstone,latMillstone); #convert the lat/long arcdeg to the current map coordinates
                    imMillstone = ax.plot(Millstone_latLongMapped[0],Millstone_latLongMapped[1],marker=gif_Millstone_Marker, color=gif_Millstone_Marker_Color, markersize=gif_Millstone_Marker_Size, zorder=50); #plot this, 50 always on top
                    
                else:
                    #Just plotting now - prep done, hopefully speeds it!
                    TEC_latLongMapped = geoMap(data['TEC']['long'][k],data['TEC']['lat'][k]); #convert the lat/long arcdeg to the current map coordinates
    
                    #Do the TEC plotting
                    imTEC = ax.scatter(TEC_latLongMapped[0],TEC_latLongMapped[1],s=gif_Scatter_Point_Size_TEC,c=data['TEC']['dTEC'][k],cmap='jet', vmin=-TEC_plotLimValu, vmax=TEC_plotLimValu, zorder=5);
    
                    if( gif_dayNiteLine == 1 ):
                        #Plot the sunrise/sunset terminators
                        dayNite_temp = np.abs(dayNite_sunrise - (TEC_timeUnique[i]-dateRange_dayNum_zeroHr[1]*86400)) <= 10/3600; #gets the sunrise locations that are within 10 sec of the current TEC time (2 min had way too many hits, zigzags)
                        hLgd_FLG_day = np.sum(dayNite_temp); #plotting flag, shows when legend is active
                        if( hLgd_FLG_day > 0 ): #only do work if it is there
                            #calc all that day/nite stuff in one function to keep it from getting cluttered
                            dayNite_Lat_line, dayNite_Long_line, dayNite_Lat_text, dayNite_Long_text, dayNite_textRotation = GRITI_movieMaker_subfun_dayniteCalc(0,np.sum(dayNite_temp),dayNite_Grid_Long[dayNite_temp],dayNite_Grid_Lat[dayNite_temp],dayNite_textLatAbs,plot_ratio,dayNite_savgolFiltLenOrig,dayNite_textRotationLenOrig);
                            dayNite_latLongMapped = geoMap(dayNite_Long_line,dayNite_Lat_line); #convert the lat/long arcdeg to the current map coordinates
                            imDayNite_day = ax.plot(dayNite_latLongMapped[0],dayNite_latLongMapped[1],color='g',linewidth=1.75,zorder=6); #plots a line to show the sunrise time
                            if( gif_dayNiteText == 1 ):
                                dayNite_latLongMapped = geoMap(dayNite_Long_text,dayNite_Lat_text); #convert the lat/long arcdeg to the current map coordinates
                                textDayNite_day = ax.text(dayNite_latLongMapped[0], dayNite_latLongMapped[1], "Sunrise", rotation=dayNite_textRotation, color='g', fontsize=FONT_axisTick, zorder=6);
                            #END IF
                        #END IF
                        
                        dayNite_temp = np.abs(dayNite_sunset - (TEC_timeUnique[i]-dateRange_dayNum_zeroHr[1]*86400)) <= 10/3600; #gets the sunset locations that are within 10 sec of the current TEC time (2 min had way too many hits, zigzags)
                        hLgd_FLG_nite = np.sum(dayNite_temp); #plotting flag, shows when legend is active
                        if( hLgd_FLG_nite > 0 ): #only do work if it is there
                            #calc all that day/nite stuff in one function to keep it from getting cluttered
                            dayNite_Lat_line, dayNite_Long_line, dayNite_Lat_text, dayNite_Long_text, dayNite_textRotation = GRITI_movieMaker_subfun_dayniteCalc(1,np.sum(dayNite_temp),dayNite_Grid_Long[dayNite_temp],dayNite_Grid_Lat[dayNite_temp],dayNite_textLatAbs,plot_ratio,dayNite_savgolFiltLenOrig,dayNite_textRotationLenOrig);
                            dayNite_latLongMapped = geoMap(dayNite_Long_line,dayNite_Lat_line); #convert the lat/long arcdeg to the current map coordinates
                            imDayNite_nite = ax.plot(dayNite_latLongMapped[0],dayNite_latLongMapped[1],color='b',linewidth=1.75,zorder=6); #plots a line to show the sunset time
                            if( gif_dayNiteText == 1 ):
                                dayNite_latLongMapped = geoMap(dayNite_Long_text,dayNite_Lat_text); #convert the lat/long arcdeg to the current map coordinates
                                textDayNite_nite = ax.text(dayNite_latLongMapped[0], dayNite_latLongMapped[1], "Sunset", rotation=dayNite_textRotation, color='b', fontsize=FONT_axisTick, zorder=6);
                            #END IF
                        #END IF
                    #END IF
                    
                    #Now drawing line of interest
    #                imMillstone = ax.plot(Millstone_latLongMapped[0],Millstone_latLongMapped[1],marker=gif_Millstone_Marker, markerfacecolor=gif_Millstone_Marker_Color ,markersize=gif_Millstone_Marker_Size); #plot this
                #END IF
            
            
                #-----------------------Create Movie/GIF---------------------------
                #Makes the gif now
                plt.draw();
                
                gif_writer.grab_frame(); #get the frame and save it
                            
                #-------------------Clean up for re-use----------------------------
                #if forget one (like hOverlay) slows it way down after many plots
                imTEC.remove();
    #            imOverlay.pop(0).remove();
    #            imMillstone.pop(0).remove();
                if( gif_dayNiteLine == 1 ):
                    if(hLgd_FLG_day > 0): #only delete if it is there
                        imDayNite_day.pop(0).remove();
                        if( gif_dayNiteText == 1 ):
                            textDayNite_day.remove();
                        #END IF
                    #END IF
                    if(hLgd_FLG_nite > 0): #only delete if it is there
                        imDayNite_nite.pop(0).remove();
                        if( gif_dayNiteText == 1 ):
                            textDayNite_nite.remove();
                        #END IF
                    #END IF
                #END IF
                
            #END FOR i
        #END WITH
    elif(gif_Type == 1): #stationary data points (through averaging)
        
        with gif_writer.saving(fig, gif_Name, gif_PPI): #figure to save, file name, and PPI (DPI in documentation)
        
            #-------------------------Start Making Pictures------------------------
            for i in range(0,TEC_timeUnique.size):
        
                #----------------Corral the data to the right place----------------
                k =  np.where( data['TEC']['time'] == TEC_timeUnique[i])[0]; #gets during a time period
                vTEC_portion = data['TEC']['dTEC'][k]; #pull out the vTEC now
                pplat_portion = data['TEC']['lat'][k]; #get the pplat (pierce-point lat) at the time required
                pplong_portion = data['TEC']['long'][k]; #get the pplong (pierce-point long) at the time required
                            
                gif_Grid = GRITI_movieMaker_subfun_dataGridder(pplat_portion,pplong_portion,vTEC_portion,gif_Grid_Lat,gif_Grid_Long,gif_Grid_Lat_Spaces,gif_Grid_Long_Spaces,gif_Grid_Lat_Delta,gif_Grid_Long_Delta,dataRejectOrig,dataRejectLimitOrig,dataRejectMax);
                #call a numba'd function that makes the movie quicker by crunching the numbers gooder
                
                #----------------------------Tack on Title-------------------------
                string_title = 'TEC Global Plot, Time =  '+'{0:.2f}'.format(np.round((TEC_timeUnique[i]-dateRange_dayNum_zeroHr[1]*86400),2))+\
                    ', 0 UT on '+dateRange_zeroHr_monthName+' '+str(dateRange_zeroHr[2])+', '+str(dateRange_dayNum_zeroHr[0]); #create mecha title
                
                ax.set_title(string_title,fontproperties=FONT_titleFM); #set the title, properties always needed
                    
                #-------------------Starting the Plotting--------------------------
                if( i == 0 ): #first run preps axes, color bars, etc.
                                   
                    #Do the TEC plotting
                    pltHelprX, pltHelprY = np.meshgrid( gif_Grid_Long, gif_Grid_Lat); #helps the pcolor work
                    TEC_latLongMapped = geoMap(pltHelprX,pltHelprY); #convert the lat/long arcdeg to the current map coordinates
                    imTEC = ax.pcolormesh(TEC_latLongMapped[0], TEC_latLongMapped[1],  gif_Grid.T ,vmin=-TEC_plotLimValu, vmax=TEC_plotLimValu,cmap='jet',zorder=5); # pseudocolor plot "stretched" to the grid
                    cbar = fig.colorbar(imTEC, cax=cax, orientation='vertical'); #create a colorbar using the prev. defined cax
                    cax.yaxis.set_ticks(np.linspace(-TEC_plotLimValu,TEC_plotLimValu,5)); #create useful tick marks
                    cax.yaxis.set_major_formatter(FormatStrFormatter('%.2f')); #force a rounded format
                    cbar.set_label("delta-vTEC [TECU]"); #tabel the colorbar
                    cbar.ax.tick_params(labelsize=FONT_axisTick);
                    cbar.mappable.set_clim(vmin=-TEC_plotLimValu, vmax=TEC_plotLimValu);
    
                    if( gif_dayNiteLine == 1 ):
                        fig.canvas.flush_events(); #this is req. to get get_window_extent() to get the current window size
                        #Plot the sunrise/sunset terminators
                        dayNite_temp = np.abs(dayNite_sunrise - (TEC_timeUnique[i]-dateRange_dayNum_zeroHr[1]*86400)) <= 10/3600; #gets the sunrise locations that are within 10 sec of the current TEC time (2 min had way too many hits, zigzags)
                        hLgd_FLG_day = np.sum(dayNite_temp); #plotting flag, shows when legend is active
                        #constants will use all the time - only for plotting of day/nite line so minor importance
                        bbox = ax.get_window_extent().transformed(fig.dpi_scale_trans.inverted()); #get the plot dimensions
                        plot_ratio = bbox.width/bbox.height; #get the plot ratio, will use it to fix up the angle
                        dayNite_textRotationLenOrig = 35; #length to go up and down the sunrise/sunset line to estimate an angle
                        dayNite_savgolFiltLenOrig = 101; #set it as a constant to start off
                        dayNite_textLatAbs = (np.max(plotLatRange)-np.min(plotLatRange))*.9 + np.min(plotLatRange); #calc like 80% of the max latitude
                        if( hLgd_FLG_day > 0 ): #only do work if it is there
                            #calc all that day/nite stuff in one function to keep it from getting cluttered
                            dayNite_Lat_line, dayNite_Long_line, dayNite_Lat_text, dayNite_Long_text, dayNite_textRotation = GRITI_movieMaker_subfun_dayniteCalc(0,np.sum(dayNite_temp),dayNite_Grid_Long[dayNite_temp],dayNite_Grid_Lat[dayNite_temp],dayNite_textLatAbs,plot_ratio,dayNite_savgolFiltLenOrig,dayNite_textRotationLenOrig);
                            dayNite_latLongMapped = geoMap(dayNite_Long_line,dayNite_Lat_line); #convert the lat/long arcdeg to the current map coordinates
                            imDayNite_day = ax.plot(dayNite_latLongMapped[0],dayNite_latLongMapped[1],color='g',linewidth=1.75,zorder=6); #plots a line to show the sunrise time
                            if( gif_dayNiteText == 1 ):
                                dayNite_latLongMapped = geoMap(dayNite_Long_text,dayNite_Lat_text); #convert the lat/long arcdeg to the current map coordinates
                                textDayNite_day = ax.text(dayNite_latLongMapped[0], dayNite_latLongMapped[1], "Sunrise", rotation=dayNite_textRotation, color='g', fontsize=FONT_axisTick, zorder=6);
                            #END IF
                        #END IF
                        
                        dayNite_temp = np.abs(dayNite_sunset - (TEC_timeUnique[i]-dateRange_dayNum_zeroHr[1]*86400)) <= 10/3600; #gets the sunset locations that are within 10 sec of the current TEC time (2 min had way too many hits, zigzags)
                        hLgd_FLG_nite = np.sum(dayNite_temp); #plotting flag, shows when legend is active
                        if( hLgd_FLG_nite > 0 ): #only do work if it is there
                            #calc all that day/nite stuff in one function to keep it from getting cluttered
                            dayNite_Lat_line, dayNite_Long_line, dayNite_Lat_text, dayNite_Long_text, dayNite_textRotation = GRITI_movieMaker_subfun_dayniteCalc(1,np.sum(dayNite_temp),dayNite_Grid_Long[dayNite_temp],dayNite_Grid_Lat[dayNite_temp],dayNite_textLatAbs,plot_ratio,dayNite_savgolFiltLenOrig,dayNite_textRotationLenOrig);
                            dayNite_latLongMapped = geoMap(dayNite_Long_line,dayNite_Lat_line); #convert the lat/long arcdeg to the current map coordinates
                            imDayNite_nite = ax.plot(dayNite_latLongMapped[0],dayNite_latLongMapped[1],color='b',linewidth=1.75,zorder=6); #plots a line to show the sunset time
                            if( gif_dayNiteText == 1 ):
                                dayNite_latLongMapped = geoMap(dayNite_Long_text,dayNite_Lat_text); #convert the lat/long arcdeg to the current map coordinates
                                textDayNite_nite = ax.text(dayNite_latLongMapped[0], dayNite_latLongMapped[1], "Sunset", rotation=dayNite_textRotation, color='b', fontsize=FONT_axisTick, zorder=6);
                            #EMD IF
                        #END IF
                    #END IF
                    
                    #Now drawing line of interest
    #                imMillstone = plot(fig1Axes,longMillstone,latMillstone,gif_Millstone_Marker,'Color',gif_Millstone_Marker_Color,'MarkerSize',gif_Millstone_Marker_Size); #plots a point with a red big *
                    
                    Millstone_latLongMapped = geoMap(longMillstone,latMillstone); #convert the lat/long arcdeg to the current map coordinates
                    imMillstone = ax.plot(Millstone_latLongMapped[0],Millstone_latLongMapped[1],marker=gif_Millstone_Marker, color=gif_Millstone_Marker_Color, markersize=gif_Millstone_Marker_Size, zorder=50); #plot this, 50 always on top
                    
                else:
                    #Just plotting now - prep done, hopefully speeds it!
                    #Do the TEC plotting
                    pltHelprX, pltHelprY = np.meshgrid( gif_Grid_Long, gif_Grid_Lat); #helps the pcolor work
                    TEC_latLongMapped = geoMap(pltHelprX,pltHelprY); #convert the lat/long arcdeg to the current map coordinates
                    imTEC = ax.pcolormesh(TEC_latLongMapped[0], TEC_latLongMapped[1],  gif_Grid.T ,vmin=-TEC_plotLimValu, vmax=TEC_plotLimValu,cmap='jet',zorder=5); # pseudocolor plot "stretched" to the grid
    
                    if( gif_dayNiteLine == 1 ):
                        #Plot the sunrise/sunset terminators
                        dayNite_temp = np.abs(dayNite_sunrise - (TEC_timeUnique[i]-dateRange_dayNum_zeroHr[1]*86400)) <= 10/3600; #gets the sunrise locations that are within 10 sec of the current TEC time (2 min had way too many hits, zigzags)
                        hLgd_FLG_day = np.sum(dayNite_temp); #plotting flag, shows when legend is active
                        if( hLgd_FLG_day > 0 ): #only do work if it is there
                            #calc all that day/nite stuff in one function to keep it from getting cluttered
                            dayNite_Lat_line, dayNite_Long_line, dayNite_Lat_text, dayNite_Long_text, dayNite_textRotation = GRITI_movieMaker_subfun_dayniteCalc(0,np.sum(dayNite_temp),dayNite_Grid_Long[dayNite_temp],dayNite_Grid_Lat[dayNite_temp],dayNite_textLatAbs,plot_ratio,dayNite_savgolFiltLenOrig,dayNite_textRotationLenOrig);
                            dayNite_latLongMapped = geoMap(dayNite_Long_line,dayNite_Lat_line); #convert the lat/long arcdeg to the current map coordinates
                            imDayNite_day = ax.plot(dayNite_latLongMapped[0],dayNite_latLongMapped[1],color='g',linewidth=1.75,zorder=6); #plots a line to show the sunrise time
                            if( gif_dayNiteText == 1 ):
                                dayNite_latLongMapped = geoMap(dayNite_Long_text,dayNite_Lat_text); #convert the lat/long arcdeg to the current map coordinates
                                textDayNite_day = ax.text(dayNite_latLongMapped[0], dayNite_latLongMapped[1], "Sunrise", rotation=dayNite_textRotation, color='g', fontsize=FONT_axisTick, zorder=6);
                            #END IF
                        #END IF
                        
                        dayNite_temp = np.abs(dayNite_sunset - (TEC_timeUnique[i]-dateRange_dayNum_zeroHr[1]*86400)) <= 10/3600; #gets the sunset locations that are within 10 sec of the current TEC time (2 min had way too many hits, zigzags)
                        hLgd_FLG_nite = np.sum(dayNite_temp); #plotting flag, shows when legend is active
                        if( hLgd_FLG_nite > 0 ): #only do work if it is there
                            #calc all that day/nite stuff in one function to keep it from getting cluttered
                            dayNite_Lat_line, dayNite_Long_line, dayNite_Lat_text, dayNite_Long_text, dayNite_textRotation = GRITI_movieMaker_subfun_dayniteCalc(1,np.sum(dayNite_temp),dayNite_Grid_Long[dayNite_temp],dayNite_Grid_Lat[dayNite_temp],dayNite_textLatAbs,plot_ratio,dayNite_savgolFiltLenOrig,dayNite_textRotationLenOrig);
                            dayNite_latLongMapped = geoMap(dayNite_Long_line,dayNite_Lat_line); #convert the lat/long arcdeg to the current map coordinates
                            imDayNite_nite = ax.plot(dayNite_latLongMapped[0],dayNite_latLongMapped[1],color='b',linewidth=1.75,zorder=6); #plots a line to show the sunset time
                            if( gif_dayNiteText == 1 ):
                                dayNite_latLongMapped = geoMap(dayNite_Long_text,dayNite_Lat_text); #convert the lat/long arcdeg to the current map coordinates
                                textDayNite_nite = ax.text(dayNite_latLongMapped[0], dayNite_latLongMapped[1], "Sunset", rotation=dayNite_textRotation, color='b', fontsize=FONT_axisTick, zorder=6);
                            #END IF
                        #END IF
                    #END IF
                    
                    #Now drawing line of interest
    #                imMillstone = ax.plot(Millstone_latLongMapped[0],Millstone_latLongMapped[1],marker=gif_Millstone_Marker, markerfacecolor=gif_Millstone_Marker_Color ,markersize=gif_Millstone_Marker_Size); #plot this
                #END IF
            
            
                #-----------------------Create Movie/GIF---------------------------
                #Makes the gif now
                plt.draw();
                
                gif_writer.grab_frame(); #get the frame and save it
                            
                #-------------------Clean up for re-use----------------------------
                #if forget one (like hOverlay) slows it way down after many plots
                imTEC.remove();
    #            imOverlay.pop(0).remove();
    #            imMillstone.pop(0).remove();
                if( gif_dayNiteLine == 1 ):
                    if(hLgd_FLG_day > 0): #only delete if it is there
                        imDayNite_day.pop(0).remove();
                        if( gif_dayNiteText == 1 ):
                            textDayNite_day.remove();
                        #END IF
                    #END IF
                    if(hLgd_FLG_nite > 0): #only delete if it is there
                        imDayNite_nite.pop(0).remove();
                        if( gif_dayNiteText == 1 ):
                            textDayNite_nite.remove();
                        #END IF
                    #END IF
                #END IF
                
            #END FOR i
        #END WITH
    elif(gif_Type == 2): #stationary data points (through averaging) + Zenith ISR overlay
        
        #-----------------------Clip Time to ISR Zenith------------------------
        gif_Zenith_time_start = np.where( np.min(np.abs(np.min(Zenith_time) - TEC_timeUnique)) == np.abs(np.min(Zenith_time) - TEC_timeUnique) )[0][0]; #match Zenith start time
        gif_Zenith_time_end = np.where( np.min(np.abs(np.max(Zenith_time) - TEC_timeUnique)) == np.abs(np.max(Zenith_time) - TEC_timeUnique) )[0][0]; #match Zenith end time
        
        with gif_writer.saving(fig, gif_Name, gif_PPI): #figure to save, file name, and PPI (DPI in documentation)
        
            #-------------------------Start Making Pictures------------------------
            for i in range(gif_Zenith_time_start,gif_Zenith_time_end+1):
        
                #----------------Corral the data to the right place----------------
                k =  np.where( data['TEC']['time'] == TEC_timeUnique[i])[0]; #gets during a time period
                vTEC_portion = data['TEC']['dTEC'][k]; #pull out the vTEC now
                pplat_portion = data['TEC']['lat'][k]; #get the pplat (pierce-point lat) at the time required
                pplong_portion = data['TEC']['long'][k]; #get the pplong (pierce-point long) at the time required
                            
                gif_Grid = GRITI_movieMaker_subfun_dataGridder(pplat_portion,pplong_portion,vTEC_portion,gif_Grid_Lat,gif_Grid_Long,gif_Grid_Lat_Spaces,gif_Grid_Long_Spaces,gif_Grid_Lat_Delta,gif_Grid_Long_Delta,dataRejectOrig,dataRejectLimitOrig,dataRejectMax);
                #call a numba'd function that makes the movie quicker by crunching the numbers gooder
                
                #----------------------------Tack on Title-------------------------
                string_title = 'TEC Global Plot, Time =  '+'{0:.2f}'.format(np.round((TEC_timeUnique[i]-dateRange_dayNum_zeroHr[1]*86400),2))+\
                    ', 0 UT on '+dateRange_zeroHr_monthName+' '+str(dateRange_zeroHr[2])+', '+str(dateRange_dayNum_zeroHr[0]); #create mecha title
                
                ax[0].set_title(string_title,fontproperties=FONT_titleFM); #set the title, properties always needed
                                
                #-------------------Starting the Plotting--------------------------
                if( i == gif_Zenith_time_start ): #first run preps axes, color bars, etc.
                                   
                    #tack on 2nd title that doesn't change
                    string_title = 'Zenith SNR '+str(filter_cutoffPeriod)+' Hr Highpass Filtered'; #create mecha title
                
                    ax[1].set_title(string_title,fontproperties=FONT_titleFM); #set the title
                    
                    #Do the TEC plotting
                    pltHelprX, pltHelprY = np.meshgrid( gif_Grid_Long, gif_Grid_Lat); #helps the pcolor work
                    TEC_latLongMapped = geoMap(pltHelprX,pltHelprY); #convert the lat/long arcdeg to the current map coordinates
                    imTEC = ax[0].pcolormesh(TEC_latLongMapped[0], TEC_latLongMapped[1],  gif_Grid.T ,vmin=-TEC_plotLimValu, vmax=TEC_plotLimValu,cmap='jet',zorder=5); # pseudocolor plot "stretched" to the grid
                    cbar = fig.colorbar(imTEC, cax=cax, orientation='vertical'); #create a colorbar using the prev. defined cax
                    cax.yaxis.set_ticks(np.linspace(-TEC_plotLimValu,TEC_plotLimValu,5)); #create useful tick marks
                    cax.yaxis.set_major_formatter(FormatStrFormatter('%.2f')); #force a rounded format
                    cbar.set_label("delta-vTEC [TECU]"); #tabel the colorbar
                    cbar.ax.tick_params(labelsize=FONT_axisTick);
                    cbar.mappable.set_clim(vmin=-TEC_plotLimValu, vmax=TEC_plotLimValu);
    
                    #Do the ISR plotting
                    pltHelprX, pltHelprY = np.meshgrid( (Zenith_time - dateRange_dayNum_zeroHr[1]*86400), Zenith_height);
                    imISR = ax[1].pcolormesh(pltHelprX , pltHelprY , Zenith_SNR_hp , vmin=-ISR_plotLimValu , vmax=ISR_plotLimValu , cmap='gray' , shading='gouraud', zorder = 1); # pseudocolor plot "stretched" to the grid
                    cbar2 = fig.colorbar(imISR, cax=cax2, orientation='vertical'); #create a colorbar using the prev. defined cax
                    cbar2.mappable.set_clim(vmin=-ISR_plotLimValu, vmax=ISR_plotLimValu);
    #                cbar2.ax.set_yticklabels(np.round(np.linspace(-ISR_plotLimValu,ISR_plotLimValu,5), len(str(ISR_plotLimValu).split('.')[1])+1 )); #create useful tick marks
                    cax2.yaxis.set_major_formatter(FormatStrFormatter('%.2f')); #force a rounded format
                    cbar2.set_label("SNR (unitless)"); #tabel the colorbar
                    cbar2.ax.tick_params(labelsize=FONT_axisTick);
                    cax2.yaxis.label.set_font_properties(FONT_axisLabelFM);
                    
                    ax[1].set_xlabel(subfun_monthNum_to_word(dateRange[0,1])[0]+" "+str(dateRange[0,2])+" (Day "+str(dateRange_dayNum[0,1])+"), "+str(dateRange[0,0])+" to "+subfun_monthNum_to_word(dateRange[1,1])[0]+" "+str(dateRange[1,2])+" (Day "+str(dateRange_dayNum[0,1])+"), "+str(dateRange[1,0]),fontproperties=FONT_axisLabelFM); #set the x axis label
                    ax[1].set_ylabel('Height (km)',fontproperties=FONT_axisLabelFM); #set the y axis label
                    
                    xAxisTicks = np.arange( (np.round((np.min(Zenith_time)-dateRange_dayNum_zeroHr[1]*86400)) - np.mod(np.round((np.min(Zenith_time)-dateRange_dayNum_zeroHr[1]*86400)),2)) , \
                            (np.round((np.max(Zenith_time)-dateRange_dayNum_zeroHr[1]*86400)) - np.mod(np.round((np.max(Zenith_time)-dateRange_dayNum_zeroHr[1]*86400)),2)) + 2 , \
                            2); #sets the start hr, stop hr, and the step size between (in this case, 2 hr)
                    ax[1].set_xticks(xAxisTicks); #set x axis ticks
                    ax[1].set_xlim( ((np.min(Zenith_time)-dateRange_dayNum_zeroHr[1]*86400) , (np.max(Zenith_time)-dateRange_dayNum_zeroHr[1]*86400)) ); #set x axis limits
                    
                    ax[1].set_ylim( ISR_RTI_heightLimValues ); #set y axis limits
                    
                    #Draw time line on bottom ISR plot
                    imISRLine = ax[1].plot( np.array(( (TEC_timeUnique[i]-dateRange_dayNum_zeroHr[1]*86400) , (TEC_timeUnique[i]-dateRange_dayNum_zeroHr[1]*86400) )) , np.array(( np.min(ISR_RTI_heightLimValues),np.max(ISR_RTI_heightLimValues))) , color=gif_Millstone_Marker_Color , zorder = 10);
                    
                    if( gif_dayNiteLine == 1 ):
                        fig.canvas.flush_events(); #this is req. to get get_window_extent() to get the current window size
                        #Plot the sunrise/sunset terminators
                        dayNite_temp = np.abs(dayNite_sunrise - (TEC_timeUnique[i]-dateRange_dayNum_zeroHr[1]*86400)) <= 10/3600; #gets the sunrise locations that are within 10 sec of the current TEC time (2 min had way too many hits, zigzags)
                        hLgd_FLG_day = np.sum(dayNite_temp); #plotting flag, shows when legend is active
                        #constants will use all the time - only for plotting of day/nite line so minor importance
                        bbox = ax[0].get_window_extent().transformed(fig.dpi_scale_trans.inverted()); #get the plot dimensions
                        plot_ratio = bbox.width/bbox.height; #get the plot ratio, will use it to fix up the angle
                        dayNite_textRotationLenOrig = 35; #length to go up and down the sunrise/sunset line to estimate an angle
                        dayNite_savgolFiltLenOrig = 101; #set it as a constant to start off
                        dayNite_textLatAbs = (np.max(plotLatRange)-np.min(plotLatRange))*.9 + np.min(plotLatRange); #calc like 80% of the max latitude
                        if( hLgd_FLG_day > 0 ): #only do work if it is there
                            #calc all that day/nite stuff in one function to keep it from getting cluttered
                            dayNite_Lat_line, dayNite_Long_line, dayNite_Lat_text, dayNite_Long_text, dayNite_textRotation = GRITI_movieMaker_subfun_dayniteCalc(0,np.sum(dayNite_temp),dayNite_Grid_Long[dayNite_temp],dayNite_Grid_Lat[dayNite_temp],dayNite_textLatAbs,plot_ratio,dayNite_savgolFiltLenOrig,dayNite_textRotationLenOrig);
                            dayNite_latLongMapped = geoMap(dayNite_Long_line,dayNite_Lat_line); #convert the lat/long arcdeg to the current map coordinates
                            imDayNite_day = ax[0].plot(dayNite_latLongMapped[0],dayNite_latLongMapped[1],color='g',linewidth=1.75,zorder=6); #plots a line to show the sunrise time
                            if( gif_dayNiteText == 1 ):
                                dayNite_latLongMapped = geoMap(dayNite_Long_text,dayNite_Lat_text); #convert the lat/long arcdeg to the current map coordinates
                                textDayNite_day = ax[0].text(dayNite_latLongMapped[0], dayNite_latLongMapped[1], "Sunrise", rotation=dayNite_textRotation, color='g', fontsize=FONT_axisTick, zorder=6);
                            #END IF
                        #END IF
                        
                        dayNite_temp = np.abs(dayNite_sunset - (TEC_timeUnique[i]-dateRange_dayNum_zeroHr[1]*86400)) <= 10/3600; #gets the sunset locations that are within 10 sec of the current TEC time (2 min had way too many hits, zigzags)
                        hLgd_FLG_nite = np.sum(dayNite_temp); #plotting flag, shows when legend is active
                        if( hLgd_FLG_nite > 0 ): #only do work if it is there
                            #calc all that day/nite stuff in one function to keep it from getting cluttered
                            dayNite_Lat_line, dayNite_Long_line, dayNite_Lat_text, dayNite_Long_text, dayNite_textRotation = GRITI_movieMaker_subfun_dayniteCalc(1,np.sum(dayNite_temp),dayNite_Grid_Long[dayNite_temp],dayNite_Grid_Lat[dayNite_temp],dayNite_textLatAbs,plot_ratio,dayNite_savgolFiltLenOrig,dayNite_textRotationLenOrig);
                            dayNite_latLongMapped = geoMap(dayNite_Long_line,dayNite_Lat_line); #convert the lat/long arcdeg to the current map coordinates
                            imDayNite_nite = ax[0].plot(dayNite_latLongMapped[0],dayNite_latLongMapped[1],color='b',linewidth=1.75,zorder=6); #plots a line to show the sunset time
                            if( gif_dayNiteText == 1 ):
                                dayNite_latLongMapped = geoMap(dayNite_Long_text,dayNite_Lat_text); #convert the lat/long arcdeg to the current map coordinates
                                textDayNite_nite = ax[0].text(dayNite_latLongMapped[0], dayNite_latLongMapped[1], "Sunset", rotation=dayNite_textRotation, color='b', fontsize=FONT_axisTick, zorder=6);
                            #EMD IF
                        #END IF
                    #END IF
                    
                    #Now drawing line of interest               
                    Millstone_latLongMapped = geoMap(longMillstone,latMillstone); #convert the lat/long arcdeg to the current map coordinates
                    imMillstone = ax[0].plot(Millstone_latLongMapped[0],Millstone_latLongMapped[1],marker=gif_Millstone_Marker, color=gif_Millstone_Marker_Color, markersize=gif_Millstone_Marker_Size, zorder=50); #plot this, 50 always on top
                                    
                else:
                    #Just plotting now - prep done, hopefully speeds it!
                    #Do the TEC plotting
                    pltHelprX, pltHelprY = np.meshgrid( gif_Grid_Long, gif_Grid_Lat); #helps the pcolor work
                    TEC_latLongMapped = geoMap(pltHelprX,pltHelprY); #convert the lat/long arcdeg to the current map coordinates
                    imTEC = ax[0].pcolormesh(TEC_latLongMapped[0], TEC_latLongMapped[1],  gif_Grid.T ,vmin=-TEC_plotLimValu, vmax=TEC_plotLimValu,cmap='jet',zorder=5); # pseudocolor plot "stretched" to the grid
    
                    #Draw time line on bottom ISR plot
                    imISRLine = ax[1].plot( np.array(( (TEC_timeUnique[i]-dateRange_dayNum_zeroHr[1]*86400) , (TEC_timeUnique[i]-dateRange_dayNum_zeroHr[1]*86400) )) , np.array(( np.min(ISR_RTI_heightLimValues),np.max(ISR_RTI_heightLimValues))) , color=gif_Millstone_Marker_Color , zorder = 10);
                    
                    if( gif_dayNiteLine == 1 ):
                        #Plot the sunrise/sunset terminators
                        dayNite_temp = np.abs(dayNite_sunrise - (TEC_timeUnique[i]-dateRange_dayNum_zeroHr[1]*86400)) <= 10/3600; #gets the sunrise locations that are within 10 sec of the current TEC time (2 min had way too many hits, zigzags)
                        hLgd_FLG_day = np.sum(dayNite_temp); #plotting flag, shows when legend is active
                        if( hLgd_FLG_day > 0 ): #only do work if it is there
                            #calc all that day/nite stuff in one function to keep it from getting cluttered
                            dayNite_Lat_line, dayNite_Long_line, dayNite_Lat_text, dayNite_Long_text, dayNite_textRotation = GRITI_movieMaker_subfun_dayniteCalc(0,np.sum(dayNite_temp),dayNite_Grid_Long[dayNite_temp],dayNite_Grid_Lat[dayNite_temp],dayNite_textLatAbs,plot_ratio,dayNite_savgolFiltLenOrig,dayNite_textRotationLenOrig);
                            dayNite_latLongMapped = geoMap(dayNite_Long_line,dayNite_Lat_line); #convert the lat/long arcdeg to the current map coordinates
                            imDayNite_day = ax[0].plot(dayNite_latLongMapped[0],dayNite_latLongMapped[1],color='g',linewidth=1.75,zorder=6); #plots a line to show the sunrise time
                            if( gif_dayNiteText == 1 ):
                                dayNite_latLongMapped = geoMap(dayNite_Long_text,dayNite_Lat_text); #convert the lat/long arcdeg to the current map coordinates
                                textDayNite_day = ax[0].text(dayNite_latLongMapped[0], dayNite_latLongMapped[1], "Sunrise", rotation=dayNite_textRotation, color='g', fontsize=FONT_axisTick, zorder=6);
                            #END IF
                        #END IF
                        
                        dayNite_temp = np.abs(dayNite_sunset - (TEC_timeUnique[i]-dateRange_dayNum_zeroHr[1]*86400)) <= 10/3600; #gets the sunset locations that are within 10 sec of the current TEC time (2 min had way too many hits, zigzags)
                        hLgd_FLG_nite = np.sum(dayNite_temp); #plotting flag, shows when legend is active
                        if( hLgd_FLG_nite > 0 ): #only do work if it is there
                            #calc all that day/nite stuff in one function to keep it from getting cluttered
                            dayNite_Lat_line, dayNite_Long_line, dayNite_Lat_text, dayNite_Long_text, dayNite_textRotation = GRITI_movieMaker_subfun_dayniteCalc(1,np.sum(dayNite_temp),dayNite_Grid_Long[dayNite_temp],dayNite_Grid_Lat[dayNite_temp],dayNite_textLatAbs,plot_ratio,dayNite_savgolFiltLenOrig,dayNite_textRotationLenOrig);
                            dayNite_latLongMapped = geoMap(dayNite_Long_line,dayNite_Lat_line); #convert the lat/long arcdeg to the current map coordinates
                            imDayNite_nite = ax[0].plot(dayNite_latLongMapped[0],dayNite_latLongMapped[1],color='b',linewidth=1.75,zorder=6); #plots a line to show the sunset time
                            if( gif_dayNiteText == 1 ):
                                dayNite_latLongMapped = geoMap(dayNite_Long_text,dayNite_Lat_text); #convert the lat/long arcdeg to the current map coordinates
                                textDayNite_nite = ax[0].text(dayNite_latLongMapped[0], dayNite_latLongMapped[1], "Sunset", rotation=dayNite_textRotation, color='b', fontsize=FONT_axisTick, zorder=6);
                            #END IF
                        #END IF
                    #END IF
                    
                #END IF
            
                #-----------------------Create Movie/GIF---------------------------
                #Makes the gif now
                plt.draw();
                
                gif_writer.grab_frame(); #get the frame and save it
                            
                #-------------------Clean up for re-use----------------------------
                #if forget one (like hOverlay) slows it way down after many plots
                imTEC.remove();
                imISRLine.pop(0).remove();
    #            imOverlay.pop(0).remove();
    #            imMillstone.pop(0).remove();
                if( gif_dayNiteLine == 1 ):
                    if(hLgd_FLG_day > 0): #only delete if it is there
                        imDayNite_day.pop(0).remove();
                        if( gif_dayNiteText == 1 ):
                            textDayNite_day.remove();
                        #END IF
                    #END IF
                    if(hLgd_FLG_nite > 0): #only delete if it is there
                        imDayNite_nite.pop(0).remove();
                        if( gif_dayNiteText == 1 ):
                            textDayNite_nite.remove();
                        #END IF
                    #END IF
                #END IF
                
            #END FOR i
        #END WITH
        
    elif(gif_Type == 3): #stationary data points (through averaging) + MISA ISR overlay
        
        #-----------------------Clip Time to ISR MISA------------------------
        gif_MISA_time_start = np.where( np.min(np.abs(np.min(MISA_time) - TEC_timeUnique)) == np.abs(np.min(MISA_time) - TEC_timeUnique) )[0][0]; #match MISA start time
        gif_MISA_time_end = np.where( np.min(np.abs(np.max(MISA_time) - TEC_timeUnique)) == np.abs(np.max(MISA_time) - TEC_timeUnique) )[0][0]; #match MISA end time
        
        with gif_writer.saving(fig, gif_Name, gif_PPI): #figure to save, file name, and PPI (DPI in documentation)
        
            #-------------------------Start Making Pictures------------------------
            for i in range(gif_MISA_time_start,gif_MISA_time_end+1):
        
                #----------------Corral the data to the right place----------------
                k =  np.where( data['TEC']['time'] == TEC_timeUnique[i])[0]; #gets during a time period
                vTEC_portion = data['TEC']['dTEC'][k]; #pull out the vTEC now
                pplat_portion = data['TEC']['lat'][k]; #get the pplat (pierce-point lat) at the time required
                pplong_portion = data['TEC']['long'][k]; #get the pplong (pierce-point long) at the time required
                            
                gif_Grid = GRITI_movieMaker_subfun_dataGridder(pplat_portion,pplong_portion,vTEC_portion,gif_Grid_Lat,gif_Grid_Long,gif_Grid_Lat_Spaces,gif_Grid_Long_Spaces,gif_Grid_Lat_Delta,gif_Grid_Long_Delta,dataRejectOrig,dataRejectLimitOrig,dataRejectMax);
                #call a numba'd function that makes the movie quicker by crunching the numbers gooder
                
                #----------------------------Tack on Title-------------------------
                string_title = 'TEC Global Plot, Time =  '+'{0:.2f}'.format(np.round((TEC_timeUnique[i]-dateRange_dayNum_zeroHr[1]*86400),2))+\
                    ', 0 UT on '+dateRange_zeroHr_monthName+' '+str(dateRange_zeroHr[2])+', '+str(dateRange_dayNum_zeroHr[0]); #create mecha title
                
                ax[0].set_title(string_title,fontproperties=FONT_titleFM); #set the title, properties always needed
                                
                #-------------------Starting the Plotting--------------------------
                if( i == gif_MISA_time_start ): #first run preps axes, color bars, etc.
                                   
                    #tack on 2nd title that doesn't change
                    string_title = 'MISA SNR '+str(filter_cutoffPeriod)+' Hr Highpass Filtered'; #create mecha title
                
                    ax[1].set_title(string_title,fontproperties=FONT_titleFM); #set the title
                    
                    #Do the TEC plotting
                    pltHelprX, pltHelprY = np.meshgrid( gif_Grid_Long, gif_Grid_Lat); #helps the pcolor work
                    TEC_latLongMapped = geoMap(pltHelprX,pltHelprY); #convert the lat/long arcdeg to the current map coordinates
                    imTEC = ax[0].pcolormesh(TEC_latLongMapped[0], TEC_latLongMapped[1],  gif_Grid.T ,vmin=-TEC_plotLimValu, vmax=TEC_plotLimValu,cmap='jet',zorder=5); # pseudocolor plot "stretched" to the grid
                    cbar = fig.colorbar(imTEC, cax=cax, orientation='vertical'); #create a colorbar using the prev. defined cax
                    cax.yaxis.set_ticks(np.linspace(-TEC_plotLimValu,TEC_plotLimValu,5)); #create useful tick marks
                    cax.yaxis.set_major_formatter(FormatStrFormatter('%.2f')); #force a rounded format
                    cbar.set_label("delta-vTEC [TECU]"); #tabel the colorbar
                    cbar.ax.tick_params(labelsize=FONT_axisTick);
                    cbar.mappable.set_clim(vmin=-TEC_plotLimValu, vmax=TEC_plotLimValu);
    
                    #Do the ISR plotting
                    pltHelprX, pltHelprY = np.meshgrid( (MISA_time - dateRange_dayNum_zeroHr[1]*86400), MISA_height);
                    imISR = ax[1].pcolormesh(pltHelprX , pltHelprY , MISA_SNR_hp , vmin=-ISR_plotLimValu , vmax=ISR_plotLimValu , cmap='gray' , shading='gouraud', zorder = 1); # pseudocolor plot "stretched" to the grid
                    cbar2 = fig.colorbar(imISR, cax=cax2, orientation='vertical'); #create a colorbar using the prev. defined cax
                    cbar2.mappable.set_clim(vmin=-ISR_plotLimValu, vmax=ISR_plotLimValu);
    #                cbar2.ax.set_yticklabels(np.round(np.linspace(-ISR_plotLimValu,ISR_plotLimValu,5), len(str(ISR_plotLimValu).split('.')[1])+1 )); #create useful tick marks
                    cax2.yaxis.set_major_formatter(FormatStrFormatter('%.2f')); #force a rounded format
                    cbar2.set_label("SNR (unitless)"); #tabel the colorbar
                    cbar2.ax.tick_params(labelsize=FONT_axisTick);
                    cax2.yaxis.label.set_font_properties(FONT_axisLabelFM);
                    
                    ax[1].set_xlabel(subfun_monthNum_to_word(dateRange[0,1])[0]+" "+str(dateRange[0,2])+" (Day "+str(dateRange_dayNum[0,1])+"), "+str(dateRange[0,0])+" to "+subfun_monthNum_to_word(dateRange[1,1])[0]+" "+str(dateRange[1,2])+" (Day "+str(dateRange_dayNum[0,1])+"), "+str(dateRange[1,0]),fontproperties=FONT_axisLabelFM); #set the x axis label
                    ax[1].set_ylabel('Height (km)',fontproperties=FONT_axisLabelFM); #set the y axis label
                    
                    xAxisTicks = np.arange( (np.round((np.min(MISA_time)-dateRange_dayNum_zeroHr[1]*86400)) - np.mod(np.round((np.min(MISA_time)-dateRange_dayNum_zeroHr[1]*86400)),2)) , \
                            (np.round((np.max(MISA_time)-dateRange_dayNum_zeroHr[1]*86400)) - np.mod(np.round((np.max(MISA_time)-dateRange_dayNum_zeroHr[1]*86400)),2)) + 2 , \
                            2); #sets the start hr, stop hr, and the step size between (in this case, 2 hr)
                    ax[1].set_xticks(xAxisTicks); #set x axis ticks
                    ax[1].set_xlim( ((np.min(MISA_time)-dateRange_dayNum_zeroHr[1]*86400) , (np.max(MISA_time)-dateRange_dayNum_zeroHr[1]*86400)) ); #set x axis limits
                    
                    ax[1].set_ylim( ISR_RTI_heightLimValues ); #set y axis limits
                    
                    #Draw time line on bottom ISR plot
                    imISRLine = ax[1].plot( np.array(( (TEC_timeUnique[i]-dateRange_dayNum_zeroHr[1]*86400) , (TEC_timeUnique[i]-dateRange_dayNum_zeroHr[1]*86400) )) , np.array(( np.min(ISR_RTI_heightLimValues),np.max(ISR_RTI_heightLimValues))) , color=gif_Millstone_Marker_Color , zorder = 10);
                    
                    if( gif_dayNiteLine == 1 ):
                        fig.canvas.flush_events(); #this is req. to get get_window_extent() to get the current window size
                        #Plot the sunrise/sunset terminators
                        dayNite_temp = np.abs(dayNite_sunrise - (TEC_timeUnique[i]-dateRange_dayNum_zeroHr[1]*86400)) <= 10/3600; #gets the sunrise locations that are within 10 sec of the current TEC time (2 min had way too many hits, zigzags)
                        hLgd_FLG_day = np.sum(dayNite_temp); #plotting flag, shows when legend is active
                        #constants will use all the time - only for plotting of day/nite line so minor importance
                        bbox = ax[0].get_window_extent().transformed(fig.dpi_scale_trans.inverted()); #get the plot dimensions
                        plot_ratio = bbox.width/bbox.height; #get the plot ratio, will use it to fix up the angle
                        dayNite_textRotationLenOrig = 35; #length to go up and down the sunrise/sunset line to estimate an angle
                        dayNite_savgolFiltLenOrig = 101; #set it as a constant to start off
                        dayNite_textLatAbs = (np.max(plotLatRange)-np.min(plotLatRange))*.9 + np.min(plotLatRange); #calc like 80% of the max latitude
                        if( hLgd_FLG_day > 0 ): #only do work if it is there
                            #calc all that day/nite stuff in one function to keep it from getting cluttered
                            dayNite_Lat_line, dayNite_Long_line, dayNite_Lat_text, dayNite_Long_text, dayNite_textRotation = GRITI_movieMaker_subfun_dayniteCalc(0,np.sum(dayNite_temp),dayNite_Grid_Long[dayNite_temp],dayNite_Grid_Lat[dayNite_temp],dayNite_textLatAbs,plot_ratio,dayNite_savgolFiltLenOrig,dayNite_textRotationLenOrig);
                            dayNite_latLongMapped = geoMap(dayNite_Long_line,dayNite_Lat_line); #convert the lat/long arcdeg to the current map coordinates
                            imDayNite_day = ax[0].plot(dayNite_latLongMapped[0],dayNite_latLongMapped[1],color='g',linewidth=1.75,zorder=6); #plots a line to show the sunrise time
                            if( gif_dayNiteText == 1 ):
                                dayNite_latLongMapped = geoMap(dayNite_Long_text,dayNite_Lat_text); #convert the lat/long arcdeg to the current map coordinates
                                textDayNite_day = ax[0].text(dayNite_latLongMapped[0], dayNite_latLongMapped[1], "Sunrise", rotation=dayNite_textRotation, color='g', fontsize=FONT_axisTick, zorder=6);
                            #END IF
                        #END IF
                        
                        dayNite_temp = np.abs(dayNite_sunset - (TEC_timeUnique[i]-dateRange_dayNum_zeroHr[1]*86400)) <= 10/3600; #gets the sunset locations that are within 10 sec of the current TEC time (2 min had way too many hits, zigzags)
                        hLgd_FLG_nite = np.sum(dayNite_temp); #plotting flag, shows when legend is active
                        if( hLgd_FLG_nite > 0 ): #only do work if it is there
                            #calc all that day/nite stuff in one function to keep it from getting cluttered
                            dayNite_Lat_line, dayNite_Long_line, dayNite_Lat_text, dayNite_Long_text, dayNite_textRotation = GRITI_movieMaker_subfun_dayniteCalc(1,np.sum(dayNite_temp),dayNite_Grid_Long[dayNite_temp],dayNite_Grid_Lat[dayNite_temp],dayNite_textLatAbs,plot_ratio,dayNite_savgolFiltLenOrig,dayNite_textRotationLenOrig);
                            dayNite_latLongMapped = geoMap(dayNite_Long_line,dayNite_Lat_line); #convert the lat/long arcdeg to the current map coordinates
                            imDayNite_nite = ax[0].plot(dayNite_latLongMapped[0],dayNite_latLongMapped[1],color='b',linewidth=1.75,zorder=6); #plots a line to show the sunset time
                            if( gif_dayNiteText == 1 ):
                                dayNite_latLongMapped = geoMap(dayNite_Long_text,dayNite_Lat_text); #convert the lat/long arcdeg to the current map coordinates
                                textDayNite_nite = ax[0].text(dayNite_latLongMapped[0], dayNite_latLongMapped[1], "Sunset", rotation=dayNite_textRotation, color='b', fontsize=FONT_axisTick, zorder=6);
                            #EMD IF
                        #END IF
                    #END IF
                    
                    #Now drawing line of interest               
                    Millstone_latLongMapped = geoMap(longMillstone,latMillstone); #convert the lat/long arcdeg to the current map coordinates
                    imMillstone = ax[0].plot(Millstone_latLongMapped[0],Millstone_latLongMapped[1],marker=gif_Millstone_Marker, color=gif_Millstone_Marker_Color, markersize=gif_Millstone_Marker_Size, zorder=50); #plot this, 50 always on top
                                    
                else:
                    #Just plotting now - prep done, hopefully speeds it!
                    #Do the TEC plotting
                    pltHelprX, pltHelprY = np.meshgrid( gif_Grid_Long, gif_Grid_Lat); #helps the pcolor work
                    TEC_latLongMapped = geoMap(pltHelprX,pltHelprY); #convert the lat/long arcdeg to the current map coordinates
                    imTEC = ax[0].pcolormesh(TEC_latLongMapped[0], TEC_latLongMapped[1],  gif_Grid.T ,vmin=-TEC_plotLimValu, vmax=TEC_plotLimValu,cmap='jet',zorder=5); # pseudocolor plot "stretched" to the grid
    
                    #Draw time line on bottom ISR plot
                    imISRLine = ax[1].plot( np.array(( (TEC_timeUnique[i]-dateRange_dayNum_zeroHr[1]*86400) , (TEC_timeUnique[i]-dateRange_dayNum_zeroHr[1]*86400) )) , np.array(( np.min(ISR_RTI_heightLimValues),np.max(ISR_RTI_heightLimValues))) , color=gif_Millstone_Marker_Color , zorder = 10);
                    
                    if( gif_dayNiteLine == 1 ):
                        #Plot the sunrise/sunset terminators
                        dayNite_temp = np.abs(dayNite_sunrise - (TEC_timeUnique[i]-dateRange_dayNum_zeroHr[1]*86400)) <= 10/3600; #gets the sunrise locations that are within 10 sec of the current TEC time (2 min had way too many hits, zigzags)
                        hLgd_FLG_day = np.sum(dayNite_temp); #plotting flag, shows when legend is active
                        if( hLgd_FLG_day > 0 ): #only do work if it is there
                            #calc all that day/nite stuff in one function to keep it from getting cluttered
                            dayNite_Lat_line, dayNite_Long_line, dayNite_Lat_text, dayNite_Long_text, dayNite_textRotation = GRITI_movieMaker_subfun_dayniteCalc(0,np.sum(dayNite_temp),dayNite_Grid_Long[dayNite_temp],dayNite_Grid_Lat[dayNite_temp],dayNite_textLatAbs,plot_ratio,dayNite_savgolFiltLenOrig,dayNite_textRotationLenOrig);
                            dayNite_latLongMapped = geoMap(dayNite_Long_line,dayNite_Lat_line); #convert the lat/long arcdeg to the current map coordinates
                            imDayNite_day = ax[0].plot(dayNite_latLongMapped[0],dayNite_latLongMapped[1],color='g',linewidth=1.75,zorder=6); #plots a line to show the sunrise time
                            if( gif_dayNiteText == 1 ):
                                dayNite_latLongMapped = geoMap(dayNite_Long_text,dayNite_Lat_text); #convert the lat/long arcdeg to the current map coordinates
                                textDayNite_day = ax[0].text(dayNite_latLongMapped[0], dayNite_latLongMapped[1], "Sunrise", rotation=dayNite_textRotation, color='g', fontsize=FONT_axisTick, zorder=6);
                            #END IF
                        #END IF
                        
                        dayNite_temp = np.abs(dayNite_sunset - (TEC_timeUnique[i]-dateRange_dayNum_zeroHr[1]*86400)) <= 10/3600; #gets the sunset locations that are within 10 sec of the current TEC time (2 min had way too many hits, zigzags)
                        hLgd_FLG_nite = np.sum(dayNite_temp); #plotting flag, shows when legend is active
                        if( hLgd_FLG_nite > 0 ): #only do work if it is there
                            #calc all that day/nite stuff in one function to keep it from getting cluttered
                            dayNite_Lat_line, dayNite_Long_line, dayNite_Lat_text, dayNite_Long_text, dayNite_textRotation = GRITI_movieMaker_subfun_dayniteCalc(1,np.sum(dayNite_temp),dayNite_Grid_Long[dayNite_temp],dayNite_Grid_Lat[dayNite_temp],dayNite_textLatAbs,plot_ratio,dayNite_savgolFiltLenOrig,dayNite_textRotationLenOrig);
                            dayNite_latLongMapped = geoMap(dayNite_Long_line,dayNite_Lat_line); #convert the lat/long arcdeg to the current map coordinates
                            imDayNite_nite = ax[0].plot(dayNite_latLongMapped[0],dayNite_latLongMapped[1],color='b',linewidth=1.75,zorder=6); #plots a line to show the sunset time
                            if( gif_dayNiteText == 1 ):
                                dayNite_latLongMapped = geoMap(dayNite_Long_text,dayNite_Lat_text); #convert the lat/long arcdeg to the current map coordinates
                                textDayNite_nite = ax[0].text(dayNite_latLongMapped[0], dayNite_latLongMapped[1], "Sunset", rotation=dayNite_textRotation, color='b', fontsize=FONT_axisTick, zorder=6);
                            #END IF
                        #END IF
                    #END IF
                    
                #END IF
            
                #-----------------------Create Movie/GIF---------------------------
                #Makes the gif now
                plt.draw();
                
                gif_writer.grab_frame(); #get the frame and save it
                            
                #-------------------Clean up for re-use----------------------------
                #if forget one (like hOverlay) slows it way down after many plots
                imTEC.remove();
                imISRLine.pop(0).remove();
    #            imOverlay.pop(0).remove();
    #            imMillstone.pop(0).remove();
                if( gif_dayNiteLine == 1 ):
                    if(hLgd_FLG_day > 0): #only delete if it is there
                        imDayNite_day.pop(0).remove();
                        if( gif_dayNiteText == 1 ):
                            textDayNite_day.remove();
                        #END IF
                    #END IF
                    if(hLgd_FLG_nite > 0): #only delete if it is there
                        imDayNite_nite.pop(0).remove();
                        if( gif_dayNiteText == 1 ):
                            textDayNite_nite.remove();
                        #END IF
                    #END IF
                #END IF
                
            #END FOR i
        #END WITH
        
    elif(gif_Type == 4): #stationary data points + AMPERE data on same plot with time average to AMPERE data (every 10 min)
        
        #---------------Prep for Averaging & Frame Multiplying-----------------
        gif_TimeAvg = np.int64(np.round(np.mean(np.diff(AMPERE_timeUnique))*24*60)); #min, force AVG to match the AMPERE time step (only for reporting at this point)
        
        timeUnique_TimeAvg = AMPERE_timeUnique; #hr, set up the time steps to be exactly what the AMPERE data time steps are
        if( timeUnique_TimeAvg[-1] < TEC_timeUnique[-1] ):
            timeUnique_TimeAvg = np.hstack( (timeUnique_TimeAvg,np.max(TEC_timeUnique)) ); #hr, force last time range to be added if it didn't fit in well
        #END IF
        #makes coding easier
        
        #Stuff for repeating a frame - needed if want a constant 30 FPS
        #This needs to go in gif_Type == 2 area
        gif_DesiredTotalTime = (timeUnique_TimeAvg.size-1)/gif_DesiredFPS; #s, total time from desired FPS
        gif_DesiredReqFrameNum = gif_DesiredTotalTime*30; #frames, number of frames needed to go for the time wanted
        gif_RepeatFrame = gif_DesiredReqFrameNum/(timeUnique_TimeAvg.size-1); #number of frames to repeat every time (exact w/ decimal)
        if( gif_RepeatFrame > 0.5 ):
            gif_RepeatFrame = np.int64(np.round(gif_RepeatFrame)); #round it
        else: #if less than 0.5 will round to 0 - so checking to see if there's a ton of frames and need to just boost it to 60 to keep run time in check
            if( ( (timeUnique_TimeAvg.size-1)/30 > gif_DesiredMaxRunTime ) & ( gif_FLGdisableFPSShift == 0 ) ): #try to keep run time down
                gif_vidFrameRate = 60; #set the FPS to 60
            #END IF
            gif_RepeatFrame = 1; #I guess to make sure it works
        #EMD IF
        
        with gif_writer.saving(fig, gif_Name, gif_PPI): #figure to save, file name, and PPI (DPI in documentation)
        
            #-------------------------Start Making Pictures------------------------
            for i in range(0,timeUnique_TimeAvg.size-1):
                
                #------------Corral the AMPERE data to the right place-------------
                k = np.where(data['AMPERE']['time'] == timeUnique_TimeAvg[i])[0]; #get where the time point is
                AMPERE_jouleHeating_portion = AMPERE_data[k,locAMPERE_jouleHeating]; #ergs/(cm^2*sec), get the Joule Heating for the current time step
                AMPERE_lat_portion = AMPERE_data[k,locAMPERE_lat]; #degc, corresponding lat values
                AMPERE_long_portion = AMPERE_data[k,locAMPERE_long]; #degc, corresponding long values
                
                #----------------Corral the data to the right place----------------
                k = np.where( ( data['TEC']['time'] >= timeUnique_TimeAvg[i]) & ( data['TEC']['time'] < timeUnique_TimeAvg[i+1] ) )[0]; #get where time points fall within the averaging boundaries
                vTEC_portion = data['TEC']['dTEC'][k]; #pull out the vTEC now
                pplat_portion = data['TEC']['lat'][k]; #get the pplat (pierce-point lat) at the time required
                pplong_portion = data['TEC']['long'][k]; #get the pplong (pierce-point long) at the time required
                            
                gif_Grid = GRITI_movieMaker_subfun_dataGridder(pplat_portion,pplong_portion,vTEC_portion,gif_Grid_Lat,gif_Grid_Long,gif_Grid_Lat_Spaces,gif_Grid_Long_Spaces,gif_Grid_Lat_Delta,gif_Grid_Long_Delta,dataRejectOrig,dataRejectLimitOrig,dataRejectMax);
                #call a numba'd function that makes the movie quicker by crunching the numbers gooder
                
                #----------------------------Tack on Title-------------------------
                string_title = 'TEC Global Plot | AMPERE Time Avg\'d to Every '+str(gif_TimeAvg)+' Min | Time =  '+'{0:.2f}'.format(np.round((TEC_timeUnique[i]-dateRange_dayNum_zeroHr[1]*86400),2))+\
                    ', 0 UT on '+dateRange_zeroHr_monthName+' '+str(dateRange_zeroHr[2])+', '+str(dateRange_zeroHr[0]); #create mecha title
                
                ax.set_title(string_title,fontproperties=FONT_titleFM); #set the title, properties always needed
                    
                #-------------------Starting the Plotting--------------------------
                if( i == 0 ): #first run preps axes, color bars, etc.
                                   
                    #Do the TEC plotting
                    pltHelprX, pltHelprY = np.meshgrid( gif_Grid_Long, gif_Grid_Lat); #helps the pcolor work
                    TEC_latLongMapped = geoMap(pltHelprX,pltHelprY); #convert the lat/long arcdeg to the current map coordinates
                    imTEC = ax.pcolormesh(TEC_latLongMapped[0], TEC_latLongMapped[1],  gif_Grid.T ,vmin=-TEC_plotLimValu, vmax=TEC_plotLimValu,cmap='jet',zorder=5); # pseudocolor plot "stretched" to the grid
                    cbar = fig.colorbar(imTEC, cax=cax, orientation='vertical'); #create a colorbar using the prev. defined cax
                    cax.yaxis.set_ticks(np.linspace(-TEC_plotLimValu,TEC_plotLimValu,5)); #create useful tick marks
                    cax.yaxis.set_major_formatter(FormatStrFormatter('%.2f')); #force a rounded format
                    cbar.set_label("delta-vTEC [TECU]"); #tabel the colorbar
                    cbar.ax.tick_params(labelsize=FONT_axisTick);
                    cbar.mappable.set_clim(vmin=-TEC_plotLimValu, vmax=TEC_plotLimValu);
    
                    #Do the AMPERE plotting
                    AMPERE_colorMap = ListedColormap( np.hstack(( np.array( ( (np.linspace(1,0.492063492063492,128)),(np.linspace(1,0.507936507936508,128)),(np.linspace(1,1,128)) ) ) , np.array( ( (np.linspace(0.492063492063492,1,128)) , (np.linspace(0.507936507936508,0,128)) , (np.linspace(1,1,128)) ) ) )).T ); #white to purpleblue to pink (based off of 'cool')
                    AMPERE_latLongMapped = geoMap(AMPERE_long_portion,AMPERE_lat_portion); #convert the lat/long arcdeg to the current map coordinates
                    imAMP = ax.scatter(AMPERE_latLongMapped[0],AMPERE_latLongMapped[1],s=gif_Scatter_Point_Size_AMPERE,c=AMPERE_jouleHeating_portion,cmap=AMPERE_colorMap, vmin=np.min(AMPERE_plotLimValu), vmax=np.max(AMPERE_plotLimValu), zorder=7);
                    cbar2 = fig.colorbar(imAMP, cax=cax2, orientation='vertical'); #create a colorbar using the prev. defined cax
    #                cbar2.ax.set_yticklabels(np.linspace(np.min(AMPERE_plotLimValu),np.max(AMPERE_plotLimValu),5)); #create useful tick marks
                    cax2.yaxis.set_major_formatter(FormatStrFormatter('%.1f')); #force a rounded format
                    cax2.yaxis.set_ticks_position('left'); #move it to the left
                    cax2.yaxis.set_label_position('left'); #move it to the left
                    cbar2.set_label('AMPERE Joule Heating '+r'$(erg/cm^{2}sec)$'); #tabel the colorbar
                    cbar2.ax.tick_params(labelsize=FONT_axisTick);
                    cbar2.mappable.set_clim(vmin=np.min(AMPERE_plotLimValu), vmax=np.max(AMPERE_plotLimValu));
                                    
                    if( gif_dayNiteLine == 1 ):
                        fig.canvas.flush_events(); #this is req. to get get_window_extent() to get the current window size
                        #Plot the sunrise/sunset terminators
                        dayNite_temp = np.abs(dayNite_sunrise - (TEC_timeUnique[i]-dateRange_dayNum_zeroHr[1]*86400)) <= 10/3600; #gets the sunrise locations that are within 10 sec of the current TEC time (2 min had way too many hits, zigzags)
                        hLgd_FLG_day = np.sum(dayNite_temp); #plotting flag, shows when legend is active
                        #constants will use all the time - only for plotting of day/nite line so minor importance
                        bbox = ax.get_window_extent().transformed(fig.dpi_scale_trans.inverted()); #get the plot dimensions
                        plot_ratio = bbox.width/bbox.height; #get the plot ratio, will use it to fix up the angle
                        dayNite_textRotationLenOrig = 35; #length to go up and down the sunrise/sunset line to estimate an angle
                        dayNite_savgolFiltLenOrig = 101; #set it as a constant to start off
                        dayNite_textLatAbs = (np.max(plotLatRange)-np.min(plotLatRange))*.9 + np.min(plotLatRange); #calc like 80% of the max latitude
                        if( hLgd_FLG_day > 0 ): #only do work if it is there
                            #calc all that day/nite stuff in one function to keep it from getting cluttered
                            dayNite_Lat_line, dayNite_Long_line, dayNite_Lat_text, dayNite_Long_text, dayNite_textRotation = GRITI_movieMaker_subfun_dayniteCalc(0,np.sum(dayNite_temp),dayNite_Grid_Long[dayNite_temp],dayNite_Grid_Lat[dayNite_temp],dayNite_textLatAbs,plot_ratio,dayNite_savgolFiltLenOrig,dayNite_textRotationLenOrig);
                            dayNite_latLongMapped = geoMap(dayNite_Long_line,dayNite_Lat_line); #convert the lat/long arcdeg to the current map coordinates
                            imDayNite_day = ax.plot(dayNite_latLongMapped[0],dayNite_latLongMapped[1],color='g',linewidth=1.75,zorder=6); #plots a line to show the sunrise time
                            if( gif_dayNiteText == 1 ):
                                dayNite_latLongMapped = geoMap(dayNite_Long_text,dayNite_Lat_text); #convert the lat/long arcdeg to the current map coordinates
                                textDayNite_day = ax.text(dayNite_latLongMapped[0], dayNite_latLongMapped[1], "Sunrise", rotation=dayNite_textRotation, color='g', fontsize=FONT_axisTick, zorder=6);
                            #END IF
                        #END IF
                        
                        dayNite_temp = np.abs(dayNite_sunset - (TEC_timeUnique[i]-dateRange_dayNum_zeroHr[1]*86400)) <= 10/3600; #gets the sunset locations that are within 10 sec of the current TEC time (2 min had way too many hits, zigzags)
                        hLgd_FLG_nite = np.sum(dayNite_temp); #plotting flag, shows when legend is active
                        if( hLgd_FLG_nite > 0 ): #only do work if it is there
                            #calc all that day/nite stuff in one function to keep it from getting cluttered
                            dayNite_Lat_line, dayNite_Long_line, dayNite_Lat_text, dayNite_Long_text, dayNite_textRotation = GRITI_movieMaker_subfun_dayniteCalc(1,np.sum(dayNite_temp),dayNite_Grid_Long[dayNite_temp],dayNite_Grid_Lat[dayNite_temp],dayNite_textLatAbs,plot_ratio,dayNite_savgolFiltLenOrig,dayNite_textRotationLenOrig);
                            dayNite_latLongMapped = geoMap(dayNite_Long_line,dayNite_Lat_line); #convert the lat/long arcdeg to the current map coordinates
                            imDayNite_nite = ax.plot(dayNite_latLongMapped[0],dayNite_latLongMapped[1],color='b',linewidth=1.75,zorder=6); #plots a line to show the sunset time
                            if( gif_dayNiteText == 1 ):
                                dayNite_latLongMapped = geoMap(dayNite_Long_text,dayNite_Lat_text); #convert the lat/long arcdeg to the current map coordinates
                                textDayNite_nite = ax.text(dayNite_latLongMapped[0], dayNite_latLongMapped[1], "Sunset", rotation=dayNite_textRotation, color='b', fontsize=FONT_axisTick, zorder=6);
                            #EMD IF
                        #END IF
                    #END IF
                    
                    #Now drawing point of interest
                    Millstone_latLongMapped = geoMap(longMillstone,latMillstone); #convert the lat/long arcdeg to the current map coordinates
                    imMillstone = ax.plot(Millstone_latLongMapped[0],Millstone_latLongMapped[1],marker=gif_Millstone_Marker, color=gif_Millstone_Marker_Color, markersize=gif_Millstone_Marker_Size, zorder=50); #plot this, 50 always on top
                    
                else:
                    #Just plotting now - prep done, hopefully speeds it!
                    #Do the TEC plotting
                    pltHelprX, pltHelprY = np.meshgrid( gif_Grid_Long, gif_Grid_Lat); #helps the pcolor work
                    TEC_latLongMapped = geoMap(pltHelprX,pltHelprY); #convert the lat/long arcdeg to the current map coordinates
                    imTEC = ax.pcolormesh(TEC_latLongMapped[0], TEC_latLongMapped[1],  gif_Grid.T ,vmin=-TEC_plotLimValu, vmax=TEC_plotLimValu,cmap='jet',zorder=5); # pseudocolor plot "stretched" to the grid
    
                    #Do the AMPERE plotting
                    AMPERE_latLongMapped = geoMap(AMPERE_long_portion,AMPERE_lat_portion); #convert the lat/long arcdeg to the current map coordinates
                    imAMP = ax.scatter(AMPERE_latLongMapped[0],AMPERE_latLongMapped[1],s=gif_Scatter_Point_Size_AMPERE,c=AMPERE_jouleHeating_portion,cmap=AMPERE_colorMap, vmin=np.min(AMPERE_plotLimValu), vmax=np.max(AMPERE_plotLimValu), zorder=7);
                
                    if( gif_dayNiteLine == 1 ):
                        #Plot the sunrise/sunset terminators
                        dayNite_temp = np.abs(dayNite_sunrise - (TEC_timeUnique[i]-dateRange_dayNum_zeroHr[1]*86400)) <= 10/3600; #gets the sunrise locations that are within 10 sec of the current TEC time (2 min had way too many hits, zigzags)
                        hLgd_FLG_day = np.sum(dayNite_temp); #plotting flag, shows when legend is active
                        if( hLgd_FLG_day > 0 ): #only do work if it is there
                            #calc all that day/nite stuff in one function to keep it from getting cluttered
                            dayNite_Lat_line, dayNite_Long_line, dayNite_Lat_text, dayNite_Long_text, dayNite_textRotation = GRITI_movieMaker_subfun_dayniteCalc(0,np.sum(dayNite_temp),dayNite_Grid_Long[dayNite_temp],dayNite_Grid_Lat[dayNite_temp],dayNite_textLatAbs,plot_ratio,dayNite_savgolFiltLenOrig,dayNite_textRotationLenOrig);
                            dayNite_latLongMapped = geoMap(dayNite_Long_line,dayNite_Lat_line); #convert the lat/long arcdeg to the current map coordinates
                            imDayNite_day = ax.plot(dayNite_latLongMapped[0],dayNite_latLongMapped[1],color='g',linewidth=1.75,zorder=6); #plots a line to show the sunrise time
                            if( gif_dayNiteText == 1 ):
                                dayNite_latLongMapped = geoMap(dayNite_Long_text,dayNite_Lat_text); #convert the lat/long arcdeg to the current map coordinates
                                textDayNite_day = ax.text(dayNite_latLongMapped[0], dayNite_latLongMapped[1], "Sunrise", rotation=dayNite_textRotation, color='g', fontsize=FONT_axisTick, zorder=6);
                            #END IF
                        #END IF
                        
                        dayNite_temp = np.abs(dayNite_sunset - (TEC_timeUnique[i]-dateRange_dayNum_zeroHr[1]*86400)) <= 10/3600; #gets the sunset locations that are within 10 sec of the current TEC time (2 min had way too many hits, zigzags)
                        hLgd_FLG_nite = np.sum(dayNite_temp); #plotting flag, shows when legend is active
                        if( hLgd_FLG_nite > 0 ): #only do work if it is there
                            #calc all that day/nite stuff in one function to keep it from getting cluttered
                            dayNite_Lat_line, dayNite_Long_line, dayNite_Lat_text, dayNite_Long_text, dayNite_textRotation = GRITI_movieMaker_subfun_dayniteCalc(1,np.sum(dayNite_temp),dayNite_Grid_Long[dayNite_temp],dayNite_Grid_Lat[dayNite_temp],dayNite_textLatAbs,plot_ratio,dayNite_savgolFiltLenOrig,dayNite_textRotationLenOrig);
                            dayNite_latLongMapped = geoMap(dayNite_Long_line,dayNite_Lat_line); #convert the lat/long arcdeg to the current map coordinates
                            imDayNite_nite = ax.plot(dayNite_latLongMapped[0],dayNite_latLongMapped[1],color='b',linewidth=1.75,zorder=6); #plots a line to show the sunset time
                            if( gif_dayNiteText == 1 ):
                                dayNite_latLongMapped = geoMap(dayNite_Long_text,dayNite_Lat_text); #convert the lat/long arcdeg to the current map coordinates
                                textDayNite_nite = ax.text(dayNite_latLongMapped[0], dayNite_latLongMapped[1], "Sunset", rotation=dayNite_textRotation, color='b', fontsize=FONT_axisTick, zorder=6);
                            #END IF
                        #END IF
                    #END IF
                #END IF
            
            
                #-----------------------Create Movie/GIF---------------------------
                #Makes the gif now
                plt.draw();
                
                for j in range(0,gif_RepeatFrame): #runs this as many times as needed to get 30 FPS or whatever
                    gif_writer.grab_frame(); #get the frame and save it
                #END FOR j
                            
                #-------------------Clean up for re-use----------------------------
                #if forget one (like hOverlay) slows it way down after many plots
                imTEC.remove();
                imAMP.remove();
                if( gif_dayNiteLine == 1 ):
                    if(hLgd_FLG_day > 0): #only delete if it is there
                        imDayNite_day.pop(0).remove();
                        if( gif_dayNiteText == 1 ):
                            textDayNite_day.remove();
                        #END IF
                    #END IF
                    if(hLgd_FLG_nite > 0): #only delete if it is there
                        imDayNite_nite.pop(0).remove();
                        if( gif_dayNiteText == 1 ):
                            textDayNite_nite.remove();
                        #END IF
                    #END IF
                #END IF
            #END FOR i
        #END WITH
    
    elif(gif_Type == 5): #stationary data points + AMPERE data on same plot (no time average for TEC)
            
        AMPERE_dataRate = np.median(np.diff(AMPERE_timeUnique)); #days, get the median data rate for AMPERE data (avoids outliers)
        with gif_writer.saving(fig, gif_Name, gif_PPI): #figure to save, file name, and PPI (DPI in documentation)
                        
            #-------------------------Start Making Pictures------------------------
            for i in range(gif_timeRange[0],gif_timeRange[1]):
                
                #------------Corral the AMPERE data to the right place-------------
                k = np.where( (data['AMPERE']['time'] <= TEC_timeUnique[i]) & (data['AMPERE']['time'] >= (TEC_timeUnique[i]-AMPERE_dataRate)) )[0]; #get where the time point is, make sure it is within the data rate window
                AMPERE_jouleHeating_portion = AMPERE_data[k,locAMPERE_jouleHeating]; #ergs/(cm^2*sec), get the Joule Heating for the current time step
                AMPERE_lat_portion = AMPERE_data[k,locAMPERE_lat]; #degc, corresponding lat values
                AMPERE_long_portion = AMPERE_data[k,locAMPERE_long]; #degc, corresponding long values
                
                #----------------Corral the data to the right place----------------
                k =  np.where( data['TEC']['time'] == TEC_timeUnique[i])[0]; #gets during a time period
                vTEC_portion = data['TEC']['dTEC'][k]; #pull out the vTEC now
                pplat_portion = data['TEC']['lat'][k]; #get the pplat (pierce-point lat) at the time required
                pplong_portion = data['TEC']['long'][k]; #get the pplong (pierce-point long) at the time required
                            
                gif_Grid = GRITI_movieMaker_subfun_dataGridder(pplat_portion,pplong_portion,vTEC_portion,gif_Grid_Lat,gif_Grid_Long,gif_Grid_Lat_Spaces,gif_Grid_Long_Spaces,gif_Grid_Lat_Delta,gif_Grid_Long_Delta,dataRejectOrig,dataRejectLimitOrig,dataRejectMax);
                #call a numba'd function that makes the movie quicker by crunching the numbers gooder
                
                #----------------------------Tack on Title-------------------------
                string_title = 'TEC Global Plot | Time =  '+'{0:.2f}'.format(np.round((TEC_timeUnique[i]-dateRange_dayNum_zeroHr[1]*86400),2))+\
                    ', 0 UT on '+dateRange_zeroHr_monthName+' '+str(dateRange_zeroHr[2])+', '+str(dateRange_zeroHr[0]); #create mecha title
                
                ax.set_title(string_title,fontproperties=FONT_titleFM); #set the title, properties always needed
                    
                #-------------------Starting the Plotting--------------------------
                if( i == 0 ): #first run preps axes, color bars, etc.
                                   
                    #Do the TEC plotting
                    pltHelprX, pltHelprY = np.meshgrid( gif_Grid_Long, gif_Grid_Lat); #helps the pcolor work
                    TEC_latLongMapped = geoMap(pltHelprX,pltHelprY); #convert the lat/long arcdeg to the current map coordinates
                    imTEC = ax.pcolormesh(TEC_latLongMapped[0], TEC_latLongMapped[1],  gif_Grid.T ,vmin=-TEC_plotLimValu, vmax=TEC_plotLimValu,cmap='jet',zorder=5); # pseudocolor plot "stretched" to the grid
                    cbar = fig.colorbar(imTEC, cax=cax, orientation='vertical'); #create a colorbar using the prev. defined cax
                    cax.yaxis.set_ticks(np.linspace(-TEC_plotLimValu,TEC_plotLimValu,5)); #create useful tick marks
                    cax.yaxis.set_major_formatter(FormatStrFormatter('%.2f')); #force a rounded format
                    cbar.set_label("delta-vTEC [TECU]"); #tabel the colorbar
                    cbar.ax.tick_params(labelsize=FONT_axisTick);
                    cbar.mappable.set_clim(vmin=-TEC_plotLimValu, vmax=TEC_plotLimValu);
    
                    #Do the AMPERE plotting
                    AMPERE_colorMap = ListedColormap( np.hstack(( np.array( ( (np.linspace(1,0.492063492063492,128)),(np.linspace(1,0.507936507936508,128)),(np.linspace(1,1,128)) ) ) , np.array( ( (np.linspace(0.492063492063492,1,128)) , (np.linspace(0.507936507936508,0,128)) , (np.linspace(1,1,128)) ) ) )).T ); #white to purpleblue to pink (based off of 'cool')
                    AMPERE_latLongMapped = geoMap(AMPERE_long_portion,AMPERE_lat_portion); #convert the lat/long arcdeg to the current map coordinates
                    imAMP = ax.scatter(AMPERE_latLongMapped[0],AMPERE_latLongMapped[1],s=gif_Scatter_Point_Size_AMPERE,c=AMPERE_jouleHeating_portion,cmap=AMPERE_colorMap, vmin=np.min(AMPERE_plotLimValu), vmax=np.max(AMPERE_plotLimValu), zorder=7);
                    cbar2 = fig.colorbar(imAMP, cax=cax2, orientation='vertical'); #create a colorbar using the prev. defined cax
    #                cbar2.ax.set_yticklabels(np.linspace(np.min(AMPERE_plotLimValu),np.max(AMPERE_plotLimValu),5)); #create useful tick marks
                    cax2.yaxis.set_major_formatter(FormatStrFormatter('%.1f')); #force a rounded format
                    cax2.yaxis.set_ticks_position('left'); #move it to the left
                    cax2.yaxis.set_label_position('left'); #move it to the left
                    cbar2.set_label('AMPERE Joule Heating '+r'$(erg/cm^{2}sec)$'); #tabel the colorbar
                    cbar2.ax.tick_params(labelsize=FONT_axisTick);
                    cbar2.mappable.set_clim(vmin=np.min(AMPERE_plotLimValu), vmax=np.max(AMPERE_plotLimValu));
                    
                    if( gif_dayNiteLine == 1 ):
                        fig.canvas.flush_events(); #this is req. to get get_window_extent() to get the current window size
                        #Plot the sunrise/sunset terminators
                        dayNite_temp = np.abs(dayNite_sunrise - (TEC_timeUnique[i]-dateRange_dayNum_zeroHr[1]*86400)) <= 10/3600; #gets the sunrise locations that are within 10 sec of the current TEC time (2 min had way too many hits, zigzags)
                        hLgd_FLG_day = np.sum(dayNite_temp); #plotting flag, shows when legend is active
                        #constants will use all the time - only for plotting of day/nite line so minor importance
                        #this stuff makes the text angle plotted mostly correct most of the time
                        bboxFig = fig.get_window_extent().transformed(fig.dpi_scale_trans.inverted()); #get the entire figure dimensions
                        bboxAx0 = ax.get_window_extent().transformed(fig.dpi_scale_trans.inverted()); #get the plot dimensions
    #                    plot_ratio = (bboxAx0.width/bboxAx0.height)/( (bboxAx0.width/bboxAx0.height)/(bboxFig.width/bboxFig.height) )**2; #get the plot ratio, will use it to fix up the angle
                        plot_ratio = (bboxAx0.width/bboxAx0.height); #get the plot ratio, will use it to fix up the angle
                        dayNite_textRotationLenOrig = 35; #length to go up and down the sunrise/sunset line to estimate an angle
                        dayNite_savgolFiltLenOrig = 101; #set it as a constant to start off
                        dayNite_textLatAbs = (np.max(plotLatRange)-np.min(plotLatRange))*.9 + np.min(plotLatRange); #calc like 80% of the max latitude
                        if( hLgd_FLG_day > 0 ): #only do work if it is there
                            #calc all that day/nite stuff in one function to keep it from getting cluttered
                            dayNite_Lat_line, dayNite_Long_line, dayNite_Lat_text, dayNite_Long_text, dayNite_textRotation = GRITI_movieMaker_subfun_dayniteCalc(0,np.sum(dayNite_temp),dayNite_Grid_Long[dayNite_temp],dayNite_Grid_Lat[dayNite_temp],dayNite_textLatAbs,plot_ratio,dayNite_savgolFiltLenOrig,dayNite_textRotationLenOrig);
                            dayNite_latLongMapped = geoMap(dayNite_Long_line,dayNite_Lat_line); #convert the lat/long arcdeg to the current map coordinates
                            imDayNite_day = ax.plot(dayNite_latLongMapped[0],dayNite_latLongMapped[1],color='g',linewidth=1.75,zorder=6); #plots a line to show the sunrise time
                            if( gif_dayNiteText == 1 ):
                                dayNite_latLongMapped = geoMap(dayNite_Long_text,dayNite_Lat_text); #convert the lat/long arcdeg to the current map coordinates
                                textDayNite_day = ax.text(dayNite_latLongMapped[0], dayNite_latLongMapped[1], "Sunrise", rotation=dayNite_textRotation, color='g', fontsize=FONT_axisTick, zorder=6);
                            #END IF
                        #END IF
                        
                        dayNite_temp = np.abs(dayNite_sunset - (TEC_timeUnique[i]-dateRange_dayNum_zeroHr[1]*86400)) <= 10/3600; #gets the sunset locations that are within 10 sec of the current TEC time (2 min had way too many hits, zigzags)
                        hLgd_FLG_nite = np.sum(dayNite_temp); #plotting flag, shows when legend is active
                        if( hLgd_FLG_nite > 0 ): #only do work if it is there
                            #calc all that day/nite stuff in one function to keep it from getting cluttered
                            dayNite_Lat_line, dayNite_Long_line, dayNite_Lat_text, dayNite_Long_text, dayNite_textRotation = GRITI_movieMaker_subfun_dayniteCalc(1,np.sum(dayNite_temp),dayNite_Grid_Long[dayNite_temp],dayNite_Grid_Lat[dayNite_temp],dayNite_textLatAbs,plot_ratio,dayNite_savgolFiltLenOrig,dayNite_textRotationLenOrig);
                            dayNite_latLongMapped = geoMap(dayNite_Long_line,dayNite_Lat_line); #convert the lat/long arcdeg to the current map coordinates
                            imDayNite_nite = ax.plot(dayNite_latLongMapped[0],dayNite_latLongMapped[1],color='b',linewidth=1.75,zorder=6); #plots a line to show the sunset time
                            if( gif_dayNiteText == 1 ):
                                dayNite_latLongMapped = geoMap(dayNite_Long_text,dayNite_Lat_text); #convert the lat/long arcdeg to the current map coordinates
                                textDayNite_nite = ax.text(dayNite_latLongMapped[0], dayNite_latLongMapped[1], "Sunset", rotation=dayNite_textRotation, color='b', fontsize=FONT_axisTick, zorder=6);
                            #EMD IF
                        #END IF
                    elif( gif_dayNiteLine == 2 ):
                        dayNite_currentDay = subfun_dayNum_to_date( np.array((dateRange_dayNum_zeroHr[0],np.int64(TEC_timeUnique[i])),ndmin=2))[0]; #get the current yr/month/day
                        dayNite_currentHr = np.int64((TEC_timeUnique[i]-np.int64(TEC_timeUnique[i]))*24); #hr, get the current hour
                        dayNite_currentMin = np.int64( ((TEC_timeUnique[i]-np.int64(TEC_timeUnique[i]))*24 - dayNite_currentHr)*60); #min, get the current min
                        dayNite_currentSec = np.int64( (((TEC_timeUnique[i]-np.int64(TEC_timeUnique[i]))*24 - dayNite_currentHr)*60 - dayNite_currentMin)*60); #min, get the current min
                        dayNite_currentTime = datetime.datetime(dayNite_currentDay[0], dayNite_currentDay[1], dayNite_currentDay[2], dayNite_currentHr, dayNite_currentMin,dayNite_currentSec);
                        dayNite_shade = geoMap.nightshade(dayNite_currentTime, color='k', delta=0.25, alpha=0.25, ax=ax, zorder=2);
                    #END IF
                    
                    #Now drawing point of interest
                    Millstone_latLongMapped = geoMap(longMillstone,latMillstone); #convert the lat/long arcdeg to the current map coordinates
                    imMillstone = ax.plot(Millstone_latLongMapped[0],Millstone_latLongMapped[1],marker=gif_Millstone_Marker, color=gif_Millstone_Marker_Color, markersize=gif_Millstone_Marker_Size, zorder=50); #plot this, 50 always on top
                    
                    if( geoMap_projectionStyle_polar >= 1 ):
                        if( gif_spin == 0):
#                            x = (1.05*0.5*np.sin(radRange_J2000[i]))+0.5; #geoMap coordinate 
#                            y = (1.05*0.5*np.cos(radRange_J2000[i]+np.pi))+0.5; #geoMap coordinate 
                            x = (1.05*0.5*np.cos(radRange_J2000[i]))+0.5; #geoMap coordinate 
                            y = (1.05*0.5*np.sin(radRange_J2000[i]))+0.5; #geoMap coordinate 
                            #hSun = ax.text(x,y,'SUN\N{DEGREE SIGN}',transform=ax.transAxes,horizontalalignment='center',verticalalignment='center',fontproperties=FONT_axisTickFM);
                            circleSun = plt.Circle((x, y), radius=0.015, color='xkcd:sun yellow', clip_on=False,transform=ax.transAxes); #make a sun figure
                            hSun = ax.add_artist(circleSun); #plot the sun
                        else:
                            hSun = ax.set_theta_offset(radRange_J2000[i]); #turn the whole plot so top is where the sun is
                            #I'm not sure if I can get this working easily - not a lot of optons.
                        #END IF
                    #END IF
                else:
                    #Just plotting now - prep done, hopefully speeds it!
                    #Do the TEC plotting
                    pltHelprX, pltHelprY = np.meshgrid( gif_Grid_Long, gif_Grid_Lat); #helps the pcolor work
                    TEC_latLongMapped = geoMap(pltHelprX,pltHelprY); #convert the lat/long arcdeg to the current map coordinates
                    imTEC = ax.pcolormesh(TEC_latLongMapped[0], TEC_latLongMapped[1],  gif_Grid.T ,vmin=-TEC_plotLimValu, vmax=TEC_plotLimValu,cmap='jet',zorder=5); # pseudocolor plot "stretched" to the grid
    
                    #Do the AMPERE plotting
                    AMPERE_latLongMapped = geoMap(AMPERE_long_portion,AMPERE_lat_portion); #convert the lat/long arcdeg to the current map coordinates
                    imAMP = ax.scatter(AMPERE_latLongMapped[0],AMPERE_latLongMapped[1],s=gif_Scatter_Point_Size_AMPERE,c=AMPERE_jouleHeating_portion,cmap=AMPERE_colorMap, vmin=np.min(AMPERE_plotLimValu), vmax=np.max(AMPERE_plotLimValu), zorder=7);
                    
                    if( gif_dayNiteLine == 1 ):
                        #Plot the sunrise/sunset terminators
                        dayNite_temp = np.abs(dayNite_sunrise - (TEC_timeUnique[i]-dateRange_dayNum_zeroHr[1]*86400)) <= 10/3600; #gets the sunrise locations that are within 10 sec of the current TEC time (2 min had way too many hits, zigzags)
                        hLgd_FLG_day = np.sum(dayNite_temp); #plotting flag, shows when legend is active
                        if( hLgd_FLG_day > 0 ): #only do work if it is there
                            #calc all that day/nite stuff in one function to keep it from getting cluttered
                            dayNite_Lat_line, dayNite_Long_line, dayNite_Lat_text, dayNite_Long_text, dayNite_textRotation = GRITI_movieMaker_subfun_dayniteCalc(0,np.sum(dayNite_temp),dayNite_Grid_Long[dayNite_temp],dayNite_Grid_Lat[dayNite_temp],dayNite_textLatAbs,plot_ratio,dayNite_savgolFiltLenOrig,dayNite_textRotationLenOrig);
                            dayNite_latLongMapped = geoMap(dayNite_Long_line,dayNite_Lat_line); #convert the lat/long arcdeg to the current map coordinates
                            imDayNite_day = ax.plot(dayNite_latLongMapped[0],dayNite_latLongMapped[1],color='g',linewidth=1.75,zorder=6); #plots a line to show the sunrise time
                            if( gif_dayNiteText == 1 ):
                                dayNite_latLongMapped = geoMap(dayNite_Long_text,dayNite_Lat_text); #convert the lat/long arcdeg to the current map coordinates
                                textDayNite_day = ax.text(dayNite_latLongMapped[0], dayNite_latLongMapped[1], "Sunrise", rotation=dayNite_textRotation, color='g', fontsize=FONT_axisTick, zorder=6);
                            #END IF
                        #END IF
                        
                        dayNite_temp = np.abs(dayNite_sunset - (TEC_timeUnique[i]-dateRange_dayNum_zeroHr[1]*86400)) <= 10/3600; #gets the sunset locations that are within 10 sec of the current TEC time (2 min had way too many hits, zigzags)
                        hLgd_FLG_nite = np.sum(dayNite_temp); #plotting flag, shows when legend is active
                        if( hLgd_FLG_nite > 0 ): #only do work if it is there
                            #calc all that day/nite stuff in one function to keep it from getting cluttered
                            dayNite_Lat_line, dayNite_Long_line, dayNite_Lat_text, dayNite_Long_text, dayNite_textRotation = GRITI_movieMaker_subfun_dayniteCalc(1,np.sum(dayNite_temp),dayNite_Grid_Long[dayNite_temp],dayNite_Grid_Lat[dayNite_temp],dayNite_textLatAbs,plot_ratio,dayNite_savgolFiltLenOrig,dayNite_textRotationLenOrig);
                            dayNite_latLongMapped = geoMap(dayNite_Long_line,dayNite_Lat_line); #convert the lat/long arcdeg to the current map coordinates
                            imDayNite_nite = ax.plot(dayNite_latLongMapped[0],dayNite_latLongMapped[1],color='b',linewidth=1.75,zorder=6); #plots a line to show the sunset time
                            if( gif_dayNiteText == 1 ):
                                dayNite_latLongMapped = geoMap(dayNite_Long_text,dayNite_Lat_text); #convert the lat/long arcdeg to the current map coordinates
                                textDayNite_nite = ax.text(dayNite_latLongMapped[0], dayNite_latLongMapped[1], "Sunset", rotation=dayNite_textRotation, color='b', fontsize=FONT_axisTick, zorder=6);
                            #END IF
                        #END IF
                    elif( gif_dayNiteLine == 2 ):
                        dayNite_currentDay = subfun_dayNum_to_date( np.array((dateRange_dayNum_zeroHr[0],np.int64(TEC_timeUnique[i])),ndmin=2))[0]; #get the current yr/month/day
                        dayNite_currentHr = np.int64((TEC_timeUnique[i]-np.int64(TEC_timeUnique[i]))*24); #hr, get the current hour
                        dayNite_currentMin = np.int64( ((TEC_timeUnique[i]-np.int64(TEC_timeUnique[i]))*24 - dayNite_currentHr)*60); #min, get the current min
                        dayNite_currentSec = np.int64( (((TEC_timeUnique[i]-np.int64(TEC_timeUnique[i]))*24 - dayNite_currentHr)*60 - dayNite_currentMin)*60); #min, get the current min
                        dayNite_currentTime = datetime.datetime(dayNite_currentDay[0], dayNite_currentDay[1], dayNite_currentDay[2], dayNite_currentHr, dayNite_currentMin,dayNite_currentSec);
                        dayNite_shade = geoMap.nightshade(dayNite_currentTime, color='k', delta=0.25, alpha=0.25, ax=ax, zorder=2);
                    #END IF
                    
                    if( geoMap_projectionStyle_polar >= 1 ):
                        if( gif_spin == 0):
#                            x = (1.05*0.5*np.sin(radRange_J2000[i]))+0.5; #geoMap coordinate 
#                            y = (1.05*0.5*np.cos(radRange_J2000[i]+np.pi))+0.5; #geoMap coordinate 
                            x = (1.05*0.5*np.cos(radRange_J2000[i]))+0.5; #geoMap coordinate 
                            y = (1.05*0.5*np.sin(radRange_J2000[i]))+0.5; #geoMap coordinate 
                            #hSun = ax.text(x,y,'SUN\N{DEGREE SIGN}',transform=ax.transAxes,horizontalalignment='center',verticalalignment='center',fontproperties=FONT_axisTickFM);
                            circleSun = plt.Circle((x, y), radius=0.015, color='xkcd:sun yellow', clip_on=False,transform=ax.transAxes); #make a sun figure
                            hSun = ax.add_artist(circleSun); #plot the sun
                        else:
                            hSun = ax.set_theta_offset(radRange_J2000[i]); #turn the whole plot so top is where the sun is
                            #I'm not sure if I can get this working easily - not a lot of optons.
                        #END IF
                    #END IF
                #END IF
                
                #Dynamically show and hide the day/nite labels
    #            if( (hLgd_FLG_day > 0) & (hLgd_FLG_nite > 0) ):
    #                hLgd = ax.legend( (imDayNite_day , imDayNite_nite) , ('Sunrise','Sunset') , loc=4 , fontsize = FONT_axisTick ); #make that legend
    #            elif( (hLgd_FLG_day > 0) & (hLgd_FLG_nite == 0) ):
    #                hLgd = ax.legend( (imDayNite_day) , ('Sunrise') , loc=4 , fontsize = FONT_axisTick , handlelength=.75 ); #make that legend
    #            elif( (hLgd_FLG_day == 0) & (hLgd_FLG_nite > 0) ):
    #                hLgd = ax.legend( (imDayNite_nite,) , ('Sunset',) , loc=4 , fontsize = FONT_axisTick ); #make that legend
    #            #END IF
            
                #-----------------------Create Movie/GIF---------------------------
                #Makes the gif now
                plt.draw();
                
                gif_writer.grab_frame(); #get the frame and save it
                    
                #-------------------Clean up for re-use----------------------------
                #if forget one (like hOverlay) slows it way down after many plots
                imTEC.remove();
                imAMP.remove();
                if( gif_dayNiteLine == 1 ):
                    if(hLgd_FLG_day > 0): #only delete if it is there
                        imDayNite_day.pop(0).remove();
                        if( gif_dayNiteText == 1 ):
                            textDayNite_day.remove();
                        #END IF
                    #END IF
                    if(hLgd_FLG_nite > 0): #only delete if it is there
                        imDayNite_nite.pop(0).remove();
                        if( gif_dayNiteText == 1 ):
                            textDayNite_nite.remove();
                        #END IF
                    #END IF
                elif( gif_dayNiteLine == 2): #only delete if it is there
                    for middleman in dayNite_shade.collections: #this needs an extra helping hand
                        middleman.remove();
                #END IF
                if( geoMap_projectionStyle_polar >= 1 ): #only delete if it is there
                    hSun.remove();
                #END IF
                
            #END FOR i
        #END WITH
        
    elif(gif_Type == 6): #stationary data points + AMPERE data on same plot (no time average for TEC) + TEC keogram with line for current time
        #prep to plot, if the colorbar limit is 1 value, make it 2 because it's meant to be a +/-# situation.
        if( np.isscalar(TEC_plotLimValu) == 1 ):
            gif_TEC_plotLimValu = np.array( (-TEC_plotLimValu,TEC_plotLimValu) ); #make it a vector
        else:
            gif_TEC_plotLimValu = TEC_plotLimValu; #keep it the same
        #END IF
        #calc the TEC keogram first, only need to calc it once
        (gif_vTECChunked_keo, gif_avg_anyAngle,gif_avg_anyAngle_Width, \
        gif_avg_anyAngle_Range_Chunks_Long_Plot,gif_avg_anyAngle_Range_Chunks_Long_Plot_Name) = \
            GRITI_TEC_keo(gif_plotLatRange,gif_plotLongRange,TEC_timeUnique,\
                TEC_plotLimValu,'jet',data['TEC']['dTEC'],data['TEC']['time'],data['TEC']['lat'],data['TEC']['long'],gif_avg_anyAngle_orig, \
                gif_avg_anyAngle_N,gif_avg_anyAngle_Width_orig,gif_avg_anyAngle_45vsLatLong,avgPt_coords,geoMap_projectionStyle,\
                dateRange_dayNum_zeroHr,plotLatRange_autoTick,plotLongRange_autoTick,plotLongRange_autoTick_Crunched, gif_Millstone_Marker, gif_Millstone_Marker_Color, \
                gif_Millstone_Marker_Size,FONT_titleFM,FONT_axisTick,FONT_axisTickFM,FONT_axisLabelFM,BasemapFixDir,\
                'delta-vTEC','delta-vTEC [TECU]',FLG_fancyPlot,PLOT_lineWidth, folder, journal_width_2C,journal_height_max,journal_dpi,\
                avg_anyAngle_polarMode=avg_anyAngle_polarMode,FLG_disablePlot=2);
        #call the mecha function that runs the keo alg and makes a plot showing the averaging are
        
        AMPERE_dataRate = np.median(np.diff(AMPERE_timeUnique)); #days, get the median data rate for AMPERE data (avoids outliers)
        with gif_writer.saving(fig, gif_Name, gif_PPI): #figure to save, file name, and PPI (DPI in documentation)
                        
            #-------------------------Start Making Pictures------------------------
            for i in range(gif_timeRange[0],gif_timeRange[1]):
                
                #------------Corral the AMPERE data to the right place-------------
                k = np.where( (data['AMPERE']['time'] <= TEC_timeUnique[i]) & (data['AMPERE']['time'] >= (TEC_timeUnique[i]-AMPERE_dataRate)) )[0]; #get where the time point is, make sure it is within the data rate window
                AMPERE_jouleHeating_portion = AMPERE_data[k,locAMPERE_jouleHeating]; #ergs/(cm^2*sec), get the Joule Heating for the current time step
                AMPERE_lat_portion = AMPERE_data[k,locAMPERE_lat]; #degc, corresponding lat values
                AMPERE_long_portion = AMPERE_data[k,locAMPERE_long]; #degc, corresponding long values
                
                #----------------Corral the data to the right place----------------
                k =  np.where( data['TEC']['time'] == TEC_timeUnique[i])[0]; #gets during a time period
                vTEC_portion = data['TEC']['dTEC'][k]; #pull out the vTEC now
                pplat_portion = data['TEC']['lat'][k]; #get the pplat (pierce-point lat) at the time required
                pplong_portion = data['TEC']['long'][k]; #get the pplong (pierce-point long) at the time required
                            
                gif_Grid = GRITI_movieMaker_subfun_dataGridder(pplat_portion,pplong_portion,vTEC_portion,gif_Grid_Lat,gif_Grid_Long,gif_Grid_Lat_Spaces,gif_Grid_Long_Spaces,gif_Grid_Lat_Delta,gif_Grid_Long_Delta,dataRejectOrig,dataRejectLimitOrig,dataRejectMax);
                #call a numba'd function that makes the movie quicker by crunching the numbers gooder
                
                #----------------------------Tack on Title-------------------------
                string_title = 'TEC Global Plot | Time =  '+'{0:.2f}'.format(np.round((TEC_timeUnique[i]-dateRange_dayNum_zeroHr[1]*86400),2))+\
                    ', 0 UT on '+dateRange_zeroHr_monthName+' '+str(dateRange_zeroHr[2])+', '+str(dateRange_zeroHr[0]); #create mecha title
                
                ax[0].set_title(string_title,fontproperties=FONT_titleFM); #set the title, properties always needed
                    
                #-------------------Starting the Plotting--------------------------
                if( i == 0 ): #first run preps axes, color bars, etc.
                                   
                    #Do the TEC plotting
                    pltHelprX, pltHelprY = np.meshgrid( gif_Grid_Long, gif_Grid_Lat); #helps the pcolor work
                    TEC_latLongMapped = geoMap(pltHelprX,pltHelprY); #convert the lat/long arcdeg to the current map coordinates
                    imTEC = ax[0].pcolormesh(TEC_latLongMapped[0], TEC_latLongMapped[1],  gif_Grid.T ,vmin=-TEC_plotLimValu, vmax=TEC_plotLimValu,cmap='jet',zorder=5); # pseudocolor plot "stretched" to the grid
                    cbar = fig.colorbar(imTEC, cax=cax, orientation='vertical'); #create a colorbar using the prev. defined cax
                    cax.yaxis.set_ticks(np.linspace(-TEC_plotLimValu,TEC_plotLimValu,5)); #create useful tick marks
                    cax.yaxis.set_major_formatter(FormatStrFormatter('%.2f')); #force a rounded format
                    cbar.set_label("delta-vTEC [TECU]",y=0.87); #tabel the colorbar
                    cbar.ax.tick_params(labelsize=FONT_axisTick);
                    cbar.mappable.set_clim(vmin=-TEC_plotLimValu, vmax=TEC_plotLimValu);
    
                    #Do the AMPERE plotting
                    AMPERE_colorMap = ListedColormap( np.hstack(( np.array( ( (np.linspace(1,0.492063492063492,128)),(np.linspace(1,0.507936507936508,128)),(np.linspace(1,1,128)) ) ) , np.array( ( (np.linspace(0.492063492063492,1,128)) , (np.linspace(0.507936507936508,0,128)) , (np.linspace(1,1,128)) ) ) )).T ); #white to purpleblue to pink (based off of 'cool')
                    AMPERE_latLongMapped = geoMap(AMPERE_long_portion,AMPERE_lat_portion); #convert the lat/long arcdeg to the current map coordinates
                    imAMP = ax[0].scatter(AMPERE_latLongMapped[0],AMPERE_latLongMapped[1],s=gif_Scatter_Point_Size_AMPERE,c=AMPERE_jouleHeating_portion,cmap=AMPERE_colorMap, vmin=np.min(AMPERE_plotLimValu), vmax=np.max(AMPERE_plotLimValu), zorder=7);
                    cbar2 = fig.colorbar(imAMP, cax=cax2, orientation='vertical'); #create a colorbar using the prev. defined cax
    #                cbar2.ax.set_yticklabels(np.linspace(np.min(AMPERE_plotLimValu),np.max(AMPERE_plotLimValu),5)); #create useful tick marks
                    cax2.yaxis.set_major_formatter(FormatStrFormatter('%.1f')); #force a rounded format
                    cax2.yaxis.set_ticks_position('left'); #move it to the left
                    cax2.yaxis.set_label_position('left'); #move it to the left
                    cbar2.set_label('AMPERE Joule Heating [$erg/cm^{2}sec$]'); #tabel the colorbar
                    cbar2.ax.tick_params(labelsize=FONT_axisTick);
                    cbar2.mappable.set_clim(vmin=np.min(AMPERE_plotLimValu), vmax=np.max(AMPERE_plotLimValu));
                    
                    if( gif_dayNiteLine == 1 ):
                        fig.canvas.flush_events(); #this is req. to get get_window_extent() to get the current window size
                        #Plot the sunrise/sunset terminators
                        dayNite_temp = np.abs(dayNite_sunrise - (TEC_timeUnique[i]-dateRange_dayNum_zeroHr[1]*86400)) <= 10/3600; #gets the sunrise locations that are within 10 sec of the current TEC time (2 min had way too many hits, zigzags)
                        hLgd_FLG_day = np.sum(dayNite_temp); #plotting flag, shows when legend is active
                        #constants will use all the time - only for plotting of day/nite line so minor importance
                        #this stuff makes the text angle plotted mostly correct most of the time
                        bboxFig = fig.get_window_extent().transformed(fig.dpi_scale_trans.inverted()); #get the entire figure dimensions
                        bboxAx0 = ax[0].get_window_extent().transformed(fig.dpi_scale_trans.inverted()); #get the plot dimensions
    #                    plot_ratio = (bboxAx0.width/bboxAx0.height)/( (bboxAx0.width/bboxAx0.height)/(bboxFig.width/bboxFig.height) )**2; #get the plot ratio, will use it to fix up the angle
                        plot_ratio = (bboxAx0.width/bboxAx0.height); #get the plot ratio, will use it to fix up the angle
                        dayNite_textRotationLenOrig = 35; #length to go up and down the sunrise/sunset line to estimate an angle
                        dayNite_savgolFiltLenOrig = 101; #set it as a constant to start off
                        dayNite_textLatAbs = (np.max(plotLatRange)-np.min(plotLatRange))*.9 + np.min(plotLatRange); #calc like 80% of the max latitude
                        if( hLgd_FLG_day > 0 ): #only do work if it is there
                            #calc all that day/nite stuff in one function to keep it from getting cluttered
                            dayNite_Lat_line, dayNite_Long_line, dayNite_Lat_text, dayNite_Long_text, dayNite_textRotation = GRITI_movieMaker_subfun_dayniteCalc(0,np.sum(dayNite_temp),dayNite_Grid_Long[dayNite_temp],dayNite_Grid_Lat[dayNite_temp],dayNite_textLatAbs,plot_ratio,dayNite_savgolFiltLenOrig,dayNite_textRotationLenOrig);
                            dayNite_latLongMapped = geoMap(dayNite_Long_line,dayNite_Lat_line); #convert the lat/long arcdeg to the current map coordinates
                            imDayNite_day = ax[0].plot(dayNite_latLongMapped[0],dayNite_latLongMapped[1],color='g',linewidth=1.75,zorder=6); #plots a line to show the sunrise time
                            if( gif_dayNiteText == 1 ):
                                dayNite_latLongMapped = geoMap(dayNite_Long_text,dayNite_Lat_text); #convert the lat/long arcdeg to the current map coordinates
                                textDayNite_day = ax[0].text(dayNite_latLongMapped[0], dayNite_latLongMapped[1], "Sunrise", rotation=dayNite_textRotation, color='g', fontsize=FONT_axisTick, zorder=6);
                            #END IF
                        #END IF
                        
                        dayNite_temp = np.abs(dayNite_sunset - (TEC_timeUnique[i]-dateRange_dayNum_zeroHr[1]*86400)) <= 10/3600; #gets the sunset locations that are within 10 sec of the current TEC time (2 min had way too many hits, zigzags)
                        hLgd_FLG_nite = np.sum(dayNite_temp); #plotting flag, shows when legend is active
                        if( hLgd_FLG_nite > 0 ): #only do work if it is there
                            #calc all that day/nite stuff in one function to keep it from getting cluttered
                            dayNite_Lat_line, dayNite_Long_line, dayNite_Lat_text, dayNite_Long_text, dayNite_textRotation = GRITI_movieMaker_subfun_dayniteCalc(1,np.sum(dayNite_temp),dayNite_Grid_Long[dayNite_temp],dayNite_Grid_Lat[dayNite_temp],dayNite_textLatAbs,plot_ratio,dayNite_savgolFiltLenOrig,dayNite_textRotationLenOrig);
                            dayNite_latLongMapped = geoMap(dayNite_Long_line,dayNite_Lat_line); #convert the lat/long arcdeg to the current map coordinates
                            imDayNite_nite = ax[0].plot(dayNite_latLongMapped[0],dayNite_latLongMapped[1],color='b',linewidth=1.75,zorder=6); #plots a line to show the sunset time
                            if( gif_dayNiteText == 1 ):
                                dayNite_latLongMapped = geoMap(dayNite_Long_text,dayNite_Lat_text); #convert the lat/long arcdeg to the current map coordinates
                                textDayNite_nite = ax[0].text(dayNite_latLongMapped[0], dayNite_latLongMapped[1], "Sunset", rotation=dayNite_textRotation, color='b', fontsize=FONT_axisTick, zorder=6);
                            #EMD IF
                        #END IF
                    elif( gif_dayNiteLine == 2 ):
                        dayNite_currentDay = subfun_dayNum_to_date( np.array((dateRange_dayNum_zeroHr[0],np.int64(TEC_timeUnique[i])),ndmin=2))[0]; #get the current yr/month/day
                        dayNite_currentHr = np.int64((TEC_timeUnique[i]-np.int64(TEC_timeUnique[i]))*24); #hr, get the current hour
                        dayNite_currentMin = np.int64( ((TEC_timeUnique[i]-np.int64(TEC_timeUnique[i]))*24 - dayNite_currentHr)*60); #min, get the current min
                        dayNite_currentSec = np.int64( (((TEC_timeUnique[i]-np.int64(TEC_timeUnique[i]))*24 - dayNite_currentHr)*60 - dayNite_currentMin)*60); #min, get the current min
                        dayNite_currentTime = datetime.datetime(dayNite_currentDay[0], dayNite_currentDay[1], dayNite_currentDay[2], dayNite_currentHr, dayNite_currentMin,dayNite_currentSec);
                        dayNite_shade = geoMap.nightshade(dayNite_currentTime, color='k', delta=0.25, alpha=0.25, ax=ax[0], zorder=2);
                    #END IF
                    
                    #Now drawing point of interest
                    Millstone_latLongMapped = geoMap(longMillstone,latMillstone); #convert the lat/long arcdeg to the current map coordinates
                    imMillstone = ax[0].plot(Millstone_latLongMapped[0],Millstone_latLongMapped[1],marker=gif_Millstone_Marker, color=gif_Millstone_Marker_Color, markersize=gif_Millstone_Marker_Size, zorder=50); #plot this, 50 always on top
                    
                    if( geoMap_projectionStyle_polar >= 1 ):
                        if( gif_spin == 0):
#                            x = (1.05*0.5*np.sin(radRange_J2000[i]))+0.5; #geoMap coordinate 
#                            y = (1.05*0.5*np.cos(radRange_J2000[i]+np.pi))+0.5; #geoMap coordinate 
                            x = (1.05*0.5*np.cos(radRange_J2000[i]))+0.5; #geoMap coordinate 
                            y = (1.05*0.5*np.sin(radRange_J2000[i]))+0.5; #geoMap coordinate 
                            #hSun = ax[0].text(x,y,'SUN\N{DEGREE SIGN}',transform=ax[0].transAxes,horizontalalignment='center',verticalalignment='center',fontproperties=FONT_axisTickFM);
                            circleSun = plt.Circle((x, y), radius=0.015, color='xkcd:sun yellow', clip_on=False,transform=ax[0].transAxes); #make a sun figure
                            hSun = ax[0].add_artist(circleSun); #plot the sun
                        else:
                            hSun = ax[0].set_theta_offset(radRange_J2000[i]); #turn the whole plot so top is where the sun is
                            #I'm not sure if I can get this working easily - not a lot of optons.
                        #END IF
                    #END IF
                    
                    #------Now plot the keogram--------
                    pltHelprX, pltHelprY = np.meshgrid( (TEC_timeUnique - dateRange_dayNum_zeroHr[1]*86400), \
                                gif_avg_anyAngle_Range_Chunks_Long_Plot);
                    im = ax[1].pcolormesh(pltHelprX, pltHelprY,  gif_vTECChunked_keo.T ,vmin=np.min(gif_TEC_plotLimValu), vmax=np.max(gif_TEC_plotLimValu),cmap='jet'); # pseudocolor plot "stretched" to the grid
                    cbarKeo = fig.colorbar(im, cax=caxKeo, orientation='vertical'); #create a colorbar using the prev. defined cax
                    caxKeo.yaxis.set_ticks(np.linspace(np.min(gif_TEC_plotLimValu),np.max(gif_TEC_plotLimValu),5)); #create useful tick marks
                    caxKeo.yaxis.set_major_formatter(FormatStrFormatter('%.2f')); #force a rounded format
                    cbarKeo.set_label('delta-vTEC [TECU]'); #tabel the colorbar
                    cbarKeo.ax.tick_params(labelsize=FONT_axisTick);
                    cbarKeo.mappable.set_clim(vmin=np.min(gif_TEC_plotLimValu), vmax=np.max(gif_TEC_plotLimValu));
                    caxKeo.yaxis.label.set_font_properties(FONT_axisLabelFM);
                    
                    #    string_title = 'TEC Averaged on Angle of '+str(np.round(avg_anyAngle,2))+' deg and Width of '+ \
                    #        str(np.round(settings['TEC']['keo']['keo width'],2))+' arcdeg, Avg Step # = '+str(avg_anyAngle_N)+ \
                    #        ' arcdeg, Line Shows '+settings['TEC']['keo']['keo plot latlong name']+' of Millstone Hill Zenith Beam'; #create mecha title
                    string_title = 'delta-vTEC Keogram of '+gif_zoneName; #create mecha title
                    ax[1].set_title(string_title,fontproperties=FONT_titleFM); #set the title
                    ax[1].set_xlabel('Time in UT - 0 Hr on Day '+str(dateRange_dayNum_zeroHr[1])+', '+str(dateRange_dayNum_zeroHr[0])+' [hr]',fontproperties=FONT_axisLabelFM); #set the x axis label
                    ax[1].set_ylabel(gif_avg_anyAngle_Range_Chunks_Long_Plot_Name+' [arcdeg]',fontproperties=FONT_axisLabelFM); #set the y axis label
                    
                    xAxisTicks = np.arange( (np.round((np.min(TEC_timeUnique)-dateRange_dayNum_zeroHr[1]*86400)) - np.mod(np.round((np.min(TEC_timeUnique)-dateRange_dayNum_zeroHr[1]*86400)),2)) , \
                            (np.round((np.max(TEC_timeUnique)-dateRange_dayNum_zeroHr[1]*86400)) - np.mod(np.round((np.max(TEC_timeUnique)-dateRange_dayNum_zeroHr[1]*86400)),2)) + 2 , \
                            8); #sets the start hr, stop hr, and the step size between (in this case, 2 hr)
                    ax[1].set_xticks(xAxisTicks); #set x axis ticks
                    
                    avg_anyAngle_Range_Chunks_Long_Plot_autoTick = (np.ceil(np.max(gif_avg_anyAngle_Range_Chunks_Long_Plot)) - np.floor(np.min(gif_avg_anyAngle_Range_Chunks_Long_Plot)))/13; #tries to split the latitude range into 13 parts (based off of 180/15+1)
                    if( avg_anyAngle_Range_Chunks_Long_Plot_autoTick > 25 ):
                        avg_anyAngle_Range_Chunks_Long_Plot_autoTick = 30; #sets the tick setting to 15 arcdegrees per tick
                    elif( avg_anyAngle_Range_Chunks_Long_Plot_autoTick > 10 ):
                        avg_anyAngle_Range_Chunks_Long_Plot_autoTick = 15; #sets the tick setting to 15 arcdegrees per tick
                    elif( avg_anyAngle_Range_Chunks_Long_Plot_autoTick > 5 ):
                        avg_anyAngle_Range_Chunks_Long_Plot_autoTick = 10; #sets the tick setting to 10 arcdegrees per tick
                    elif( avg_anyAngle_Range_Chunks_Long_Plot_autoTick > 2 ):
                        avg_anyAngle_Range_Chunks_Long_Plot_autoTick = 5; #sets the tick setting to 5 arcdegrees per tick
                    elif( avg_anyAngle_Range_Chunks_Long_Plot_autoTick > 1 ):
                        avg_anyAngle_Range_Chunks_Long_Plot_autoTick = 2; #sets the tick setting to 5 arcdegrees per tick
                    elif( avg_anyAngle_Range_Chunks_Long_Plot_autoTick >= 0.6 ): #0.6 because 15/25 = 0.6, so there will be enough 1 arcdeg ticks
                        avg_anyAngle_Range_Chunks_Long_Plot_autoTick = 1; #                                                        sets the tick setting to 1 arcdegree per tick
                    else:
                        if(gif_avg_anyAngle_Range_Chunks_Long_Plot_Name == 'Latitude'): #if Y axis is latitude, use latitude
                            avg_anyAngle_Range_Chunks_Long_Plot_autoTick = (np.max(gif_plotLatRange) - np.min(gif_plotLatRange))/13; #just goes for it if it's a super tiny range
                        elif(gif_avg_anyAngle_Range_Chunks_Long_Plot_Name == 'Longitude'): #if Y axis is longitude, use longitude
                            avg_anyAngle_Range_Chunks_Long_Plot_autoTick = (np.max(gif_plotLongRange) - np.min(gif_plotLongRange))/13; #just goes for it if it's a super tiny range
                        #END IF
                    #END IF
                    yAxisTicks = np.round(np.arange( np.floor(np.min(gif_avg_anyAngle_Range_Chunks_Long_Plot)),np.ceil(np.max(gif_avg_anyAngle_Range_Chunks_Long_Plot))+avg_anyAngle_Range_Chunks_Long_Plot_autoTick,avg_anyAngle_Range_Chunks_Long_Plot_autoTick ),2); #creates y ticks automagically
                    ax[1].set_yticks(yAxisTicks); #set x axis ticks
                    ax[1].set_ylim( np.round(ax[1].get_ylim()) ); #avoid weird rounding errors
                    
                    #Now drawing line of interest
                    if( gif_avg_anyAngle_Range_Chunks_Long_Plot_Name == 'Longitude' ): #if true, longitude
                        if( (np.min(gif_plotLongRange) <= longMillstone) & (np.max(gif_plotLongRange) >= longMillstone) ): #only plot if it's in the long range specified
                            ax[1].plot( np.linspace(np.min((TEC_timeUnique - dateRange_dayNum_zeroHr[1]*86400)/3600),np.max((TEC_timeUnique - dateRange_dayNum_zeroHr[1]*86400)/3600),10,endpoint=True) , #X time hr
                                    np.tile(longMillstone,10) , #Y latitude OR longitude arcdeg
                                    c='xkcd:black',linewidth=1); #plots a point with a black line
                        #END IF
                    else: #else latitude
                        if( (np.min(gif_plotLatRange) <= latMillstone) & (np.max(gif_plotLatRange) >= latMillstone) ): #only plot if it's in the lat range specified
                            ax[1].plot( np.linspace(np.min((TEC_timeUnique - dateRange_dayNum_zeroHr[1]*86400)/3600),np.max((TEC_timeUnique - dateRange_dayNum_zeroHr[1]*86400)/3600),10,endpoint=True) , #X time hr
                                    np.tile(latMillstone,10) , #Y latitude OR longitude arcdeg
                                    c='xkcd:black',linewidth=1); #plots a point with a black line
                        #END IF
                    #END IF
                    
                    #-----plot vertical line showing the time on the keogram-----
                    hVline = ax[1].axvline( x=(TEC_timeUnique[i] - dateRange_dayNum_zeroHr[1]*86400) ,c='xkcd:black',linewidth=1, linestyle='--'); #plot a vertical line to show the current time
                    
                else:
                    #Just plotting now - prep done, hopefully speeds it!
                    #Do the TEC plotting
                    pltHelprX, pltHelprY = np.meshgrid( gif_Grid_Long, gif_Grid_Lat); #helps the pcolor work
                    TEC_latLongMapped = geoMap(pltHelprX,pltHelprY); #convert the lat/long arcdeg to the current map coordinates
                    imTEC = ax[0].pcolormesh(TEC_latLongMapped[0], TEC_latLongMapped[1],  gif_Grid.T ,vmin=-TEC_plotLimValu, vmax=TEC_plotLimValu,cmap='jet',zorder=5); # pseudocolor plot "stretched" to the grid
    
                    #Do the AMPERE plotting
                    AMPERE_latLongMapped = geoMap(AMPERE_long_portion,AMPERE_lat_portion); #convert the lat/long arcdeg to the current map coordinates
                    imAMP = ax[0].scatter(AMPERE_latLongMapped[0],AMPERE_latLongMapped[1],s=gif_Scatter_Point_Size_AMPERE,c=AMPERE_jouleHeating_portion,cmap=AMPERE_colorMap, vmin=np.min(AMPERE_plotLimValu), vmax=np.max(AMPERE_plotLimValu), zorder=7);
                    
                    if( gif_dayNiteLine == 1 ):
                        #Plot the sunrise/sunset terminators
                        dayNite_temp = np.abs(dayNite_sunrise - (TEC_timeUnique[i]-dateRange_dayNum_zeroHr[1]*86400)) <= 10/3600; #gets the sunrise locations that are within 10 sec of the current TEC time (2 min had way too many hits, zigzags)
                        hLgd_FLG_day = np.sum(dayNite_temp); #plotting flag, shows when legend is active
                        if( hLgd_FLG_day > 0 ): #only do work if it is there
                            #calc all that day/nite stuff in one function to keep it from getting cluttered
                            dayNite_Lat_line, dayNite_Long_line, dayNite_Lat_text, dayNite_Long_text, dayNite_textRotation = GRITI_movieMaker_subfun_dayniteCalc(0,np.sum(dayNite_temp),dayNite_Grid_Long[dayNite_temp],dayNite_Grid_Lat[dayNite_temp],dayNite_textLatAbs,plot_ratio,dayNite_savgolFiltLenOrig,dayNite_textRotationLenOrig);
                            dayNite_latLongMapped = geoMap(dayNite_Long_line,dayNite_Lat_line); #convert the lat/long arcdeg to the current map coordinates
                            imDayNite_day = ax[0].plot(dayNite_latLongMapped[0],dayNite_latLongMapped[1],color='g',linewidth=1.75,zorder=6); #plots a line to show the sunrise time
                            if( gif_dayNiteText == 1 ):
                                dayNite_latLongMapped = geoMap(dayNite_Long_text,dayNite_Lat_text); #convert the lat/long arcdeg to the current map coordinates
                                textDayNite_day = ax[0].text(dayNite_latLongMapped[0], dayNite_latLongMapped[1], "Sunrise", rotation=dayNite_textRotation, color='g', fontsize=FONT_axisTick, zorder=6);
                            #END IF
                        #END IF
                        
                        dayNite_temp = np.abs(dayNite_sunset - (TEC_timeUnique[i]-dateRange_dayNum_zeroHr[1]*86400)) <= 10/3600; #gets the sunset locations that are within 10 sec of the current TEC time (2 min had way too many hits, zigzags)
                        hLgd_FLG_nite = np.sum(dayNite_temp); #plotting flag, shows when legend is active
                        if( hLgd_FLG_nite > 0 ): #only do work if it is there
                            #calc all that day/nite stuff in one function to keep it from getting cluttered
                            dayNite_Lat_line, dayNite_Long_line, dayNite_Lat_text, dayNite_Long_text, dayNite_textRotation = GRITI_movieMaker_subfun_dayniteCalc(1,np.sum(dayNite_temp),dayNite_Grid_Long[dayNite_temp],dayNite_Grid_Lat[dayNite_temp],dayNite_textLatAbs,plot_ratio,dayNite_savgolFiltLenOrig,dayNite_textRotationLenOrig);
                            dayNite_latLongMapped = geoMap(dayNite_Long_line,dayNite_Lat_line); #convert the lat/long arcdeg to the current map coordinates
                            imDayNite_nite = ax[0].plot(dayNite_latLongMapped[0],dayNite_latLongMapped[1],color='b',linewidth=1.75,zorder=6); #plots a line to show the sunset time
                            if( gif_dayNiteText == 1 ):
                                dayNite_latLongMapped = geoMap(dayNite_Long_text,dayNite_Lat_text); #convert the lat/long arcdeg to the current map coordinates
                                textDayNite_nite = ax[0].text(dayNite_latLongMapped[0], dayNite_latLongMapped[1], "Sunset", rotation=dayNite_textRotation, color='b', fontsize=FONT_axisTick, zorder=6);
                            #END IF
                        #END IF
                    elif( gif_dayNiteLine == 2 ):
                        dayNite_currentDay = subfun_dayNum_to_date( np.array((dateRange_dayNum_zeroHr[0],np.int64(TEC_timeUnique[i])),ndmin=2))[0]; #get the current yr/month/day
                        dayNite_currentHr = np.int64((TEC_timeUnique[i]-np.int64(TEC_timeUnique[i]))*24); #hr, get the current hour
                        dayNite_currentMin = np.int64( ((TEC_timeUnique[i]-np.int64(TEC_timeUnique[i]))*24 - dayNite_currentHr)*60); #min, get the current min
                        dayNite_currentSec = np.int64( (((TEC_timeUnique[i]-np.int64(TEC_timeUnique[i]))*24 - dayNite_currentHr)*60 - dayNite_currentMin)*60); #min, get the current min
                        dayNite_currentTime = datetime.datetime(dayNite_currentDay[0], dayNite_currentDay[1], dayNite_currentDay[2], dayNite_currentHr, dayNite_currentMin,dayNite_currentSec);
                        dayNite_shade = geoMap.nightshade(dayNite_currentTime, color='k', delta=0.25, alpha=0.25, ax=ax[0], zorder=2);
                    #END IF
                    
                    if( geoMap_projectionStyle_polar >= 1 ):
                        if( gif_spin == 0):
#                            x = (1.05*0.5*np.sin(radRange_J2000[i]))+0.5; #geoMap coordinate 
#                            y = (1.05*0.5*np.cos(radRange_J2000[i]+np.pi))+0.5; #geoMap coordinate 
                            x = (1.05*0.5*np.cos(radRange_J2000[i]))+0.5; #geoMap coordinate 
                            y = (1.05*0.5*np.sin(radRange_J2000[i]))+0.5; #geoMap coordinate 
                            #hSun = ax.text(x,y,'SUN\N{DEGREE SIGN}',transform=ax.transAxes,horizontalalignment='center',verticalalignment='center',fontproperties=FONT_axisTickFM);
                            circleSun = plt.Circle((x, y), radius=0.015, color='xkcd:sun yellow', clip_on=False,transform=ax[0].transAxes); #make a sun figure
                            hSun = ax[0].add_artist(circleSun); #plot the sun
                        else:
                            hSun = ax[0].set_theta_offset(radRange_J2000[i]); #turn the whole plot so top is where the sun is
                            #I'm not sure if I can get this working easily - not a lot of optons.
                        #END IF
                    #END IF
                    
                    #----plot vertical line showing the time on the keogram-----
                    hVline = ax[1].axvline( x=(TEC_timeUnique[i] - dateRange_dayNum_zeroHr[1]*86400) ,c='xkcd:black',linewidth=1, linestyle='--'); #plot a vertical line to show the current time
                #END IF
                
                #Dynamically show and hide the day/nite labels
    #            if( (hLgd_FLG_day > 0) & (hLgd_FLG_nite > 0) ):
    #                hLgd = ax.legend( (imDayNite_day , imDayNite_nite) , ('Sunrise','Sunset') , loc=4 , fontsize = FONT_axisTick ); #make that legend
    #            elif( (hLgd_FLG_day > 0) & (hLgd_FLG_nite == 0) ):
    #                hLgd = ax.legend( (imDayNite_day) , ('Sunrise') , loc=4 , fontsize = FONT_axisTick , handlelength=.75 ); #make that legend
    #            elif( (hLgd_FLG_day == 0) & (hLgd_FLG_nite > 0) ):
    #                hLgd = ax.legend( (imDayNite_nite,) , ('Sunset',) , loc=4 , fontsize = FONT_axisTick ); #make that legend
    #            #END IF
            
                #-----------------------Create Movie/GIF---------------------------
                #Makes the gif now
                plt.draw();
                gif_writer.grab_frame(); #get the frame and save it
                    
                #-------------------Clean up for re-use----------------------------
                #if forget one (like hOverlay) slows it way down after many plots
                imTEC.remove();
                imAMP.remove();
                hVline.remove();
                if( gif_dayNiteLine == 1 ):
                    if(hLgd_FLG_day > 0): #only delete if it is there
                        imDayNite_day.pop(0).remove();
                        if( gif_dayNiteText == 1 ):
                            textDayNite_day.remove();
                        #END IF
                    #END IF
                    if(hLgd_FLG_nite > 0): #only delete if it is there
                        imDayNite_nite.pop(0).remove();
                        if( gif_dayNiteText == 1 ):
                            textDayNite_nite.remove();
                        #END IF
                    #END IF
                elif( gif_dayNiteLine == 2): #only delete if it is there
                    for middleman in dayNite_shade.collections: #this needs an extra helping hand
                        middleman.remove();
                #END IF
                if( geoMap_projectionStyle_polar >= 1 ): #only delete if it is there
                    hSun.remove();
                #END IF
                
            #END FOR i
        #END WITH
        
    elif(gif_Type == 7): #stationary data points + AMPERE data on same plot (no time average for TEC) + TEC keogram with line for current time
        #prep to plot, if the colorbar limit is 1 value, make it 2 because it's meant to be a +/-# situation.
        if( np.isscalar(TEC_plotLimValu) == 1 ):
            gif_TEC_plotLimValu = np.array( (-TEC_plotLimValu,TEC_plotLimValu) ); #make it a vector
        else:
            gif_TEC_plotLimValu = TEC_plotLimValu; #keep it the same
        #END IF
        #calc the TEC keogram first, only need to calc it once
        (gif_vTECChunked_keo, gif_avg_anyAngle,gif_avg_anyAngle_Width, \
        gif_avg_anyAngle_Range_Chunks_Long_Plot,gif_avg_anyAngle_Range_Chunks_Long_Plot_Name) = \
            GRITI_TEC_keo(gif_plotLatRange,gif_plotLongRange,TEC_timeUnique,\
                TEC_plotLimValu,'jet',data['TEC']['dTEC'],data['TEC']['time'],data['TEC']['lat'],data['TEC']['long'],data['time ref'],gif_avg_anyAngle_orig, \
                gif_avg_anyAngle_N,gif_avg_anyAngle_Width_orig,gif_avg_anyAngle_45vsLatLong,avgPt_coords,geoMap_projectionStyle,\
                dateRange_dayNum_zeroHr,plotLatRange_autoTick,plotLongRange_autoTick,plotLongRange_autoTick_Crunched, gif_Millstone_Marker, gif_Millstone_Marker_Color, \
                gif_Millstone_Marker_Size,FONT_titleFM,FONT_axisTick,FONT_axisTickFM,FONT_axisLabelFM,BasemapFixDir,\
                'delta-vTEC','delta-vTEC [TECU]',FLG_fancyPlot,PLOT_lineWidth, folder, journal_width_2C,journal_height_max,journal_dpi,\
                avg_anyAngle_polarMode=avg_anyAngle_polarMode,FLG_disablePlot=2);
        #call the mecha function that runs the keo alg and makes a plot showing the averaging are
        
        (gif2_vTECChunked_keo, gif_avg_anyAngle,gif2_avg_anyAngle_Width, \
        gif2_avg_anyAngle_Range_Chunks_Long_Plot,gif2_avg_anyAngle_Range_Chunks_Long_Plot_Name) = \
            GRITI_TEC_keo(gif2_plotLatRange,gif2_plotLongRange,TEC_timeUnique,\
                TEC_plotLimValu,'jet',data['TEC']['dTEC'],data['TEC']['time'],data['TEC']['lat'],data['TEC']['long'],data['time ref'],gif_avg_anyAngle_orig, \
                gif_avg_anyAngle_N,gif_avg_anyAngle_Width_orig,gif_avg_anyAngle_45vsLatLong,avgPt_coords,geoMap_projectionStyle,\
                dateRange_dayNum_zeroHr,plotLatRange_autoTick,plotLongRange_autoTick,plotLongRange_autoTick_Crunched, gif_Millstone_Marker, gif_Millstone_Marker_Color, \
                gif_Millstone_Marker_Size,FONT_titleFM,FONT_axisTick,FONT_axisTickFM,FONT_axisLabelFM,BasemapFixDir,\
                'delta-vTEC','delta-vTEC [TECU]',FLG_fancyPlot,PLOT_lineWidth, folder, journal_width_2C,journal_height_max,journal_dpi,\
                avg_anyAngle_polarMode=avg_anyAngle_polarMode,FLG_disablePlot=2);
        #call the mecha function that runs the keo alg and makes a plot showing the averaging are
        
        AMPERE_dataRate = np.median(np.diff(AMPERE_timeUnique)); #days, get the median data rate for AMPERE data (avoids outliers)
        with gif_writer.saving(fig, gif_Name, gif_PPI): #figure to save, file name, and PPI (DPI in documentation)
                        
            #-------------------------Start Making Pictures------------------------
            for i in range(gif_timeRange[0],gif_timeRange[1]):
                
                #------------Corral the AMPERE data to the right place-------------
                if( gif_timeDelay == 1 ):
                    k = np.where( ((data['AMPERE']['time']+time_cutout_range_delay_AMPERE/24) <= TEC_timeUnique[i]) & ((data['AMPERE']['time']+time_cutout_range_delay_AMPERE/24) >= (TEC_timeUnique[i]-AMPERE_dataRate)) )[0]; #get where the time point is, make sure it is within the data rate window
                else:
                    k = np.where( (data['AMPERE']['time'] <= TEC_timeUnique[i]) & (data['AMPERE']['time'] >= (TEC_timeUnique[i]-AMPERE_dataRate)) )[0]; #get where the time point is, make sure it is within the data rate window
                #END IF
                AMPERE_jouleHeating_portion = AMPERE_data[k,locAMPERE_jouleHeating]; #ergs/(cm^2*sec), get the Joule Heating for the current time step
                AMPERE_lat_portion = AMPERE_data[k,locAMPERE_lat]; #degc, corresponding lat values
                AMPERE_long_portion = AMPERE_data[k,locAMPERE_long]; #degc, corresponding long values
                
                #----------------Corral the data to the right place----------------
                k =  np.where( data['TEC']['time'] == TEC_timeUnique[i])[0]; #gets during a time period
                vTEC_portion = data['TEC']['dTEC'][k]; #pull out the vTEC now
                pplat_portion = data['TEC']['lat'][k]; #get the pplat (pierce-point lat) at the time required
                pplong_portion = data['TEC']['long'][k]; #get the pplong (pierce-point long) at the time required
                            
                gif_Grid = GRITI_movieMaker_subfun_dataGridder(pplat_portion,pplong_portion,vTEC_portion,gif_Grid_Lat,gif_Grid_Long,gif_Grid_Lat_Spaces,gif_Grid_Long_Spaces,gif_Grid_Lat_Delta,gif_Grid_Long_Delta,dataRejectOrig,dataRejectLimitOrig,dataRejectMax);
                #call a numba'd function that makes the movie quicker by crunching the numbers gooder
                
                #----------------------------Tack on Title-------------------------
                string_title = 'TEC Global Plot | Time =  '+'{0:.2f}'.format(np.round((TEC_timeUnique[i]-dateRange_dayNum_zeroHr[1]*86400),2))+\
                    ', 0 UT on '+dateRange_zeroHr_monthName+' '+str(dateRange_zeroHr[2])+', '+str(dateRange_zeroHr[0]); #create mecha title
                
                ax[0].set_title(string_title,fontproperties=FONT_titleFM,y=1.035); #set the title, properties always needed
                    
                #-------------------Starting the Plotting--------------------------
                if( i == 0 ): #first run preps axes, color bars, etc.
                                   
                    #Do the TEC plotting
                    pltHelprX, pltHelprY = np.meshgrid( gif_Grid_Long, gif_Grid_Lat); #helps the pcolor work
                    TEC_latLongMapped = geoMap(pltHelprX,pltHelprY); #convert the lat/long arcdeg to the current map coordinates
                    imTEC = ax[0].pcolormesh(TEC_latLongMapped[0], TEC_latLongMapped[1],  gif_Grid.T ,vmin=-TEC_plotLimValu, vmax=TEC_plotLimValu,cmap='jet',zorder=5); # pseudocolor plot "stretched" to the grid
                    cbar = fig.colorbar(imTEC, cax=cax, orientation='vertical'); #create a colorbar using the prev. defined cax
                    cax.yaxis.set_ticks(np.linspace(-TEC_plotLimValu,TEC_plotLimValu,5)); #create useful tick marks
                    cax.yaxis.set_major_formatter(FormatStrFormatter('%.2f')); #force a rounded format
                    # cbar.set_label("delta-vTEC [TECU]",y=0.5); #tabel the colorbar
                    cbar.ax.tick_params(labelsize=FONT_axisTick);
                    cbar.mappable.set_clim(vmin=-TEC_plotLimValu, vmax=TEC_plotLimValu);
    
                    #Do the AMPERE plotting
                    AMPERE_colorMap = ListedColormap( np.hstack(( np.array( ( (np.linspace(1,0.492063492063492,128)),(np.linspace(1,0.507936507936508,128)),(np.linspace(1,1,128)) ) ) , np.array( ( (np.linspace(0.492063492063492,1,128)) , (np.linspace(0.507936507936508,0,128)) , (np.linspace(1,1,128)) ) ) )).T ); #white to purpleblue to pink (based off of 'cool')
                    AMPERE_latLongMapped = geoMap(AMPERE_long_portion,AMPERE_lat_portion); #convert the lat/long arcdeg to the current map coordinates
                    imAMP = ax[0].scatter(AMPERE_latLongMapped[0],AMPERE_latLongMapped[1],s=gif_Scatter_Point_Size_AMPERE,c=AMPERE_jouleHeating_portion,cmap=AMPERE_colorMap, vmin=np.min(AMPERE_plotLimValu), vmax=np.max(AMPERE_plotLimValu), zorder=7);
                    cbar2 = fig.colorbar(imAMP, cax=cax2, orientation='vertical'); #create a colorbar using the prev. defined cax
    #                cbar2.ax.set_yticklabels(np.linspace(np.min(AMPERE_plotLimValu),np.max(AMPERE_plotLimValu),5)); #create useful tick marks
                    if( gif_timeDelay == 1 ):
                        cbar2.set_label('AMPERE '+AMPERE_plot_labels[np.where(AMPERE_plot_index == AMPERE_plot_indexes)[0].item()]+' (Delayed by '+str(time_cutout_range_delay_AMPERE)+' hrs)'); #tabel the colorbar
                    else:
                        cbar2.set_label('AMPERE '+AMPERE_plot_labels[np.where(AMPERE_plot_index == AMPERE_plot_indexes)[0].item()]); #tabel the colorbar
                    #END IF
                    cbar2.ax.tick_params(labelsize=FONT_axisTick);
                    cbar2.mappable.set_clim(vmin=np.min(AMPERE_plotLimValu), vmax=np.max(AMPERE_plotLimValu));
                    if( np.all(np.mod(cbar2.get_ticks(),1) == 0) ):
                        cax2.yaxis.set_major_formatter(FormatStrFormatter('%.0f')); #force a rounded format
                    else:
                        cax2.yaxis.set_major_formatter(FormatStrFormatter('%.1f')); #force a rounded format
                    #END IF
                    cax2.yaxis.set_ticks_position('left'); #move it to the left
                    cax2.yaxis.set_label_position('left'); #move it to the left
                    
                    if( gif_dayNiteLine == 1 ):
                        fig.canvas.flush_events(); #this is req. to get get_window_extent() to get the current window size
                        #Plot the sunrise/sunset terminators
                        dayNite_temp = np.abs(dayNite_sunrise - (TEC_timeUnique[i]-dateRange_dayNum_zeroHr[1]*86400)) <= 10/3600; #gets the sunrise locations that are within 10 sec of the current TEC time (2 min had way too many hits, zigzags)
                        hLgd_FLG_day = np.sum(dayNite_temp); #plotting flag, shows when legend is active
                        #constants will use all the time - only for plotting of day/nite line so minor importance
                        #this stuff makes the text angle plotted mostly correct most of the time
                        bboxFig = fig.get_window_extent().transformed(fig.dpi_scale_trans.inverted()); #get the entire figure dimensions
                        bboxAx0 = ax[0].get_window_extent().transformed(fig.dpi_scale_trans.inverted()); #get the plot dimensions
    #                    plot_ratio = (bboxAx0.width/bboxAx0.height)/( (bboxAx0.width/bboxAx0.height)/(bboxFig.width/bboxFig.height) )**2; #get the plot ratio, will use it to fix up the angle
                        plot_ratio = (bboxAx0.width/bboxAx0.height); #get the plot ratio, will use it to fix up the angle
                        dayNite_textRotationLenOrig = 35; #length to go up and down the sunrise/sunset line to estimate an angle
                        dayNite_savgolFiltLenOrig = 101; #set it as a constant to start off
                        dayNite_textLatAbs = (np.max(plotLatRange)-np.min(plotLatRange))*.9 + np.min(plotLatRange); #calc like 80% of the max latitude
                        if( hLgd_FLG_day > 0 ): #only do work if it is there
                            #calc all that day/nite stuff in one function to keep it from getting cluttered
                            dayNite_Lat_line, dayNite_Long_line, dayNite_Lat_text, dayNite_Long_text, dayNite_textRotation = GRITI_movieMaker_subfun_dayniteCalc(0,np.sum(dayNite_temp),dayNite_Grid_Long[dayNite_temp],dayNite_Grid_Lat[dayNite_temp],dayNite_textLatAbs,plot_ratio,dayNite_savgolFiltLenOrig,dayNite_textRotationLenOrig);
                            dayNite_latLongMapped = geoMap(dayNite_Long_line,dayNite_Lat_line); #convert the lat/long arcdeg to the current map coordinates
                            imDayNite_day = ax[0].plot(dayNite_latLongMapped[0],dayNite_latLongMapped[1],color='g',linewidth=1.75,zorder=6); #plots a line to show the sunrise time
                            if( gif_dayNiteText == 1 ):
                                dayNite_latLongMapped = geoMap(dayNite_Long_text,dayNite_Lat_text); #convert the lat/long arcdeg to the current map coordinates
                                textDayNite_day = ax[0].text(dayNite_latLongMapped[0], dayNite_latLongMapped[1], "Sunrise", rotation=dayNite_textRotation, color='g', fontsize=FONT_axisTick, zorder=6);
                            #END IF
                        #END IF
                        
                        dayNite_temp = np.abs(dayNite_sunset - (TEC_timeUnique[i]-dateRange_dayNum_zeroHr[1]*86400)) <= 10/3600; #gets the sunset locations that are within 10 sec of the current TEC time (2 min had way too many hits, zigzags)
                        hLgd_FLG_nite = np.sum(dayNite_temp); #plotting flag, shows when legend is active
                        if( hLgd_FLG_nite > 0 ): #only do work if it is there
                            #calc all that day/nite stuff in one function to keep it from getting cluttered
                            dayNite_Lat_line, dayNite_Long_line, dayNite_Lat_text, dayNite_Long_text, dayNite_textRotation = GRITI_movieMaker_subfun_dayniteCalc(1,np.sum(dayNite_temp),dayNite_Grid_Long[dayNite_temp],dayNite_Grid_Lat[dayNite_temp],dayNite_textLatAbs,plot_ratio,dayNite_savgolFiltLenOrig,dayNite_textRotationLenOrig);
                            dayNite_latLongMapped = geoMap(dayNite_Long_line,dayNite_Lat_line); #convert the lat/long arcdeg to the current map coordinates
                            imDayNite_nite = ax[0].plot(dayNite_latLongMapped[0],dayNite_latLongMapped[1],color='b',linewidth=1.75,zorder=6); #plots a line to show the sunset time
                            if( gif_dayNiteText == 1 ):
                                dayNite_latLongMapped = geoMap(dayNite_Long_text,dayNite_Lat_text); #convert the lat/long arcdeg to the current map coordinates
                                textDayNite_nite = ax[0].text(dayNite_latLongMapped[0], dayNite_latLongMapped[1], "Sunset", rotation=dayNite_textRotation, color='b', fontsize=FONT_axisTick, zorder=6);
                            #EMD IF
                        #END IF
                    elif( gif_dayNiteLine == 2 ):
                        dayNite_currentDay = subfun_dayNum_to_date( np.array((dateRange_dayNum_zeroHr[0],np.int64(TEC_timeUnique[i])),ndmin=2))[0]; #get the current yr/month/day
                        dayNite_currentHr = np.int64((TEC_timeUnique[i]-np.int64(TEC_timeUnique[i]))*24); #hr, get the current hour
                        dayNite_currentMin = np.int64( ((TEC_timeUnique[i]-np.int64(TEC_timeUnique[i]))*24 - dayNite_currentHr)*60); #min, get the current min
                        dayNite_currentSec = np.int64( (((TEC_timeUnique[i]-np.int64(TEC_timeUnique[i]))*24 - dayNite_currentHr)*60 - dayNite_currentMin)*60); #min, get the current min
                        dayNite_currentTime = datetime.datetime(dayNite_currentDay[0], dayNite_currentDay[1], dayNite_currentDay[2], dayNite_currentHr, dayNite_currentMin,dayNite_currentSec);
                        dayNite_shade = geoMap.nightshade(dayNite_currentTime, color='k', delta=0.25, alpha=0.25, ax=ax[0], zorder=2);
                    #END IF
                    
                    #Now drawing point of interest
                    Millstone_latLongMapped = geoMap(longMillstone,latMillstone); #convert the lat/long arcdeg to the current map coordinates
                    imMillstone = ax[0].plot(Millstone_latLongMapped[0],Millstone_latLongMapped[1],marker=gif_Millstone_Marker, color=gif_Millstone_Marker_Color, markersize=gif_Millstone_Marker_Size, zorder=50); #plot this, 50 always on top
                    
                    if( geoMap_projectionStyle_polar >= 1 ):
                        if( gif_spin == 0):
#                            x = (1.05*0.5*np.sin(radRange_J2000[i]))+0.5; #geoMap coordinate 
#                            y = (1.05*0.5*np.cos(radRange_J2000[i]+np.pi))+0.5; #geoMap coordinate 
                            x = (1.05*0.5*np.cos(radRange_J2000[i]))+0.5; #geoMap coordinate 
                            y = (1.05*0.5*np.sin(radRange_J2000[i]))+0.5; #geoMap coordinate 
                            #hSun = ax[0].text(x,y,'SUN\N{DEGREE SIGN}',transform=ax[0].transAxes,horizontalalignment='center',verticalalignment='center',fontproperties=FONT_axisTickFM);
                            circleSun = plt.Circle((x, y), radius=0.015, color='xkcd:sun yellow', clip_on=False,transform=ax[0].transAxes); #make a sun figure
                            hSun = ax[0].add_artist(circleSun); #plot the sun
                        else:
                            hSun = ax[0].set_theta_offset(radRange_J2000[i]); #turn the whole plot so top is where the sun is
                            #I'm not sure if I can get this working easily - not a lot of optons.
                        #END IF
                    #END IF
                    
                    #------Now plot the keogram--------
                    pltHelprX, pltHelprY = np.meshgrid( (TEC_timeUnique - dateRange_dayNum_zeroHr[1]*86400), \
                                gif_avg_anyAngle_Range_Chunks_Long_Plot);
                    im = ax[1].pcolormesh(pltHelprX, pltHelprY,  gif_vTECChunked_keo.T ,vmin=np.min(gif_TEC_plotLimValu), vmax=np.max(gif_TEC_plotLimValu),cmap='jet'); # pseudocolor plot "stretched" to the grid
                    cbarKeo = fig.colorbar(im, cax=caxKeo, orientation='vertical'); #create a colorbar using the prev. defined cax
                    caxKeo.yaxis.set_ticks(np.linspace(np.min(gif_TEC_plotLimValu),np.max(gif_TEC_plotLimValu),5)); #create useful tick marks
                    caxKeo.yaxis.set_major_formatter(FormatStrFormatter('%.2f')); #force a rounded format
                    cbarKeo.set_label('delta-vTEC [TECU]'); #tabel the colorbar
                    cbarKeo.ax.tick_params(labelsize=FONT_axisTick);
                    cbarKeo.mappable.set_clim(vmin=np.min(gif_TEC_plotLimValu), vmax=np.max(gif_TEC_plotLimValu));
                    caxKeo.yaxis.label.set_font_properties(FONT_axisLabelFM);
                    
                    #    string_title = 'TEC Averaged on Angle of '+str(np.round(avg_anyAngle,2))+' deg and Width of '+ \
                    #        str(np.round(settings['TEC']['keo']['keo width'],2))+' arcdeg, Avg Step # = '+str(avg_anyAngle_N)+ \
                    #        ' arcdeg, Line Shows '+settings['TEC']['keo']['keo plot latlong name']+' of Millstone Hill Zenith Beam'; #create mecha title
                    string_title = 'delta-vTEC Keogram of '+gif_zoneName; #create mecha title
                    ax[1].set_title(string_title,fontproperties=FONT_titleFM); #set the title
                    ax[1].set_xlabel('Time in UT - 0 Hr on Day '+str(dateRange_dayNum_zeroHr[1])+', '+str(dateRange_dayNum_zeroHr[0])+' [hr]',fontproperties=FONT_axisLabelFM); #set the x axis label
                    ax[1].set_ylabel(gif_avg_anyAngle_Range_Chunks_Long_Plot_Name+' [arcdeg]',fontproperties=FONT_axisLabelFM); #set the y axis label
                    
                    xAxisTicks = np.arange( (np.round((np.min(TEC_timeUnique)-dateRange_dayNum_zeroHr[1]*86400)) - np.mod(np.round((np.min(TEC_timeUnique)-dateRange_dayNum_zeroHr[1]*86400)),2)) , \
                            (np.round((np.max(TEC_timeUnique)-dateRange_dayNum_zeroHr[1]*86400)) - np.mod(np.round((np.max(TEC_timeUnique)-dateRange_dayNum_zeroHr[1]*86400)),2)) + 2 , \
                            8); #sets the start hr, stop hr, and the step size between (in this case, 2 hr)
                    ax[1].set_xticks(xAxisTicks); #set x axis ticks
                    
                    avg_anyAngle_Range_Chunks_Long_Plot_autoTick = (np.ceil(np.max(gif_avg_anyAngle_Range_Chunks_Long_Plot)) - np.floor(np.min(gif_avg_anyAngle_Range_Chunks_Long_Plot)))/13; #tries to split the latitude range into 13 parts (based off of 180/15+1)
                    if( avg_anyAngle_Range_Chunks_Long_Plot_autoTick > 25 ):
                        avg_anyAngle_Range_Chunks_Long_Plot_autoTick = 30; #sets the tick setting to 15 arcdegrees per tick
                    elif( avg_anyAngle_Range_Chunks_Long_Plot_autoTick > 10 ):
                        avg_anyAngle_Range_Chunks_Long_Plot_autoTick = 15; #sets the tick setting to 15 arcdegrees per tick
                    elif( avg_anyAngle_Range_Chunks_Long_Plot_autoTick > 5 ):
                        avg_anyAngle_Range_Chunks_Long_Plot_autoTick = 10; #sets the tick setting to 10 arcdegrees per tick
                    elif( avg_anyAngle_Range_Chunks_Long_Plot_autoTick > 2 ):
                        avg_anyAngle_Range_Chunks_Long_Plot_autoTick = 5; #sets the tick setting to 5 arcdegrees per tick
                    elif( avg_anyAngle_Range_Chunks_Long_Plot_autoTick > 1 ):
                        avg_anyAngle_Range_Chunks_Long_Plot_autoTick = 2; #sets the tick setting to 5 arcdegrees per tick
                    elif( avg_anyAngle_Range_Chunks_Long_Plot_autoTick >= 0.6 ): #0.6 because 15/25 = 0.6, so there will be enough 1 arcdeg ticks
                        avg_anyAngle_Range_Chunks_Long_Plot_autoTick = 1; #                                                        sets the tick setting to 1 arcdegree per tick
                    else:
                        if(gif_avg_anyAngle_Range_Chunks_Long_Plot_Name == 'Latitude'): #if Y axis is latitude, use latitude
                            avg_anyAngle_Range_Chunks_Long_Plot_autoTick = (np.max(gif_plotLatRange) - np.min(gif_plotLatRange))/13; #just goes for it if it's a super tiny range
                        elif(gif_avg_anyAngle_Range_Chunks_Long_Plot_Name == 'Longitude'): #if Y axis is longitude, use longitude
                            avg_anyAngle_Range_Chunks_Long_Plot_autoTick = (np.max(gif_plotLongRange) - np.min(gif_plotLongRange))/13; #just goes for it if it's a super tiny range
                        #END IF
                    #END IF
                    yAxisTicks = np.round(np.arange( np.floor(np.min(gif_avg_anyAngle_Range_Chunks_Long_Plot)),np.ceil(np.max(gif_avg_anyAngle_Range_Chunks_Long_Plot))+avg_anyAngle_Range_Chunks_Long_Plot_autoTick,avg_anyAngle_Range_Chunks_Long_Plot_autoTick ),2); #creates y ticks automagically
                    ax[1].set_yticks(yAxisTicks); #set x axis ticks
                    ax[1].set_ylim( np.round(ax[1].get_ylim()) ); #avoid weird rounding errors
                    
                    #Now drawing line of interest
                    if( gif_avg_anyAngle_Range_Chunks_Long_Plot_Name == 'Longitude' ): #if true, longitude
                        if( (np.min(gif_plotLongRange) <= longMillstone) & (np.max(gif_plotLongRange) >= longMillstone) ): #only plot if it's in the long range specified
                            ax[1].plot( np.linspace(np.min((TEC_timeUnique - dateRange_dayNum_zeroHr[1]*86400)/3600),np.max((TEC_timeUnique - dateRange_dayNum_zeroHr[1]*86400)/3600),10,endpoint=True) , #X time hr
                                    np.tile(longMillstone,10) , #Y latitude OR longitude arcdeg
                                    c='xkcd:black',linewidth=1); #plots a point with a black line
                        #END IF
                    else: #else latitude
                        if( (np.min(gif_plotLatRange) <= latMillstone) & (np.max(gif_plotLatRange) >= latMillstone) ): #only plot if it's in the lat range specified
                            ax[1].plot( np.linspace(np.min((TEC_timeUnique - dateRange_dayNum_zeroHr[1]*86400)/3600),np.max((TEC_timeUnique - dateRange_dayNum_zeroHr[1]*86400)/3600),10,endpoint=True) , #X time hr
                                    np.tile(latMillstone,10) , #Y latitude OR longitude arcdeg
                                    c='xkcd:black',linewidth=1); #plots a point with a black line
                        #END IF
                    #END IF
                    
                    #-----plot vertical line showing the time on the keogram-----
                    hVline = ax[1].axvline( x=(TEC_timeUnique[i] - dateRange_dayNum_zeroHr[1]*86400) ,c='xkcd:black',linewidth=1, linestyle='--'); #plot a vertical line to show the current time
                    
                    #------Now plot the keogram2--------
                    pltHelprX, pltHelprY = np.meshgrid( (TEC_timeUnique - dateRange_dayNum_zeroHr[1]*86400), \
                                gif2_avg_anyAngle_Range_Chunks_Long_Plot);
                    imKeo2 = ax[2].pcolormesh(pltHelprX, pltHelprY,  gif2_vTECChunked_keo.T ,vmin=np.min(gif_TEC_plotLimValu), vmax=np.max(gif_TEC_plotLimValu),cmap='jet'); # pseudocolor plot "stretched" to the grid
                    cbarKeo2 = fig.colorbar(imKeo2, cax=caxKeo2, orientation='vertical'); #create a colorbar using the prev. defined cax
                    caxKeo2.yaxis.set_ticks(np.linspace(np.min(gif_TEC_plotLimValu),np.max(gif_TEC_plotLimValu),5)); #create useful tick marks
                    caxKeo2.yaxis.set_major_formatter(FormatStrFormatter('%.2f')); #force a rounded format
                    cbarKeo2.set_label('delta-vTEC [TECU]'); #tabel the colorbar
                    cbarKeo2.ax.tick_params(labelsize=FONT_axisTick);
                    cbarKeo2.mappable.set_clim(vmin=np.min(gif_TEC_plotLimValu), vmax=np.max(gif_TEC_plotLimValu));
                    caxKeo2.yaxis.label.set_font_properties(FONT_axisLabelFM);
                    
                    #    string_title = 'TEC Averaged on Angle of '+str(np.round(avg_anyAngle,2))+' deg and Width of '+ \
                    #        str(np.round(settings['TEC']['keo']['keo width'],2))+' arcdeg, Avg Step # = '+str(avg_anyAngle_N)+ \
                    #        ' arcdeg, Line Shows '+settings['TEC']['keo']['keo plot latlong name']+' of Millstone Hill Zenith Beam'; #create mecha title
                    string_title = 'delta-vTEC Keogram of '+gif2_zoneName; #create mecha title
                    ax[2].set_title(string_title,fontproperties=FONT_titleFM); #set the title
                    ax[2].set_xlabel('Time in UT - 0 Hr on Day '+str(dateRange_dayNum_zeroHr[1])+', '+str(dateRange_dayNum_zeroHr[0])+' [hr]',fontproperties=FONT_axisLabelFM); #set the x axis label
                    ax[2].set_ylabel(gif2_avg_anyAngle_Range_Chunks_Long_Plot_Name+' [arcdeg]',fontproperties=FONT_axisLabelFM); #set the y axis label
                    
                    xAxisTicks = np.arange( (np.round((np.min(TEC_timeUnique)-dateRange_dayNum_zeroHr[1]*86400)) - np.mod(np.round((np.min(TEC_timeUnique)-dateRange_dayNum_zeroHr[1]*86400)),2)) , \
                            (np.round((np.max(TEC_timeUnique)-dateRange_dayNum_zeroHr[1]*86400)) - np.mod(np.round((np.max(TEC_timeUnique)-dateRange_dayNum_zeroHr[1]*86400)),2)) + 2 , \
                            8); #sets the start hr, stop hr, and the step size between (in this case, 2 hr)
                    ax[2].set_xticks(xAxisTicks); #set x axis ticks
                    
                    avg_anyAngle_Range_Chunks_Long_Plot_autoTick = (np.ceil(np.max(gif2_avg_anyAngle_Range_Chunks_Long_Plot)) - np.floor(np.min(gif2_avg_anyAngle_Range_Chunks_Long_Plot)))/13; #tries to split the latitude range into 13 parts (based off of 180/15+1)
                    if( avg_anyAngle_Range_Chunks_Long_Plot_autoTick > 25 ):
                        avg_anyAngle_Range_Chunks_Long_Plot_autoTick = 30; #sets the tick setting to 15 arcdegrees per tick
                    elif( avg_anyAngle_Range_Chunks_Long_Plot_autoTick > 10 ):
                        avg_anyAngle_Range_Chunks_Long_Plot_autoTick = 15; #sets the tick setting to 15 arcdegrees per tick
                    elif( avg_anyAngle_Range_Chunks_Long_Plot_autoTick > 5 ):
                        avg_anyAngle_Range_Chunks_Long_Plot_autoTick = 10; #sets the tick setting to 10 arcdegrees per tick
                    elif( avg_anyAngle_Range_Chunks_Long_Plot_autoTick > 2 ):
                        avg_anyAngle_Range_Chunks_Long_Plot_autoTick = 5; #sets the tick setting to 5 arcdegrees per tick
                    elif( avg_anyAngle_Range_Chunks_Long_Plot_autoTick > 1 ):
                        avg_anyAngle_Range_Chunks_Long_Plot_autoTick = 2; #sets the tick setting to 5 arcdegrees per tick
                    elif( avg_anyAngle_Range_Chunks_Long_Plot_autoTick >= 0.6 ): #0.6 because 15/25 = 0.6, so there will be enough 1 arcdeg ticks
                        avg_anyAngle_Range_Chunks_Long_Plot_autoTick = 1; #                                                        sets the tick setting to 1 arcdegree per tick
                    else:
                        if(gif2_avg_anyAngle_Range_Chunks_Long_Plot_Name == 'Latitude'): #if Y axis is latitude, use latitude
                            avg_anyAngle_Range_Chunks_Long_Plot_autoTick = (np.max(gif2_plotLatRange) - np.min(gif2_plotLatRange))/13; #just goes for it if it's a super tiny range
                        elif(gif2_avg_anyAngle_Range_Chunks_Long_Plot_Name == 'Longitude'): #if Y axis is longitude, use longitude
                            avg_anyAngle_Range_Chunks_Long_Plot_autoTick = (np.max(gif2_plotLongRange) - np.min(gif2_plotLongRange))/13; #just goes for it if it's a super tiny range
                        #END IF
                    #END IF
                    yAxisTicks = np.round(np.arange( np.floor(np.min(gif2_avg_anyAngle_Range_Chunks_Long_Plot)),np.ceil(np.max(gif2_avg_anyAngle_Range_Chunks_Long_Plot))+avg_anyAngle_Range_Chunks_Long_Plot_autoTick,avg_anyAngle_Range_Chunks_Long_Plot_autoTick ),2); #creates y ticks automagically
                    ax[2].set_yticks(yAxisTicks); #set x axis ticks
                    ax[2].set_ylim( np.round(ax[2].get_ylim()) ); #avoid weird rounding errors
                    
                    #Now drawing line of interest
                    if( gif2_avg_anyAngle_Range_Chunks_Long_Plot_Name == 'Longitude' ): #if true, longitude
                        if( (np.min(gif2_plotLongRange) <= longMillstone) & (np.max(gif2_plotLongRange) >= longMillstone) ): #only plot if it's in the long range specified
                            ax[2].plot( np.linspace(np.min((TEC_timeUnique - dateRange_dayNum_zeroHr[1]*86400)/3600),np.max((TEC_timeUnique - dateRange_dayNum_zeroHr[1]*86400)/3600),10,endpoint=True) , #X time hr
                                    np.tile(longMillstone,10) , #Y latitude OR longitude arcdeg
                                    c='xkcd:black',linewidth=1); #plots a point with a black line
                        #END IF
                    else: #else latitude
                        if( (np.min(gif2_plotLatRange) <= latMillstone) & (np.max(gif2_plotLatRange) >= latMillstone) ): #only plot if it's in the lat range specified
                            ax[2].plot( np.linspace(np.min((TEC_timeUnique - dateRange_dayNum_zeroHr[1]*86400)/3600),np.max((TEC_timeUnique - dateRange_dayNum_zeroHr[1]*86400)/3600),10,endpoint=True) , #X time hr
                                    np.tile(latMillstone,10) , #Y latitude OR longitude arcdeg
                                    c='xkcd:black',linewidth=1); #plots a point with a black line
                        #END IF
                    #END IF
                    
                    #-----plot vertical line showing the time on the keogram2-----
                    hVline2 = ax[2].axvline( x=(TEC_timeUnique[i] - dateRange_dayNum_zeroHr[1]*86400) ,c='xkcd:black',linewidth=1, linestyle='--'); #plot a vertical line to show the current time
                    
                else:
                    #Just plotting now - prep done, hopefully speeds it!
                    #Do the TEC plotting
                    pltHelprX, pltHelprY = np.meshgrid( gif_Grid_Long, gif_Grid_Lat); #helps the pcolor work
                    TEC_latLongMapped = geoMap(pltHelprX,pltHelprY); #convert the lat/long arcdeg to the current map coordinates
                    imTEC = ax[0].pcolormesh(TEC_latLongMapped[0], TEC_latLongMapped[1],  gif_Grid.T ,vmin=-TEC_plotLimValu, vmax=TEC_plotLimValu,cmap='jet',zorder=5); # pseudocolor plot "stretched" to the grid
    
                    #Do the AMPERE plotting
                    AMPERE_latLongMapped = geoMap(AMPERE_long_portion,AMPERE_lat_portion); #convert the lat/long arcdeg to the current map coordinates
                    imAMP = ax[0].scatter(AMPERE_latLongMapped[0],AMPERE_latLongMapped[1],s=gif_Scatter_Point_Size_AMPERE,c=AMPERE_jouleHeating_portion,cmap=AMPERE_colorMap, vmin=np.min(AMPERE_plotLimValu), vmax=np.max(AMPERE_plotLimValu), zorder=7);
                    
                    if( gif_dayNiteLine == 1 ):
                        #Plot the sunrise/sunset terminators
                        dayNite_temp = np.abs(dayNite_sunrise - (TEC_timeUnique[i]-dateRange_dayNum_zeroHr[1]*86400)) <= 10/3600; #gets the sunrise locations that are within 10 sec of the current TEC time (2 min had way too many hits, zigzags)
                        hLgd_FLG_day = np.sum(dayNite_temp); #plotting flag, shows when legend is active
                        if( hLgd_FLG_day > 0 ): #only do work if it is there
                            #calc all that day/nite stuff in one function to keep it from getting cluttered
                            dayNite_Lat_line, dayNite_Long_line, dayNite_Lat_text, dayNite_Long_text, dayNite_textRotation = GRITI_movieMaker_subfun_dayniteCalc(0,np.sum(dayNite_temp),dayNite_Grid_Long[dayNite_temp],dayNite_Grid_Lat[dayNite_temp],dayNite_textLatAbs,plot_ratio,dayNite_savgolFiltLenOrig,dayNite_textRotationLenOrig);
                            dayNite_latLongMapped = geoMap(dayNite_Long_line,dayNite_Lat_line); #convert the lat/long arcdeg to the current map coordinates
                            imDayNite_day = ax[0].plot(dayNite_latLongMapped[0],dayNite_latLongMapped[1],color='g',linewidth=1.75,zorder=6); #plots a line to show the sunrise time
                            if( gif_dayNiteText == 1 ):
                                dayNite_latLongMapped = geoMap(dayNite_Long_text,dayNite_Lat_text); #convert the lat/long arcdeg to the current map coordinates
                                textDayNite_day = ax[0].text(dayNite_latLongMapped[0], dayNite_latLongMapped[1], "Sunrise", rotation=dayNite_textRotation, color='g', fontsize=FONT_axisTick, zorder=6);
                            #END IF
                        #END IF
                        
                        dayNite_temp = np.abs(dayNite_sunset - (TEC_timeUnique[i]-dateRange_dayNum_zeroHr[1]*86400)) <= 10/3600; #gets the sunset locations that are within 10 sec of the current TEC time (2 min had way too many hits, zigzags)
                        hLgd_FLG_nite = np.sum(dayNite_temp); #plotting flag, shows when legend is active
                        if( hLgd_FLG_nite > 0 ): #only do work if it is there
                            #calc all that day/nite stuff in one function to keep it from getting cluttered
                            dayNite_Lat_line, dayNite_Long_line, dayNite_Lat_text, dayNite_Long_text, dayNite_textRotation = GRITI_movieMaker_subfun_dayniteCalc(1,np.sum(dayNite_temp),dayNite_Grid_Long[dayNite_temp],dayNite_Grid_Lat[dayNite_temp],dayNite_textLatAbs,plot_ratio,dayNite_savgolFiltLenOrig,dayNite_textRotationLenOrig);
                            dayNite_latLongMapped = geoMap(dayNite_Long_line,dayNite_Lat_line); #convert the lat/long arcdeg to the current map coordinates
                            imDayNite_nite = ax[0].plot(dayNite_latLongMapped[0],dayNite_latLongMapped[1],color='b',linewidth=1.75,zorder=6); #plots a line to show the sunset time
                            if( gif_dayNiteText == 1 ):
                                dayNite_latLongMapped = geoMap(dayNite_Long_text,dayNite_Lat_text); #convert the lat/long arcdeg to the current map coordinates
                                textDayNite_nite = ax[0].text(dayNite_latLongMapped[0], dayNite_latLongMapped[1], "Sunset", rotation=dayNite_textRotation, color='b', fontsize=FONT_axisTick, zorder=6);
                            #END IF
                        #END IF
                    elif( gif_dayNiteLine == 2 ):
                        dayNite_currentDay = subfun_dayNum_to_date( np.array((dateRange_dayNum_zeroHr[0],np.int64(TEC_timeUnique[i])),ndmin=2))[0]; #get the current yr/month/day
                        dayNite_currentHr = np.int64((TEC_timeUnique[i]-np.int64(TEC_timeUnique[i]))*24); #hr, get the current hour
                        dayNite_currentMin = np.int64( ((TEC_timeUnique[i]-np.int64(TEC_timeUnique[i]))*24 - dayNite_currentHr)*60); #min, get the current min
                        dayNite_currentSec = np.int64( (((TEC_timeUnique[i]-np.int64(TEC_timeUnique[i]))*24 - dayNite_currentHr)*60 - dayNite_currentMin)*60); #min, get the current min
                        dayNite_currentTime = datetime.datetime(dayNite_currentDay[0], dayNite_currentDay[1], dayNite_currentDay[2], dayNite_currentHr, dayNite_currentMin,dayNite_currentSec);
                        dayNite_shade = geoMap.nightshade(dayNite_currentTime, color='k', delta=0.25, alpha=0.25, ax=ax[0], zorder=2);
                    #END IF
                    
                    if( geoMap_projectionStyle_polar >= 1 ):
                        if( gif_spin == 0):
#                            x = (1.05*0.5*np.sin(radRange_J2000[i]))+0.5; #geoMap coordinate 
#                            y = (1.05*0.5*np.cos(radRange_J2000[i]+np.pi))+0.5; #geoMap coordinate 
                            x = (1.05*0.5*np.cos(radRange_J2000[i]))+0.5; #geoMap coordinate 
                            y = (1.05*0.5*np.sin(radRange_J2000[i]))+0.5; #geoMap coordinate 
                            #hSun = ax.text(x,y,'SUN\N{DEGREE SIGN}',transform=ax.transAxes,horizontalalignment='center',verticalalignment='center',fontproperties=FONT_axisTickFM);
                            circleSun = plt.Circle((x, y), radius=0.015, color='xkcd:sun yellow', clip_on=False,transform=ax[0].transAxes); #make a sun figure
                            hSun = ax[0].add_artist(circleSun); #plot the sun
                        else:
                            hSun = ax[0].set_theta_offset(radRange_J2000[i]); #turn the whole plot so top is where the sun is
                            #I'm not sure if I can get this working easily - not a lot of optons.
                        #END IF
                    #END IF
                    
                    #----plot vertical line showing the time on the keogram-----
                    hVline = ax[1].axvline( x=(TEC_timeUnique[i] - dateRange_dayNum_zeroHr[1]*86400) ,c='xkcd:black',linewidth=1, linestyle='--'); #plot a vertical line to show the current time
                    
                    #----plot vertical line showing the time on the keogram2-----
                    hVline2 = ax[2].axvline( x=(TEC_timeUnique[i] - dateRange_dayNum_zeroHr[1]*86400) ,c='xkcd:black',linewidth=1, linestyle='--'); #plot a vertical line to show the current time
                #END IF
                
                #Dynamically show and hide the day/nite labels
    #            if( (hLgd_FLG_day > 0) & (hLgd_FLG_nite > 0) ):
    #                hLgd = ax.legend( (imDayNite_day , imDayNite_nite) , ('Sunrise','Sunset') , loc=4 , fontsize = FONT_axisTick ); #make that legend
    #            elif( (hLgd_FLG_day > 0) & (hLgd_FLG_nite == 0) ):
    #                hLgd = ax.legend( (imDayNite_day) , ('Sunrise') , loc=4 , fontsize = FONT_axisTick , handlelength=.75 ); #make that legend
    #            elif( (hLgd_FLG_day == 0) & (hLgd_FLG_nite > 0) ):
    #                hLgd = ax.legend( (imDayNite_nite,) , ('Sunset',) , loc=4 , fontsize = FONT_axisTick ); #make that legend
    #            #END IF
            
                #-----------------------Create Movie/GIF---------------------------
                #Makes the gif now
                plt.draw();
                gif_writer.grab_frame(); #get the frame and save it
                    
                #-------------------Clean up for re-use----------------------------
                #if forget one (like hOverlay) slows it way down after many plots
                imTEC.remove();
                imAMP.remove();
                hVline.remove();
                hVline2.remove();
                if( gif_dayNiteLine == 1 ):
                    if(hLgd_FLG_day > 0): #only delete if it is there
                        imDayNite_day.pop(0).remove();
                        if( gif_dayNiteText == 1 ):
                            textDayNite_day.remove();
                        #END IF
                    #END IF
                    if(hLgd_FLG_nite > 0): #only delete if it is there
                        imDayNite_nite.pop(0).remove();
                        if( gif_dayNiteText == 1 ):
                            textDayNite_nite.remove();
                        #END IF
                    #END IF
                elif( gif_dayNiteLine == 2): #only delete if it is there
                    for middleman in dayNite_shade.collections: #this needs an extra helping hand
                        middleman.remove();
                #END IF
                if( geoMap_projectionStyle_polar >= 1 ): #only delete if it is there
                    hSun.remove();
                #END IF
                
            #END FOR i
        #END WITH
        
    elif(gif_Type == 8): #stationary data points (through averaging) + OMNI overlay
            
        with gif_writer.saving(fig, gif_Name, gif_PPI): #figure to save, file name, and PPI (DPI in documentation)
            
            #-------------------------OMNI prep stuff-------------------------
            OMNI_timeUnique_hr = (OMNI_timeUnique - dateRange_dayNum_zeroHr[1]*86400); #hr, convert to hr with 0 hr at specified day
            
            #-------------------------Start Making Pictures------------------------
            for i in range(0,TEC_timeUnique.size):
                
                #----------------Corral the data to the right place----------------
                k =  np.where( data['TEC']['time'] == TEC_timeUnique[i])[0]; #gets during a time period
                vTEC_portion = data['TEC']['dTEC'][k]; #pull out the vTEC now
                pplat_portion = data['TEC']['lat'][k]; #get the pplat (pierce-point lat) at the time required
                pplong_portion = data['TEC']['long'][k]; #get the pplong (pierce-point long) at the time required
                            
                gif_Grid = GRITI_movieMaker_subfun_dataGridder(pplat_portion,pplong_portion,vTEC_portion,gif_Grid_Lat,gif_Grid_Long,gif_Grid_Lat_Spaces,gif_Grid_Long_Spaces,gif_Grid_Lat_Delta,gif_Grid_Long_Delta,dataRejectOrig,dataRejectLimitOrig,dataRejectMax);
                #call a numba'd function that makes the movie quicker by crunching the numbers gooder
                
                #----------------------------Tack on Title-------------------------
                string_title = 'TEC Global Plot, Time =  '+'{0:.2f}'.format(np.round((TEC_timeUnique[i]-dateRange_dayNum_zeroHr[1]*86400),2))+\
                    ', 0 UT on '+dateRange_zeroHr_monthName+' '+str(dateRange_zeroHr[2])+', '+str(dateRange_dayNum_zeroHr[0]); #create mecha title
                
                ax[0].set_title(string_title,fontproperties=FONT_titleFM); #set the title, properties always needed
                                
                #-------------------Starting the Plotting--------------------------
                if( i == 0 ): #first run preps axes, color bars, etc.
                                                   
                    #Do the TEC plotting
                    pltHelprX, pltHelprY = np.meshgrid( gif_Grid_Long, gif_Grid_Lat); #helps the pcolor work
                    TEC_latLongMapped = geoMap(pltHelprX,pltHelprY); #convert the lat/long arcdeg to the current map coordinates
                    imTEC = ax[0].pcolormesh(TEC_latLongMapped[0], TEC_latLongMapped[1],  gif_Grid.T ,vmin=-TEC_plotLimValu, vmax=TEC_plotLimValu,cmap='jet',zorder=5); # pseudocolor plot "stretched" to the grid
                    cbar = fig.colorbar(imTEC, cax=cax, orientation='vertical'); #create a colorbar using the prev. defined cax
                    cax.yaxis.set_ticks(np.linspace(-TEC_plotLimValu,TEC_plotLimValu,5)); #create useful tick marks
                    cax.yaxis.set_major_formatter(FormatStrFormatter('%.2f')); #force a rounded format
                    cbar.set_label("delta-vTEC [TECU]"); #tabel the colorbar
                    cbar.ax.tick_params(labelsize=FONT_axisTick);
                    cbar.mappable.set_clim(vmin=-TEC_plotLimValu, vmax=TEC_plotLimValu);
    
                    #Do the OMNI plotting
                    imOMNI = ax[1].plot( OMNI_timeUnique_hr, OMNI_data[:,OMNI_dict[OMNI_plot_scargle_name]], linewidth=0.8 , zorder=1); #plot
            
                    if( np.mod(np.round(np.min(OMNI_timeUnique_hr)),2) == 0 ):
                        OMNI_time_hr_axis_min = np.round(np.min(OMNI_timeUnique_hr)); #is even, good to go
                    else:
                        OMNI_time_hr_axis_min = np.round(np.min(OMNI_timeUnique_hr))+1; #is odd, make even
                    #END IF
                    if( np.mod(np.round(np.max(OMNI_timeUnique_hr)),2) == 0 ):
                        OMNI_time_hr_axis_max = np.round(np.max(OMNI_timeUnique_hr)); #is even, good to go
                    else:
                        OMNI_time_hr_axis_max = np.round(np.max(OMNI_timeUnique_hr))-1; #is odd, make even
                    #END IF
                    
                    xAxisTicks = np.arange(OMNI_time_hr_axis_min,OMNI_time_hr_axis_max+4,4); #sets the start hr, stop hr, and the step size between (in this case, 4 hr)
                    ax[1].set_xticks(xAxisTicks); #set x axis ticks
                    ax[1].set_xlim( OMNI_time_hr_axis_min , OMNI_time_hr_axis_max ); #set y axis limits
                    ax[1].set_ylabel(OMNI_dictPlot[OMNI_dict[OMNI_plot_scargle_name]],fontproperties=FONT_axisLabelFM); #set the y axis label
                    ax[1].set_ylim( np.min(OMNI_data[:,OMNI_dict[OMNI_plot_scargle_name]]) , np.max(OMNI_data[:,OMNI_dict[OMNI_plot_scargle_name]]) ); #set y axis limits
                    ax[1].grid(b=True, which='major', axis='both', color='xkcd:light grey'); #sets major axis grid lines to be on
                    
                    #tack on 2nd title that doesn't change
                    OMNI_plot_scargle_label = OMNI_dictPlot[OMNI_dict[OMNI_plot_scargle_name]]; #get the label
                    OMNI_plot_scargle_labelNoUnits = OMNI_plot_scargle_label[0:OMNI_plot_scargle_label.find('(')-1]; #remove the (units)
                    string_title = 'OMNI '+OMNI_plot_scargle_labelNoUnits+' Index'; #create mecha title
                
                    ax[1].set_title(string_title,fontproperties=FONT_titleFM); #set the title
                    ax[1].set_xlabel(subfun_monthNum_to_word(dateRange[0,1])[0]+" "+str(dateRange[0,2])+" (Day "+str(dateRange_dayNum[0,1])+"), "+str(dateRange[0,0])+" to "+subfun_monthNum_to_word(dateRange[1,1])[0]+" "+str(dateRange[1,2])+" (Day "+str(dateRange_dayNum[0,1])+"), "+str(dateRange[1,0]),fontproperties=FONT_axisLabelFM); #set the x axis label                
                    
                    #Draw time line on bottom OMNI plot
                    OMNI_data_min = np.min(OMNI_data[:,OMNI_dict[OMNI_plot_scargle_name]]); #pre-calc the min
                    OMNI_data_max = np.max(OMNI_data[:,OMNI_dict[OMNI_plot_scargle_name]]); #pre-calc the max
                    imOMNILine = ax[1].plot( np.array(( (TEC_timeUnique[i]-dateRange_dayNum_zeroHr[1]*86400) , (TEC_timeUnique[i]-dateRange_dayNum_zeroHr[1]*86400) )) , np.array(( OMNI_data_min,OMNI_data_max)) , color=gif_Millstone_Marker_Color , zorder = 10);
                    
                    if( gif_dayNiteLine == 1 ):
                        fig.canvas.flush_events(); #this is req. to get get_window_extent() to get the current window size
                        #Plot the sunrise/sunset terminators
                        dayNite_temp = np.abs(dayNite_sunrise - (TEC_timeUnique[i]-dateRange_dayNum_zeroHr[1]*86400)) <= 10/3600; #gets the sunrise locations that are within 10 sec of the current TEC time (2 min had way too many hits, zigzags)
                        hLgd_FLG_day = np.sum(dayNite_temp); #plotting flag, shows when legend is active
                        #constants will use all the time - only for plotting of day/nite line so minor importance
                        
                        #this stuff makes the text angle plotted mostly correct most of the time
                        bboxFig = fig.get_window_extent().transformed(fig.dpi_scale_trans.inverted()); #get the entire figure dimensions
                        bboxAx0 = ax[0].get_window_extent().transformed(fig.dpi_scale_trans.inverted()); #get the plot dimensions
    #                    plot_ratio = (bboxAx0.width/bboxAx0.height)/( (bboxAx0.width/bboxAx0.height)/(bboxFig.width/bboxFig.height) )**2; #get the plot ratio, will use it to fix up the angle
                        plot_ratio = (bboxAx0.width/bboxAx0.height); #get the plot ratio, will use it to fix up the angle
                        
                        dayNite_textRotationLenOrig = 35; #length to go up and down the sunrise/sunset line to estimate an angle
                        dayNite_savgolFiltLenOrig = 101; #set it as a constant to start off
                        dayNite_textLatAbs = (np.max(plotLatRange)-np.min(plotLatRange))*.9 + np.min(plotLatRange); #calc like 80% of the max latitude
                        if( hLgd_FLG_day > 0 ): #only do work if it is there
                            #calc all that day/nite stuff in one function to keep it from getting cluttered
                            dayNite_Lat_line, dayNite_Long_line, dayNite_Lat_text, dayNite_Long_text, dayNite_textRotation = GRITI_movieMaker_subfun_dayniteCalc(0,np.sum(dayNite_temp),dayNite_Grid_Long[dayNite_temp],dayNite_Grid_Lat[dayNite_temp],dayNite_textLatAbs,plot_ratio,dayNite_savgolFiltLenOrig,dayNite_textRotationLenOrig);
                            dayNite_latLongMapped = geoMap(dayNite_Long_line,dayNite_Lat_line); #convert the lat/long arcdeg to the current map coordinates
                            imDayNite_day = ax[0].plot(dayNite_latLongMapped[0],dayNite_latLongMapped[1],color='g',linewidth=1.75,zorder=6); #plots a line to show the sunrise time
                            if( gif_dayNiteText == 1 ):
                                dayNite_latLongMapped = geoMap(dayNite_Long_text,dayNite_Lat_text); #convert the lat/long arcdeg to the current map coordinates
                                textDayNite_day = ax[0].text(dayNite_latLongMapped[0], dayNite_latLongMapped[1], "Sunrise", rotation=dayNite_textRotation, color='g', fontsize=FONT_axisTick, zorder=6);
                            #END IF
                        #END IF
                        
                        dayNite_temp = np.abs(dayNite_sunset - (TEC_timeUnique[i]-dateRange_dayNum_zeroHr[1]*86400)) <= 10/3600; #gets the sunset locations that are within 10 sec of the current TEC time (2 min had way too many hits, zigzags)
                        hLgd_FLG_nite = np.sum(dayNite_temp); #plotting flag, shows when legend is active
                        if( hLgd_FLG_nite > 0 ): #only do work if it is there
                            #calc all that day/nite stuff in one function to keep it from getting cluttered
                            dayNite_Lat_line, dayNite_Long_line, dayNite_Lat_text, dayNite_Long_text, dayNite_textRotation = GRITI_movieMaker_subfun_dayniteCalc(1,np.sum(dayNite_temp),dayNite_Grid_Long[dayNite_temp],dayNite_Grid_Lat[dayNite_temp],dayNite_textLatAbs,plot_ratio,dayNite_savgolFiltLenOrig,dayNite_textRotationLenOrig);
                            dayNite_latLongMapped = geoMap(dayNite_Long_line,dayNite_Lat_line); #convert the lat/long arcdeg to the current map coordinates
                            imDayNite_nite = ax[0].plot(dayNite_latLongMapped[0],dayNite_latLongMapped[1],color='b',linewidth=1.75,zorder=6); #plots a line to show the sunset time
                            if( gif_dayNiteText == 1 ):
                                dayNite_latLongMapped = geoMap(dayNite_Long_text,dayNite_Lat_text); #convert the lat/long arcdeg to the current map coordinates
                                textDayNite_nite = ax[0].text(dayNite_latLongMapped[0], dayNite_latLongMapped[1], "Sunset", rotation=dayNite_textRotation, color='b', fontsize=FONT_axisTick, zorder=6);
                            #EMD IF
                        #END IF
                    #END IF
                    
                    #Now drawing line of interest               
                    Millstone_latLongMapped = geoMap(longMillstone,latMillstone); #convert the lat/long arcdeg to the current map coordinates
                    imMillstone = ax[0].plot(Millstone_latLongMapped[0],Millstone_latLongMapped[1],marker=gif_Millstone_Marker, color=gif_Millstone_Marker_Color, markersize=gif_Millstone_Marker_Size, zorder=50); #plot this, 50 always on top
                                    
                else:
                    #Just plotting now - prep done, hopefully speeds it!
                    #Do the TEC plotting
                    pltHelprX, pltHelprY = np.meshgrid( gif_Grid_Long, gif_Grid_Lat); #helps the pcolor work
                    TEC_latLongMapped = geoMap(pltHelprX,pltHelprY); #convert the lat/long arcdeg to the current map coordinates
                    imTEC = ax[0].pcolormesh(TEC_latLongMapped[0], TEC_latLongMapped[1],  gif_Grid.T ,vmin=-TEC_plotLimValu, vmax=TEC_plotLimValu,cmap='jet',zorder=5); # pseudocolor plot "stretched" to the grid
    
                    #Draw time line on bottom OMNI plot
                    imOMNILine = ax[1].plot( np.array(( (TEC_timeUnique[i]-dateRange_dayNum_zeroHr[1]*86400) , (TEC_timeUnique[i]-dateRange_dayNum_zeroHr[1]*86400) )) , np.array(( OMNI_data_min,OMNI_data_max)) , color=gif_Millstone_Marker_Color , zorder = 10);
                    
                    if( gif_dayNiteLine == 1 ):
                        #Plot the sunrise/sunset terminators
                        dayNite_temp = np.abs(dayNite_sunrise - (TEC_timeUnique[i]-dateRange_dayNum_zeroHr[1]*86400)) <= 10/3600; #gets the sunrise locations that are within 10 sec of the current TEC time (2 min had way too many hits, zigzags)
                        hLgd_FLG_day = np.sum(dayNite_temp); #plotting flag, shows when legend is active
                        if( hLgd_FLG_day > 0 ): #only do work if it is there
                            #calc all that day/nite stuff in one function to keep it from getting cluttered
                            dayNite_Lat_line, dayNite_Long_line, dayNite_Lat_text, dayNite_Long_text, dayNite_textRotation = GRITI_movieMaker_subfun_dayniteCalc(0,np.sum(dayNite_temp),dayNite_Grid_Long[dayNite_temp],dayNite_Grid_Lat[dayNite_temp],dayNite_textLatAbs,plot_ratio,dayNite_savgolFiltLenOrig,dayNite_textRotationLenOrig);
                            dayNite_latLongMapped = geoMap(dayNite_Long_line,dayNite_Lat_line); #convert the lat/long arcdeg to the current map coordinates
                            imDayNite_day = ax[0].plot(dayNite_latLongMapped[0],dayNite_latLongMapped[1],color='g',linewidth=1.75,zorder=6); #plots a line to show the sunrise time
                            if( gif_dayNiteText == 1 ):
                                dayNite_latLongMapped = geoMap(dayNite_Long_text,dayNite_Lat_text); #convert the lat/long arcdeg to the current map coordinates
                                textDayNite_day = ax[0].text(dayNite_latLongMapped[0], dayNite_latLongMapped[1], "Sunrise", rotation=dayNite_textRotation, color='g', fontsize=FONT_axisTick, zorder=6);
                            #END IF
                        #END IF
                        
                        dayNite_temp = np.abs(dayNite_sunset - (TEC_timeUnique[i]-dateRange_dayNum_zeroHr[1]*86400)) <= 10/3600; #gets the sunset locations that are within 10 sec of the current TEC time (2 min had way too many hits, zigzags)
                        hLgd_FLG_nite = np.sum(dayNite_temp); #plotting flag, shows when legend is active
                        if( hLgd_FLG_nite > 0 ): #only do work if it is there
                            #calc all that day/nite stuff in one function to keep it from getting cluttered
                            dayNite_Lat_line, dayNite_Long_line, dayNite_Lat_text, dayNite_Long_text, dayNite_textRotation = GRITI_movieMaker_subfun_dayniteCalc(1,np.sum(dayNite_temp),dayNite_Grid_Long[dayNite_temp],dayNite_Grid_Lat[dayNite_temp],dayNite_textLatAbs,plot_ratio,dayNite_savgolFiltLenOrig,dayNite_textRotationLenOrig);
                            dayNite_latLongMapped = geoMap(dayNite_Long_line,dayNite_Lat_line); #convert the lat/long arcdeg to the current map coordinates
                            imDayNite_nite = ax[0].plot(dayNite_latLongMapped[0],dayNite_latLongMapped[1],color='b',linewidth=1.75,zorder=6); #plots a line to show the sunset time
                            if( gif_dayNiteText == 1 ):
                                dayNite_latLongMapped = geoMap(dayNite_Long_text,dayNite_Lat_text); #convert the lat/long arcdeg to the current map coordinates
                                textDayNite_nite = ax[0].text(dayNite_latLongMapped[0], dayNite_latLongMapped[1], "Sunset", rotation=dayNite_textRotation, color='b', fontsize=FONT_axisTick, zorder=6);
                            #END IF
                        #END IF
                    #END IF
                    
                #END IF
            
                #-----------------------Create Movie/GIF---------------------------
                #Makes the gif now
                plt.draw();
                
                gif_writer.grab_frame(); #get the frame and save it
                            
                #-------------------Clean up for re-use----------------------------
                #if forget one (like hOverlay) slows it way down after many plots
                imTEC.remove();
                imOMNILine.pop(0).remove();
    #            imOverlay.pop(0).remove();
    #            imMillstone.pop(0).remove();
                if( gif_dayNiteLine == 1 ):
                    if(hLgd_FLG_day > 0): #only delete if it is there
                        imDayNite_day.pop(0).remove();
                        if( gif_dayNiteText == 1 ):
                            textDayNite_day.remove();
                        #END IF
                    #END IF
                    if(hLgd_FLG_nite > 0): #only delete if it is there
                        imDayNite_nite.pop(0).remove();
                        if( gif_dayNiteText == 1 ):
                            textDayNite_nite.remove();
                        #END IF
                    #END IF
                #END IF
                
            #END FOR i
        #END WITH
    
    elif(gif_Type == 9): #stationary data points (through averaging) + AMPERE data on same plot (no time average for TEC) + OMNI overlay
        
        AMPERE_dataRate = np.median(np.diff(AMPERE_timeUnique)); #days, get the median data rate for AMPERE data (avoids outliers)
        with gif_writer.saving(fig, gif_Name, gif_PPI): #figure to save, file name, and PPI (DPI in documentation)
            
            #-------------------------OMNI prep stuff-------------------------
            OMNI_timeUnique_hr = (OMNI_timeUnique - dateRange_dayNum_zeroHr[1]*86400); #hr, convert to hr with 0 hr at specified day
            
            #-------------------------Start Making Pictures------------------------
            for i in range(0,TEC_timeUnique.size):
                
                #------------Corral the AMPERE data to the right place-------------
                k = np.where( (data['AMPERE']['time'] <= TEC_timeUnique[i]) & (data['AMPERE']['time'] >= (TEC_timeUnique[i]-AMPERE_dataRate)) )[0]; #get where the time point is, make sure it is within the data rate window
                AMPERE_jouleHeating_portion = AMPERE_data[k,locAMPERE_jouleHeating]; #ergs/(cm^2*sec), get the Joule Heating for the current time step
                AMPERE_lat_portion = AMPERE_data[k,locAMPERE_lat]; #degc, corresponding lat values
                AMPERE_long_portion = AMPERE_data[k,locAMPERE_long]; #degc, corresponding long values
                
                #----------------Corral the data to the right place----------------
                k =  np.where( data['TEC']['time'] == TEC_timeUnique[i])[0]; #gets during a time period
                vTEC_portion = data['TEC']['dTEC'][k]; #pull out the vTEC now
                pplat_portion = data['TEC']['lat'][k]; #get the pplat (pierce-point lat) at the time required
                pplong_portion = data['TEC']['long'][k]; #get the pplong (pierce-point long) at the time required
                            
                gif_Grid = GRITI_movieMaker_subfun_dataGridder(pplat_portion,pplong_portion,vTEC_portion,gif_Grid_Lat,gif_Grid_Long,gif_Grid_Lat_Spaces,gif_Grid_Long_Spaces,gif_Grid_Lat_Delta,gif_Grid_Long_Delta,dataRejectOrig,dataRejectLimitOrig,dataRejectMax);
                #call a numba'd function that makes the movie quicker by crunching the numbers gooder
                
                #----------------------------Tack on Title-------------------------
                string_title = 'TEC Global Plot, Time =  '+'{0:.2f}'.format(np.round((TEC_timeUnique[i]-dateRange_dayNum_zeroHr[1]*86400),2))+\
                    ', 0 UT on '+dateRange_zeroHr_monthName+' '+str(dateRange_zeroHr[2])+', '+str(dateRange_dayNum_zeroHr[0]); #create mecha title
                
                ax[0].set_title(string_title,fontproperties=FONT_titleFM); #set the title, properties always needed
                                
                #-------------------Starting the Plotting--------------------------
                if( i == 0 ): #first run preps axes, color bars, etc.
                                                   
                    #Do the TEC plotting
                    pltHelprX, pltHelprY = np.meshgrid( gif_Grid_Long, gif_Grid_Lat); #helps the pcolor work
                    TEC_latLongMapped = geoMap(pltHelprX,pltHelprY); #convert the lat/long arcdeg to the current map coordinates
                    imTEC = ax[0].pcolormesh(TEC_latLongMapped[0], TEC_latLongMapped[1],  gif_Grid.T ,vmin=-TEC_plotLimValu, vmax=TEC_plotLimValu,cmap='jet',zorder=5); # pseudocolor plot "stretched" to the grid
                    cbar = fig.colorbar(imTEC, cax=cax, orientation='vertical'); #create a colorbar using the prev. defined cax
                    cax.yaxis.set_ticks(np.linspace(-TEC_plotLimValu,TEC_plotLimValu,5)); #create useful tick marks
                    cax.yaxis.set_major_formatter(FormatStrFormatter('%.2f')); #force a rounded format
                    cbar.set_label("delta-vTEC [TECU]"); #tabel the colorbar
                    cbar.ax.tick_params(labelsize=FONT_axisTick);
                    cbar.mappable.set_clim(vmin=-TEC_plotLimValu, vmax=TEC_plotLimValu);
                    
                    #Do the AMPERE plotting
                    AMPERE_colorMap = ListedColormap( np.hstack(( np.array( ( (np.linspace(1,0.492063492063492,128)),(np.linspace(1,0.507936507936508,128)),(np.linspace(1,1,128)) ) ) , np.array( ( (np.linspace(0.492063492063492,1,128)) , (np.linspace(0.507936507936508,0,128)) , (np.linspace(1,1,128)) ) ) )).T ); #white to purpleblue to pink (based off of 'cool')
                    AMPERE_latLongMapped = geoMap(AMPERE_long_portion,AMPERE_lat_portion); #convert the lat/long arcdeg to the current map coordinates
                    imAMP = ax[0].scatter(AMPERE_latLongMapped[0],AMPERE_latLongMapped[1],s=gif_Scatter_Point_Size_AMPERE,c=AMPERE_jouleHeating_portion,cmap=AMPERE_colorMap, vmin=np.min(AMPERE_plotLimValu), vmax=np.max(AMPERE_plotLimValu), zorder=7);
                    cbar2 = fig.colorbar(imAMP, cax=cax2, orientation='vertical'); #create a colorbar using the prev. defined cax
    #                cbar2.ax.set_yticklabels(np.linspace(np.min(AMPERE_plotLimValu),np.max(AMPERE_plotLimValu),5)); #create useful tick marks
                    cax2.yaxis.set_major_formatter(FormatStrFormatter('%.1f')); #force a rounded format
                    cax2.yaxis.set_ticks_position('left'); #move it to the left
                    cax2.yaxis.set_label_position('left'); #move it to the left
                    cbar2.set_label('AMPERE Joule Heating '+r'$(erg/cm^{2}sec)$'); #tabel the colorbar
                    cbar2.ax.tick_params(labelsize=FONT_axisTick);
                    cbar2.mappable.set_clim(vmin=np.min(AMPERE_plotLimValu), vmax=np.max(AMPERE_plotLimValu));
    
                    #Do the OMNI plotting
                    imOMNI = ax[1].plot( OMNI_timeUnique_hr, OMNI_data[:,OMNI_dict[OMNI_plot_scargle_name]] , linewidth=0.8 , zorder=1); #plot
            
                    if( np.mod(np.round(np.min(OMNI_timeUnique_hr)),2) == 0 ):
                        OMNI_time_hr_axis_min = np.round(np.min(OMNI_timeUnique_hr)); #is even, good to go
                    else:
                        OMNI_time_hr_axis_min = np.round(np.min(OMNI_timeUnique_hr))+1; #is odd, make even
                    #END IF
                    if( np.mod(np.round(np.max(OMNI_timeUnique_hr)),2) == 0 ):
                        OMNI_time_hr_axis_max = np.round(np.max(OMNI_timeUnique_hr)); #is even, good to go
                    else:
                        OMNI_time_hr_axis_max = np.round(np.max(OMNI_timeUnique_hr))-1; #is odd, make even
                    #END IF
                    
                    xAxisTicks = np.arange(OMNI_time_hr_axis_min,OMNI_time_hr_axis_max+4,4); #sets the start hr, stop hr, and the step size between (in this case, 4 hr)
                    ax[1].set_xticks(xAxisTicks); #set x axis ticks
                    ax[1].set_xlim( OMNI_time_hr_axis_min , OMNI_time_hr_axis_max ); #set y axis limits
                    ax[1].set_ylabel(OMNI_dictPlot[OMNI_dict[OMNI_plot_scargle_name]],fontproperties=FONT_axisLabelFM); #set the y axis label
                    ax[1].set_ylim( np.min(OMNI_data[:,OMNI_dict[OMNI_plot_scargle_name]]) , np.max(OMNI_data[:,OMNI_dict[OMNI_plot_scargle_name]]) ); #set y axis limits
                    ax[1].grid(b=True, which='major', axis='both', color='xkcd:light grey'); #sets major axis grid lines to be on
                    
                    #tack on 2nd title that doesn't change
                    OMNI_plot_scargle_label = OMNI_dictPlot[OMNI_dict[OMNI_plot_scargle_name]]; #get the label
                    OMNI_plot_scargle_labelNoUnits = OMNI_plot_scargle_label[0:OMNI_plot_scargle_label.find('(')-1]; #remove the (units)
                    string_title = 'OMNI '+OMNI_plot_scargle_labelNoUnits+' Index'; #create mecha title
                
                    ax[1].set_title(string_title,fontproperties=FONT_titleFM); #set the title
                    ax[1].set_xlabel(subfun_monthNum_to_word(dateRange[0,1])[0]+" "+str(dateRange[0,2])+" (Day "+str(dateRange_dayNum[0,1])+"), "+str(dateRange[0,0])+" to "+subfun_monthNum_to_word(dateRange[1,1])[0]+" "+str(dateRange[1,2])+" (Day "+str(dateRange_dayNum[0,1])+"), "+str(dateRange[1,0]),fontproperties=FONT_axisLabelFM); #set the x axis label                
                    
                    #Draw time line on bottom OMNI plot
                    OMNI_data_min = np.min(OMNI_data[:,OMNI_dict[OMNI_plot_scargle_name]]); #pre-calc the min
                    OMNI_data_max = np.max(OMNI_data[:,OMNI_dict[OMNI_plot_scargle_name]]); #pre-calc the max
                    imOMNILine = ax[1].plot( np.array(( (TEC_timeUnique[i]-dateRange_dayNum_zeroHr[1]*86400) , (TEC_timeUnique[i]-dateRange_dayNum_zeroHr[1]*86400) )) , np.array(( OMNI_data_min,OMNI_data_max)) , color=gif_Millstone_Marker_Color , zorder = 10);
                    
                    if( gif_dayNiteLine == 1 ):
                        fig.canvas.flush_events(); #this is req. to get get_window_extent() to get the current window size
                        #Plot the sunrise/sunset terminators
                        dayNite_temp = np.abs(dayNite_sunrise - (TEC_timeUnique[i]-dateRange_dayNum_zeroHr[1]*86400)) <= 10/3600; #gets the sunrise locations that are within 10 sec of the current TEC time (2 min had way too many hits, zigzags)
                        hLgd_FLG_day = np.sum(dayNite_temp); #plotting flag, shows when legend is active
                        #constants will use all the time - only for plotting of day/nite line so minor importance
                        
                        #this stuff makes the text angle plotted mostly correct most of the time
                        bboxFig = fig.get_window_extent().transformed(fig.dpi_scale_trans.inverted()); #get the entire figure dimensions
                        bboxAx0 = ax[0].get_window_extent().transformed(fig.dpi_scale_trans.inverted()); #get the plot dimensions
    #                    plot_ratio = (bboxAx0.width/bboxAx0.height)/( (bboxAx0.width/bboxAx0.height)/(bboxFig.width/bboxFig.height) )**2; #get the plot ratio, will use it to fix up the angle
                        plot_ratio = (bboxAx0.width/bboxAx0.height); #get the plot ratio, will use it to fix up the angle
                        
                        dayNite_textRotationLenOrig = 35; #length to go up and down the sunrise/sunset line to estimate an angle
                        dayNite_savgolFiltLenOrig = 101; #set it as a constant to start off
                        dayNite_textLatAbs = (np.max(plotLatRange)-np.min(plotLatRange))*.9 + np.min(plotLatRange); #calc like 80% of the max latitude
                        if( hLgd_FLG_day > 0 ): #only do work if it is there
                            #calc all that day/nite stuff in one function to keep it from getting cluttered
                            dayNite_Lat_line, dayNite_Long_line, dayNite_Lat_text, dayNite_Long_text, dayNite_textRotation = GRITI_movieMaker_subfun_dayniteCalc(0,np.sum(dayNite_temp),dayNite_Grid_Long[dayNite_temp],dayNite_Grid_Lat[dayNite_temp],dayNite_textLatAbs,plot_ratio,dayNite_savgolFiltLenOrig,dayNite_textRotationLenOrig);
                            dayNite_latLongMapped = geoMap(dayNite_Long_line,dayNite_Lat_line); #convert the lat/long arcdeg to the current map coordinates
                            imDayNite_day = ax[0].plot(dayNite_latLongMapped[0],dayNite_latLongMapped[1],color='g',linewidth=1.75,zorder=6); #plots a line to show the sunrise time
                            if( gif_dayNiteText == 1 ):
                                dayNite_latLongMapped = geoMap(dayNite_Long_text,dayNite_Lat_text); #convert the lat/long arcdeg to the current map coordinates
                                textDayNite_day = ax[0].text(dayNite_latLongMapped[0], dayNite_latLongMapped[1], "Sunrise", rotation=dayNite_textRotation, color='g', fontsize=FONT_axisTick, zorder=6);
                            #END IF
                        #END IF
                        
                        dayNite_temp = np.abs(dayNite_sunset - (TEC_timeUnique[i]-dateRange_dayNum_zeroHr[1]*86400)) <= 10/3600; #gets the sunset locations that are within 10 sec of the current TEC time (2 min had way too many hits, zigzags)
                        hLgd_FLG_nite = np.sum(dayNite_temp); #plotting flag, shows when legend is active
                        if( hLgd_FLG_nite > 0 ): #only do work if it is there
                            #calc all that day/nite stuff in one function to keep it from getting cluttered
                            dayNite_Lat_line, dayNite_Long_line, dayNite_Lat_text, dayNite_Long_text, dayNite_textRotation = GRITI_movieMaker_subfun_dayniteCalc(1,np.sum(dayNite_temp),dayNite_Grid_Long[dayNite_temp],dayNite_Grid_Lat[dayNite_temp],dayNite_textLatAbs,plot_ratio,dayNite_savgolFiltLenOrig,dayNite_textRotationLenOrig);
                            dayNite_latLongMapped = geoMap(dayNite_Long_line,dayNite_Lat_line); #convert the lat/long arcdeg to the current map coordinates
                            imDayNite_nite = ax[0].plot(dayNite_latLongMapped[0],dayNite_latLongMapped[1],color='b',linewidth=1.75,zorder=6); #plots a line to show the sunset time
                            if( gif_dayNiteText == 1 ):
                                dayNite_latLongMapped = geoMap(dayNite_Long_text,dayNite_Lat_text); #convert the lat/long arcdeg to the current map coordinates
                                textDayNite_nite = ax[0].text(dayNite_latLongMapped[0], dayNite_latLongMapped[1], "Sunset", rotation=dayNite_textRotation, color='b', fontsize=FONT_axisTick, zorder=6);
                            #EMD IF
                        #END IF
                    #END IF
                    
                    #Now drawing line of interest               
                    Millstone_latLongMapped = geoMap(longMillstone,latMillstone); #convert the lat/long arcdeg to the current map coordinates
                    imMillstone = ax[0].plot(Millstone_latLongMapped[0],Millstone_latLongMapped[1],marker=gif_Millstone_Marker, color=gif_Millstone_Marker_Color, markersize=gif_Millstone_Marker_Size, zorder=50); #plot this, 50 always on top
                                    
                else:
                    #Just plotting now - prep done, hopefully speeds it!
                    #Do the TEC plotting
                    pltHelprX, pltHelprY = np.meshgrid( gif_Grid_Long, gif_Grid_Lat); #helps the pcolor work
                    TEC_latLongMapped = geoMap(pltHelprX,pltHelprY); #convert the lat/long arcdeg to the current map coordinates
                    imTEC = ax[0].pcolormesh(TEC_latLongMapped[0], TEC_latLongMapped[1],  gif_Grid.T ,vmin=-TEC_plotLimValu, vmax=TEC_plotLimValu,cmap='jet',zorder=5); # pseudocolor plot "stretched" to the grid
                    
                    #Do the AMPERE plotting
                    AMPERE_latLongMapped = geoMap(AMPERE_long_portion,AMPERE_lat_portion); #convert the lat/long arcdeg to the current map coordinates
                    imAMP = ax[0].scatter(AMPERE_latLongMapped[0],AMPERE_latLongMapped[1],s=gif_Scatter_Point_Size_AMPERE,c=AMPERE_jouleHeating_portion,cmap=AMPERE_colorMap, vmin=np.min(AMPERE_plotLimValu), vmax=np.max(AMPERE_plotLimValu), zorder=7);
                    
                    #Draw time line on bottom OMNI plot
                    imOMNILine = ax[1].plot( np.array(( (TEC_timeUnique[i]-dateRange_dayNum_zeroHr[1]*86400) , (TEC_timeUnique[i]-dateRange_dayNum_zeroHr[1]*86400) )) , np.array(( OMNI_data_min,OMNI_data_max)) , color=gif_Millstone_Marker_Color , zorder = 10);
                    
                    if( gif_dayNiteLine == 1 ):
                        #Plot the sunrise/sunset terminators
                        dayNite_temp = np.abs(dayNite_sunrise - (TEC_timeUnique[i]-dateRange_dayNum_zeroHr[1]*86400)) <= 10/3600; #gets the sunrise locations that are within 10 sec of the current TEC time (2 min had way too many hits, zigzags)
                        hLgd_FLG_day = np.sum(dayNite_temp); #plotting flag, shows when legend is active
                        if( hLgd_FLG_day > 0 ): #only do work if it is there
                            #calc all that day/nite stuff in one function to keep it from getting cluttered
                            dayNite_Lat_line, dayNite_Long_line, dayNite_Lat_text, dayNite_Long_text, dayNite_textRotation = GRITI_movieMaker_subfun_dayniteCalc(0,np.sum(dayNite_temp),dayNite_Grid_Long[dayNite_temp],dayNite_Grid_Lat[dayNite_temp],dayNite_textLatAbs,plot_ratio,dayNite_savgolFiltLenOrig,dayNite_textRotationLenOrig);
                            dayNite_latLongMapped = geoMap(dayNite_Long_line,dayNite_Lat_line); #convert the lat/long arcdeg to the current map coordinates
                            imDayNite_day = ax[0].plot(dayNite_latLongMapped[0],dayNite_latLongMapped[1],color='g',linewidth=1.75,zorder=6); #plots a line to show the sunrise time
                            if( gif_dayNiteText == 1 ):
                                dayNite_latLongMapped = geoMap(dayNite_Long_text,dayNite_Lat_text); #convert the lat/long arcdeg to the current map coordinates
                                textDayNite_day = ax[0].text(dayNite_latLongMapped[0], dayNite_latLongMapped[1], "Sunrise", rotation=dayNite_textRotation, color='g', fontsize=FONT_axisTick, zorder=6);
                            #END IF
                        #END IF
                        
                        dayNite_temp = np.abs(dayNite_sunset - (TEC_timeUnique[i]-dateRange_dayNum_zeroHr[1]*86400)) <= 10/3600; #gets the sunset locations that are within 10 sec of the current TEC time (2 min had way too many hits, zigzags)
                        hLgd_FLG_nite = np.sum(dayNite_temp); #plotting flag, shows when legend is active
                        if( hLgd_FLG_nite > 0 ): #only do work if it is there
                            #calc all that day/nite stuff in one function to keep it from getting cluttered
                            dayNite_Lat_line, dayNite_Long_line, dayNite_Lat_text, dayNite_Long_text, dayNite_textRotation = GRITI_movieMaker_subfun_dayniteCalc(1,np.sum(dayNite_temp),dayNite_Grid_Long[dayNite_temp],dayNite_Grid_Lat[dayNite_temp],dayNite_textLatAbs,plot_ratio,dayNite_savgolFiltLenOrig,dayNite_textRotationLenOrig);
                            dayNite_latLongMapped = geoMap(dayNite_Long_line,dayNite_Lat_line); #convert the lat/long arcdeg to the current map coordinates
                            imDayNite_nite = ax[0].plot(dayNite_latLongMapped[0],dayNite_latLongMapped[1],color='b',linewidth=1.75,zorder=6); #plots a line to show the sunset time
                            if( gif_dayNiteText == 1 ):
                                dayNite_latLongMapped = geoMap(dayNite_Long_text,dayNite_Lat_text); #convert the lat/long arcdeg to the current map coordinates
                                textDayNite_nite = ax[0].text(dayNite_latLongMapped[0], dayNite_latLongMapped[1], "Sunset", rotation=dayNite_textRotation, color='b', fontsize=FONT_axisTick, zorder=6);
                            #END IF
                        #END IF
                    #END IF
                    
                #END IF
            
                #-----------------------Create Movie/GIF---------------------------
                #Makes the gif now
                plt.draw();
                
                gif_writer.grab_frame(); #get the frame and save it
                            
                #-------------------Clean up for re-use----------------------------
                #if forget one (like hOverlay) slows it way down after many plots
                imTEC.remove();
                imAMP.remove();
                imOMNILine.pop(0).remove();
    #            imOverlay.pop(0).remove();
    #            imMillstone.pop(0).remove();
                if( gif_dayNiteLine == 1 ):
                    if(hLgd_FLG_day > 0): #only delete if it is there
                        imDayNite_day.pop(0).remove();
                        if( gif_dayNiteText == 1 ):
                            textDayNite_day.remove();
                        #END IF
                    #END IF
                    if(hLgd_FLG_nite > 0): #only delete if it is there
                        imDayNite_nite.pop(0).remove();
                        if( gif_dayNiteText == 1 ):
                            textDayNite_nite.remove();
                        #END IF
                    #END IF
                #END IF
                
            #END FOR i
        #END WITH
    #END IF
    
    toc = time.time() - tic; #sec, calc current toc
    print("Time to run: "+str(np.round(toc,2))+" sec/ "+str(np.round(toc/60,2))+" min");
    
#END IF MOVIE CREATION
    
    
if( FLG_enable_movieSnaps  == 1 ):
#!!! SNAP TIMES !!! 
    #----------------------PRIME THE SNAP SHOT TIMES-----------------------------
    if( snaps_auto == 0 ): #use manually defined snap_times
        snaps_times = np.array( snaps_times ); #convert to useful form, makes it bulky to have it declared like this tho
    else: #otherwise auto make snap_times
        snaps_times = np.arange(0,snaps_auto_stepsToTake)*snaps_auto_step/60+snaps_auto_start; #make snap_times automagically  
    #END IF
    snaps_timesDays = snaps_times/24+dateRange_dayNum_zeroHr[1]; #days, convert to days for comparison with stuff
    
    
    #----------------------PRIME TTHE SNAP SHOT ARRANGEMENT-----------------------------
    if( snaps_times.size == 4 ):
        snaps_rows = 2; #set pre-determined row/col stuff
        snaps_cols = 2;
        
        snaps_left = 0.045; #for the figure to adjust its sizing
        snaps_right = 0.945;
        snaps_top = 0.96;
        snaps_bottom = 0.035;  
        snaps_hspace = 0.135; 
        snaps_wspace = 0.265;
    #END IF
    elif( snaps_times.size == 6 ):
        snaps_rows = 2; #set pre-determined row/col stuff
        snaps_cols = 3;
        
        snaps_left = 0.045; #for the figure to adjust its sizing
        snaps_right = 0.945;
        snaps_top = 0.96;
        snaps_bottom = 0.035;  
        snaps_hspace = 0.155; 
        snaps_wspace = 0.265;
    #END IF
    elif( snaps_times.size == 9 ):
        snaps_rows = 3; #set pre-determined row/col stuff
        snaps_cols = 3;
        
        snaps_left = 0.045; #for the figure to adjust its sizing
        snaps_right = 0.945;
        snaps_top = 0.96;
        snaps_bottom = 0.035;  
        snaps_hspace = 0.225; 
        snaps_wspace = 0.205;
    else:
        print('\nERROR:\nIN SNAPS FUNCTION - UNSUPPORTED SUBPLOT NUMBER OF '+str(snaps_times.size)+' REQUESTED. GIVING UP.\n');
        sys.crash(); #yeet that program
    #END IF
    
    
    #----------------------CALCULATE SUNRISE SUNSET TIMES----------------------
    #SECOND STEP: CALC LOCAL SUNRISE/SUNSET TIMES
    #calcs done in UT/GMT
    # based on calc steps in https://www.mathworks.com/examples/matlab/community/21093-estimating-sunrise-and-sunset
    #Preallocate
    dayNite_Grid_size = 1000; #number to subdivide grid into
    dayNite_sunrise = np.zeros( (dayNite_Grid_size,dayNite_Grid_size,dateRange_dayNum_full.shape[0]) ,dtype=np.float64); #hr UT, prep sunrise time for each day in the lat/long grid
    dayNite_sunset = np.zeros( (dayNite_Grid_size,dayNite_Grid_size,dateRange_dayNum_full.shape[0]) ,dtype=np.float64); #hr UT, prep sunset time for each day in the lat/long grid
    [dayNite_Grid_Long,dayNite_Grid_Lat] = np.meshgrid(np.linspace(np.min(plotLongRange),np.max(plotLongRange),dayNite_Grid_size),np.linspace(np.min(plotLatRange),np.max(plotLatRange),dayNite_Grid_size)); #degc, make two matrixes that have all the corresponding points in a lat/long grid
    dayNite_long_corrected = 4*(dayNite_Grid_Long); #calc corrected longitude, for sunrise/sunset time
    
    for i in range(0,dateRange_dayNum_full.shape[0]):
    
        dayNite_B = 360*(dateRange_dayNum_full[i,1] - 81)/365*np.pi/180; #rad, some sort of angle based on days and stuff
        dayNite_EoT_corrected = 9.87*np.sin(2*dayNite_B) - 7.53*np.cos(dayNite_B) - 1.5*np.sin(dayNite_B); #eq for Time Correction
        dayNite_solar_corrected = dayNite_long_corrected + np.tile(dayNite_EoT_corrected,(dayNite_Grid_size,dayNite_Grid_size) ); #min, solar time correction - for noon
    
        dayNite_solar_declination = np.arcsin(np.sin(23.45*np.pi/180)*np.sin(360*(dateRange_dayNum_full[i,1] - 81)/365*np.pi/180)); #rad, solar declination
    
        dayNite_temp = -np.tan(dayNite_Grid_Lat*np.pi/180)*np.tan(dayNite_solar_declination); #calc some mid step
    #     dayNite_temp( dayNite_temp >= 1 ) = dayNite_temp( dayNite_temp >= 1 ) - -2*(1 - dayNite_temp( dayNite_temp >= 1 )); #attempt a flip
    #     dayNite_temp( dayNite_temp <= -1) = dayNite_temp( dayNite_temp <= -1) + -2*(1 + dayNite_temp( dayNite_temp <= -1) ); #attempt a flip
        k = (dayNite_temp[:,0] <= -1) | (dayNite_temp[:,0] >= 1); #prep to replace these
    #     kF = find(k == 1,1,'first');
        
        dayNite_sunrise[:,:,i] = 12 - np.real(np.arccos(dayNite_temp)*180/np.pi)/15 - dayNite_solar_corrected/60; #hr UT, sunrise time
    #     for(j = 1:dayNite_Grid_size) %interpolation didn't work - too precipitous
    #         dayNite_sunrise(k,j,i) = interp1(1:1:(kF-1),dayNite_sunrise(~k,j,i),kF:1:dayNite_Grid_size,'spline','extrap'); %interp for each long set (calc oofs out at specific lat)
    #     end
        dayNite_sunset[:,:,i] = 12 + np.real(np.arccos(dayNite_temp)*180/np.pi)/15 - dayNite_solar_corrected/60; #hr UT, sunrise time
        #Accurate to like 10 minutes or whatever (breaks at high latitudes...)
        
        dayNite_sunrise[k,:,i] = np.nan; #remove data that we can't calc with this alg
        dayNite_sunset[k,:,i] = np.nan; #remove data that we can't calc with this alg
        
        dayNite_sunrise[:,:,i] = dayNite_sunrise[:,:,i] + dateRange_zeroHr_hrs[i]; #adjust to make it align to the hourly schedule
        dayNite_sunset[:,:,i] = dayNite_sunset[:,:,i] + dateRange_zeroHr_hrs[i]; #adjust to make it align to the hourly schedule
    #EMD FOR i
    
    #yo I straight up just transpose and reshape in different ways till it works how I want, matlab's is so much easier
    dayNite_sunrise =  np.reshape(dayNite_sunrise.transpose(2,1,0), (dayNite_Grid_size*dateRange_dayNum_full.shape[0], dayNite_Grid_size) ).T; #reshape into one big thing since each day's 6 AM sunrise or whatever is now per-day (+/-24 etc)
    dayNite_sunset = np.reshape(dayNite_sunset.transpose(2,1,0), (dayNite_Grid_size*dateRange_dayNum_full.shape[0], dayNite_Grid_size) ).T; #reshape into one big thing since each day's 6 AM sunrise or whatever is now per-day (+/-24 etc)
    dayNite_Grid_Lat = np.tile(dayNite_Grid_Lat, (1, dateRange_dayNum_full.shape[0]) ); #copy this to match above 1:1
    dayNite_Grid_Long = np.tile(dayNite_Grid_Long, (1, dateRange_dayNum_full.shape[0]) ); #copy this to match above 1:1
    
    
    #----------------------MAKE CUSTOM AUTOTICKS FOR THESE CRUNCHED SUBPLOTS----------------------
    #plot help with autotick calculating
    plotLongRange_autoTick = (np.max(plotLongRange) - np.min(plotLongRange))/(20/snaps_cols); #tries to split the longitude range into 20 parts (based off of what fits goodish) a nd divided by the number of columns
    if( plotLongRange_autoTick > 10 ):
        plotLongRange_autoTick = 15; #sets the tick setting to 15 arcdegrees per tick
    elif( plotLongRange_autoTick > 5 ):
        plotLongRange_autoTick = 10; #sets the tick setting to 10 arcdegrees per tick
    elif( plotLongRange_autoTick > 2 ):
        plotLongRange_autoTick = 5; #sets the tick setting to 5 arcdegrees per tick
    elif( plotLongRange_autoTick > 1 ):
        plotLongRange_autoTick = 2; #sets the tick setting to 2 arcdegrees per tick
    elif( plotLongRange_autoTick >= 0.6 ): #0.6 because 15/25 = 0.6, so there will be enough 1 arcdeg ticks
        plotLongRange_autoTick = 1; #sets the tick setting to 1 arcdegree per tick
    else:
        plotLongRange_autoTick = (np.max(plotLongRange) - np.min(plotLongRange))/15; #just goes for it if it's a super tiny range
    #END IF
    plotLatRange_autoTick = (np.max(plotLatRange) - np.min(plotLatRange))/(16/snaps_rows); #tries to split the latitude range into 16 parts (based off of what fits goodish) and divided by the number of rows
    if( plotLatRange_autoTick > 10 ):
        plotLatRange_autoTick = 15; #sets the tick setting to 15 arcdegrees per tick
    elif( plotLatRange_autoTick > 5 ):
        plotLatRange_autoTick = 10; #sets the tick setting to 10 arcdegrees per tick
    elif( plotLatRange_autoTick > 2 ):
        plotLatRange_autoTick = 5; #sets the tick setting to 5 arcdegrees per tick
    elif( plotLatRange_autoTick > 1 ):
        plotLatRange_autoTick = 2; #sets the tick setting to 2 arcdegrees per tick
    elif( plotLatRange_autoTick > 0.75 ): #0.75 because 10/13 = 0.76something and it sounded good for enough 1 arcdeg ticks
        plotLatRange_autoTick = 1; #sets the tick setting to 1 arcdegree per tick
    else:
        plotLatRange_autoTick = (np.max(plotLatRange) - np.min(plotLatRange))/15; #just goes for it if it's a super tiny range
    #END IF
    
        
    #----------------------PRIME THE FIGURE WINDOW-----------------------------
    #get some arrays that indentify the indexes of the plots [0,0], [0,1], etc.
    snaps_rowsArray, snaps_colsArray = np.meshgrid( np.arange(0,snaps_rows) , np.arange(0,snaps_cols) );
    snaps_rowsArray = np.ndarray.flatten(snaps_rowsArray.T); #yy stuff
    snaps_colsArray = np.ndarray.flatten(snaps_colsArray.T); #xx stuff
        
    #fire up the figure
    fig, ax = plt.subplots(figsize = gif_figureSize/gif_figurePPI ,nrows=snaps_rows, ncols=snaps_cols); #use instead of fig because it inits an axis too (I think I dunno)
    figManager = plt.get_current_fig_manager(); #req to maximize
    figManager.window.showMaximized(); #force maximized
    
    #this just won't activate anywhere else - so putting it at the end
    for i in range(0,snaps_times.size):     
        fig.canvas.flush_events(); #this is req. to get get_window_extent() to get the current window size
        #Remove the aspect ratio from the basemap so it fills the screen better
        ax[snaps_rowsArray[i],snaps_colsArray[i]].set_aspect('auto');
    #END FOR i
    
    #fit the figure to the screen better than automatic does
    fig.subplots_adjust(left = snaps_left, right = snaps_right, top = snaps_top, bottom = snaps_bottom ,  hspace = snaps_hspace ,  wspace = snaps_wspace); #sets padding to small numbers for minimal white space
    #fig.tight_layout(); #function for a tight layout, doesn't seem to do much here
    
    plt.show(); #req to make plot show up
    
    
    #----------------------PRIME THE LAT/LONG GRID-----------------------------
    if( FLG_snaps_grid_spaces_auto == 1 ):
        snaps_Grid_Long_Size = snaps_Grid_Lat_Size/1.0; #degc, calc the long avg square size - hard-coded ratio for now
        snaps_Grid_Lat_Spaces = np.int64(np.round((np.max(plotLatRange)-np.min(plotLatRange))/snaps_Grid_Lat_Size,0)); #calc the number of spaces
        snaps_Grid_Long_Spaces = np.int64(np.round((np.max(plotLongRange)-np.min(plotLongRange))/snaps_Grid_Long_Size,0)); #calc the number of spaces
    #END IF
    
    gif_Grid_Lat = np.linspace(np.min(plotLatRange),np.max(plotLatRange),snaps_Grid_Lat_Spaces+1); #degc, create lat points (+1 lets us use delta to edge wanted range - yields correct # of spaces)
    gif_Grid_Long = np.linspace(np.min(plotLongRange),np.max(plotLongRange),snaps_Grid_Long_Spaces+1); #degc, create long points (+1 lets us use delta to edge wanted range - yields correct # of spaces)
    gif_Grid_Lat_Delta = np.abs(gif_Grid_Lat[1] - gif_Grid_Lat[0]); #degc, lat delta
    gif_Grid_Long_Delta = np.abs(gif_Grid_Long[1] - gif_Grid_Long[0]); #degc, long delta
    
    
    #----------------------CREATE THE SNAPS----------------------
    if( snaps_type == 1 ):
        #------------Time keeping for various data sources-------------
        
        #-------------------------Start Making Pictures------------------------
        for i in range(0,snaps_times.size):            
            #------------Make human readable time-------------
            if( np.int64(np.round(np.abs(np.abs((snaps_times[i]-np.int64(snaps_times[i]))*60)-np.int64(np.abs((snaps_times[i]-np.int64(snaps_times[i]))*60)))*60,2)) == 0 ):
                snaps_timeReadable = str(np.int64(snaps_times[i])).zfill(2)+':'+str(np.int64(np.abs((snaps_times[i]-np.int64(snaps_times[i]))*60))).zfill(2); #create a human-readable time, no seconds
            else:
                snaps_timeReadable = str(np.int64(snaps_times[i])).zfill(2)+':'+str(np.int64(np.abs((snaps_times[i]-np.int64(snaps_times[i]))*60))).zfill(2)+':'+\
                    str( np.int64(np.round(np.abs(np.abs((snaps_times[i]-np.int64(snaps_times[i]))*60)-np.int64(np.abs((snaps_times[i]-np.int64(snaps_times[i]))*60)))*60,2)) ).zfill(2); #create a human-readable time
                if( snaps_timeReadable[-2:] == '60' ): #fix 60 second issue
                    snaps_timeReadable = str(np.int64(snaps_times[i])).zfill(2)+':'+str(np.int64(np.abs((snaps_times[i]-np.int64(snaps_times[i]))*60+1))).zfill(2); #create a human-readable time
                #END IF
            #END IF
                        
            #----------------Corral the data to the right place----------------
            k =  np.where( np.min(np.abs(data['TEC']['time'] - snaps_timesDays[i])) == np.abs(data['TEC']['time'] - snaps_timesDays[i]) ) [0]; #gets during a time period
            vTEC_portion = data['TEC']['dTEC'][k]; #pull out the vTEC now
            pplat_portion = data['TEC']['lat'][k]; #get the pplat (pierce-point lat) at the time required
            pplong_portion = data['TEC']['long'][k]; #get the pplong (pierce-point long) at the time required
                        
            gif_Grid = GRITI_movieMaker_subfun_dataGridder(pplat_portion,pplong_portion,vTEC_portion,gif_Grid_Lat,gif_Grid_Long,snaps_Grid_Lat_Spaces,snaps_Grid_Long_Spaces,gif_Grid_Lat_Delta,gif_Grid_Long_Delta,dataRejectOrig,dataRejectLimitOrig,dataRejectMax);
            #call a numba'd function that makes the movie quicker by crunching the numbers gooder
            
            #----------------------------Tack on Title-------------------------
            string_title = 'Time =  '+'{0:.2f}'.format(np.round(snaps_times[i],2))+\
                ', '+snaps_timeReadable; #create mecha title
            
            ax[snaps_rowsArray[i],snaps_colsArray[i]].set_title(string_title,fontproperties=FONT_titleFM); #set the title, properties always needed
                
            #-------------------Starting the Plotting--------------------------

            #prime the colorbars
            if( snaps_colsArray[i] == np.max(snaps_colsArray) ): #only plot the label on the right side
                divider = make_axes_locatable(ax[snaps_rowsArray[i],snaps_colsArray[i]]); #prep to add an axis
                cax = divider.append_axes('right', size='1.5%', pad=0.35); #make a color bar axis
                cax.yaxis.label.set_font_properties(FONT_axisLabelFM);
            #END IF
                        
            #Prime the basemap for each axis
            geoMap = Basemap(projection=geoMap_projectionStyle, lat_0=np.mean(plotLatRange), lon_0=np.mean(plotLongRange), #projection type, and I think lat_0/lon_0 are the centers?
                resolution = 'i', area_thresh = 10000, ax=ax[snaps_rowsArray[i],snaps_colsArray[i]], #resolutions I know are l, i, h - i seems good. area_thresh being big prevents it drawing lil lakes, 0.1 makes everything
                llcrnrlon=np.float32(plotLongRange[0]), llcrnrlat=np.float32(plotLatRange[0]), #lower left corner lat/long - MUST BE FLOAT cause CODED BY THE BEST
                urcrnrlon=np.float32(plotLongRange[1]), urcrnrlat=np.float32(plotLatRange[1])); #upper right corner lat/long - MUST BE FLOAT cause CODED BY THE BEST

            geoMap.drawcoastlines(zorder=25); #always on top
            if( gif_ContinentFill == 1 ): #color in stuff if this is on
                #geoMap.drawcountries();
                #geoMap.drawmapboundary();
                geoMap.fillcontinents(color=gif_ContientColor,lake_color=gif_ContinentWaterColor,zorder=1);
                geoMap.drawmapboundary(fill_color=gif_ContinentWaterColor,zorder=0);
            #END IF
                        
            #np.linspace(startlat,endlat,5) # 5 = number of "ticks"
            geoMap.drawmeridians( np.round(np.arange(np.floor(np.min(plotLongRange)),np.ceil(np.max(plotLongRange))+1,plotLongRange_autoTick),2), 
                labels=[True,False,False,True], labelstyle='+/-', dashes=[6,15000], color='black' ); #adds the labels but keeps the lines invisible
            geoMap.drawparallels(np.round(np.arange(np.floor(np.min(plotLatRange)),np.ceil(np.max(plotLatRange))+1,plotLatRange_autoTick),2), 
                labels=[True,False,True,False], labelstyle='+/-', dashes=[6,15000], color='black' ); #adds the labels but keeps the lines invisible
            #dashes[6,15000] seems to be enough to keep the repeating dash from happening on a world plot (I think it's how wide a dash is and the dash spacing). 900 was good for 22 degc longitude, for ref.
            #labels=[left,right,top,bottom] is the order. true/false to turn them on and off. not sure why there's a top/bottom for the parallels but w/e people do it
            
            #Do the TEC plotting
            pltHelprX, pltHelprY = np.meshgrid( gif_Grid_Long, gif_Grid_Lat); #helps the pcolor work
            TEC_latLongMapped = geoMap(pltHelprX,pltHelprY); #convert the lat/long arcdeg to the current map coordinates
            imTEC = ax[snaps_rowsArray[i],snaps_colsArray[i]].pcolormesh(TEC_latLongMapped[0], TEC_latLongMapped[1],  gif_Grid.T ,vmin=-TEC_plotLimValu, vmax=TEC_plotLimValu,cmap='jet',zorder=5); # pseudocolor plot "stretched" to the grid
            if( snaps_colsArray[i] == np.max(snaps_colsArray) ): #only plot the label on the right side
                cbar = fig.colorbar(imTEC, cax=cax, orientation='vertical'); #create a colorbar using the prev. defined cax
                cax.yaxis.set_ticks(np.linspace(-TEC_plotLimValu,TEC_plotLimValu,5)); #create useful tick marks
                cax.yaxis.set_major_formatter(FormatStrFormatter('%.2f')); #force a rounded format
                cbar.set_label("delta-vTEC [TECU]"); #tabel the colorbar
                cbar.ax.tick_params(labelsize=FONT_axisTick);
                cbar.mappable.set_clim(vmin=-TEC_plotLimValu, vmax=TEC_plotLimValu);
            #END IF
            
            if( snaps_dayNiteLine == 1 ):
                fig.canvas.flush_events(); #this is req. to get get_window_extent() to get the current window size
                #Plot the sunrise/sunset terminators
                dayNite_temp = np.abs(dayNite_sunrise - snaps_times[i]) <= 10/3600; #gets the sunrise locations that are within 10 sec of the current TEC time (2 min had way too many hits, zigzags)
                hLgd_FLG_day = np.sum(dayNite_temp); #plotting flag, shows when legend is active
                #constants will use all the time - only for plotting of day/nite line so minor importance
                #this stuff makes the text angle plotted mostly correct most of the time
                bboxFig = fig.get_window_extent().transformed(fig.dpi_scale_trans.inverted()); #get the entire figure dimensions
                bboxAx0 = ax[snaps_rowsArray[i],snaps_colsArray[i]].get_window_extent().transformed(fig.dpi_scale_trans.inverted()); #get the plot dimensions
#                    plot_ratio = (bboxAx0.width/bboxAx0.height)/( (bboxAx0.width/bboxAx0.height)/(bboxFig.width/bboxFig.height) )**2; #get the plot ratio, will use it to fix up the angle
                plot_ratio = (bboxAx0.width/bboxAx0.height); #get the plot ratio, will use it to fix up the angle
                dayNite_textRotationLenOrig = 35; #length to go up and down the sunrise/sunset line to estimate an angle
                dayNite_savgolFiltLenOrig = 101; #set it as a constant to start off
                dayNite_textLatAbs = (np.max(plotLatRange)-np.min(plotLatRange))*.9 + np.min(plotLatRange); #calc like 80% of the max latitude
                if( hLgd_FLG_day > 0 ): #only do work if it is there
                    #calc all that day/nite stuff in one function to keep it from getting cluttered
                    dayNite_Lat_line, dayNite_Long_line, dayNite_Lat_text, dayNite_Long_text, dayNite_textRotation = GRITI_movieMaker_subfun_dayniteCalc(0,np.sum(dayNite_temp),dayNite_Grid_Long[dayNite_temp],dayNite_Grid_Lat[dayNite_temp],dayNite_textLatAbs,plot_ratio,dayNite_savgolFiltLenOrig,dayNite_textRotationLenOrig);
                    dayNite_latLongMapped = geoMap(dayNite_Long_line,dayNite_Lat_line); #convert the lat/long arcdeg to the current map coordinates
                    imDayNite_day = ax[snaps_rowsArray[i],snaps_colsArray[i]].plot(dayNite_latLongMapped[0],dayNite_latLongMapped[1],color='g',linewidth=1.75,zorder=6); #plots a line to show the sunrise time
                    if( snaps_dayNiteText == 1 ):
                        dayNite_latLongMapped = geoMap(dayNite_Long_text,dayNite_Lat_text); #convert the lat/long arcdeg to the current map coordinates
                        textDayNite_day = ax[snaps_rowsArray[i],snaps_colsArray[i]].text(dayNite_latLongMapped[0], dayNite_latLongMapped[1], "Sunrise", rotation=dayNite_textRotation, color='g', fontsize=FONT_axisTick, zorder=6);
                    #END IF
                #END IF
                
                dayNite_temp = np.abs(dayNite_sunset - snaps_times[i]) <= 10/3600; #gets the sunset locations that are within 10 sec of the current TEC time (2 min had way too many hits, zigzags)
                hLgd_FLG_nite = np.sum(dayNite_temp); #plotting flag, shows when legend is active
                if( hLgd_FLG_nite > 0 ): #only do work if it is there
                    #calc all that day/nite stuff in one function to keep it from getting cluttered
                    dayNite_Lat_line, dayNite_Long_line, dayNite_Lat_text, dayNite_Long_text, dayNite_textRotation = GRITI_movieMaker_subfun_dayniteCalc(1,np.sum(dayNite_temp),dayNite_Grid_Long[dayNite_temp],dayNite_Grid_Lat[dayNite_temp],dayNite_textLatAbs,plot_ratio,dayNite_savgolFiltLenOrig,dayNite_textRotationLenOrig);
                    dayNite_latLongMapped = geoMap(dayNite_Long_line,dayNite_Lat_line); #convert the lat/long arcdeg to the current map coordinates
                    imDayNite_nite = ax[snaps_rowsArray[i],snaps_colsArray[i]].plot(dayNite_latLongMapped[0],dayNite_latLongMapped[1],color='b',linewidth=1.75,zorder=6); #plots a line to show the sunset time
                    if( snaps_dayNiteText == 1 ):
                        dayNite_latLongMapped = geoMap(dayNite_Long_text,dayNite_Lat_text); #convert the lat/long arcdeg to the current map coordinates
                        textDayNite_nite = ax[snaps_rowsArray[i],snaps_colsArray[i]].text(dayNite_latLongMapped[0], dayNite_latLongMapped[1], "Sunset", rotation=dayNite_textRotation, color='b', fontsize=FONT_axisTick, zorder=6);
                    #EMD IF
                #END IF
            #END IF
            
            #Now drawing point of interest
            Millstone_latLongMapped = geoMap(longMillstone,latMillstone); #convert the lat/long arcdeg to the current map coordinates
            imMillstone = ax[snaps_rowsArray[i],snaps_colsArray[i]].plot(Millstone_latLongMapped[0],Millstone_latLongMapped[1],marker=gif_Millstone_Marker, color=gif_Millstone_Marker_Color, markersize=gif_Millstone_Marker_Size, zorder=50); #plot this, 50 always on top
           
        #END FOR i
    elif( snaps_type == 5 ):
        #------------Time keeping for various data sources-------------
        AMPERE_dataRate = np.median(np.diff(AMPERE_timeUnique)); #days, get the median data rate for AMPERE data (avoids outliers)
        
        #-------------------------Start Making Pictures------------------------
        for i in range(0,snaps_times.size):            
            #------------Make human readable time-------------
            if( np.int64(np.round(np.abs(np.abs((snaps_times[i]-np.int64(snaps_times[i]))*60)-np.int64(np.abs((snaps_times[i]-np.int64(snaps_times[i]))*60)))*60,2)) == 0 ):
                snaps_timeReadable = str(np.int64(snaps_times[i])).zfill(2)+':'+str(np.int64(np.abs((snaps_times[i]-np.int64(snaps_times[i]))*60))).zfill(2); #create a human-readable time, no seconds
            else:
                snaps_timeReadable = str(np.int64(snaps_times[i])).zfill(2)+':'+str(np.int64(np.abs((snaps_times[i]-np.int64(snaps_times[i]))*60))).zfill(2)+':'+\
                    str( np.int64(np.round(np.abs(np.abs((snaps_times[i]-np.int64(snaps_times[i]))*60)-np.int64(np.abs((snaps_times[i]-np.int64(snaps_times[i]))*60)))*60,2)) ).zfill(2); #create a human-readable time
            #END IF
            
            #------------Corral the AMPERE data to the right place-------------
            k = np.where( (data['AMPERE']['time'] <= snaps_timesDays[i]) & (data['AMPERE']['time'] >= (snaps_timesDays[i]-AMPERE_dataRate)) )[0]; #get where the time point is, make sure it is within the data rate window
            AMPERE_jouleHeating_portion = AMPERE_data[k,locAMPERE_jouleHeating]; #ergs/(cm^2*sec), get the Joule Heating for the current time step
            AMPERE_lat_portion = AMPERE_data[k,locAMPERE_lat]; #degc, corresponding lat values
            AMPERE_long_portion = AMPERE_data[k,locAMPERE_long]; #degc, corresponding long values
            
            #----------------Corral the data to the right place----------------
            k =  np.where( np.min(np.abs(data['TEC']['time'] - snaps_timesDays[i])) == np.abs(data['TEC']['time'] - snaps_timesDays[i]) ) [0]; #gets during a time period
            vTEC_portion = data['TEC']['dTEC'][k]; #pull out the vTEC now
            pplat_portion = data['TEC']['lat'][k]; #get the pplat (pierce-point lat) at the time required
            pplong_portion = data['TEC']['long'][k]; #get the pplong (pierce-point long) at the time required
                        
            gif_Grid = GRITI_movieMaker_subfun_dataGridder(pplat_portion,pplong_portion,vTEC_portion,gif_Grid_Lat,gif_Grid_Long,snaps_Grid_Lat_Spaces,snaps_Grid_Long_Spaces,gif_Grid_Lat_Delta,gif_Grid_Long_Delta,dataRejectOrig,dataRejectLimitOrig,dataRejectMax);
            #call a numba'd function that makes the movie quicker by crunching the numbers gooder
            
            #----------------------------Tack on Title-------------------------
            string_title = 'Time =  '+'{0:.2f}'.format(np.round(snaps_times[i],2))+\
                ', '+snaps_timeReadable; #create mecha title
            
            ax[snaps_rowsArray[i],snaps_colsArray[i]].set_title(string_title,fontproperties=FONT_titleFM); #set the title, properties always needed
                
            #-------------------Starting the Plotting--------------------------

            #prime the colorbars
            if( snaps_colsArray[i] == np.max(snaps_colsArray) ): #only plot the label on the right side
                divider = make_axes_locatable(ax[snaps_rowsArray[i],snaps_colsArray[i]]); #prep to add an axis
                cax = divider.append_axes('right', size='1.5%', pad=0.35); #make a color bar axis
                cax.yaxis.label.set_font_properties(FONT_axisLabelFM);
            #END IF
            if( snaps_colsArray[i] == np.min(snaps_colsArray) ): #only plot the label on the left side
                divider = make_axes_locatable(ax[snaps_rowsArray[i],snaps_colsArray[i]]); #prep to add an axis
                cax2 = divider.append_axes('left', size='1.5%', pad=0.65); #make a color bar axis
                cax2.yaxis.label.set_font_properties(FONT_axisLabelFM);
            #END IF
                        
            #Prime the basemap for each axis
            geoMap = Basemap(projection=geoMap_projectionStyle, lat_0=np.mean(plotLatRange), lon_0=np.mean(plotLongRange), #projection type, and I think lat_0/lon_0 are the centers?
                resolution = 'i', area_thresh = 10000, ax=ax[snaps_rowsArray[i],snaps_colsArray[i]], #resolutions I know are l, i, h - i seems good. area_thresh being big prevents it drawing lil lakes, 0.1 makes everything
                llcrnrlon=np.float32(plotLongRange[0]), llcrnrlat=np.float32(plotLatRange[0]), #lower left corner lat/long - MUST BE FLOAT cause CODED BY THE BEST
                urcrnrlon=np.float32(plotLongRange[1]), urcrnrlat=np.float32(plotLatRange[1])); #upper right corner lat/long - MUST BE FLOAT cause CODED BY THE BEST

            geoMap.drawcoastlines(zorder=25); #always on top
            if( gif_ContinentFill == 1 ): #color in stuff if this is on
                #geoMap.drawcountries();
                #geoMap.drawmapboundary();
                geoMap.fillcontinents(color=gif_ContientColor,lake_color=gif_ContinentWaterColor,zorder=1);
                geoMap.drawmapboundary(fill_color=gif_ContinentWaterColor,zorder=0);
            #END IF
                        
            #np.linspace(startlat,endlat,5) # 5 = number of "ticks"
            geoMap.drawmeridians( np.round(np.arange(np.floor(np.min(plotLongRange)),np.ceil(np.max(plotLongRange))+1,plotLongRange_autoTick),2), 
                labels=[True,False,False,True], labelstyle='+/-', dashes=[6,15000], color='black' ); #adds the labels but keeps the lines invisible
            geoMap.drawparallels(np.round(np.arange(np.floor(np.min(plotLatRange)),np.ceil(np.max(plotLatRange))+1,plotLatRange_autoTick),2), 
                labels=[True,False,True,False], labelstyle='+/-', dashes=[6,15000], color='black' ); #adds the labels but keeps the lines invisible
            #dashes[6,15000] seems to be enough to keep the repeating dash from happening on a world plot (I think it's how wide a dash is and the dash spacing). 900 was good for 22 degc longitude, for ref.
            #labels=[left,right,top,bottom] is the order. true/false to turn them on and off. not sure why there's a top/bottom for the parallels but w/e people do it
            
            #Do the TEC plotting
            pltHelprX, pltHelprY = np.meshgrid( gif_Grid_Long, gif_Grid_Lat); #helps the pcolor work
            TEC_latLongMapped = geoMap(pltHelprX,pltHelprY); #convert the lat/long arcdeg to the current map coordinates
            imTEC = ax[snaps_rowsArray[i],snaps_colsArray[i]].pcolormesh(TEC_latLongMapped[0], TEC_latLongMapped[1],  gif_Grid.T ,vmin=-TEC_plotLimValu, vmax=TEC_plotLimValu,cmap='jet',zorder=5); # pseudocolor plot "stretched" to the grid
            if( snaps_colsArray[i] == np.max(snaps_colsArray) ): #only plot the label on the right side
                cbar = fig.colorbar(imTEC, cax=cax, orientation='vertical'); #create a colorbar using the prev. defined cax
                cax.yaxis.set_ticks(np.linspace(-TEC_plotLimValu,TEC_plotLimValu,5)); #create useful tick marks
                cax.yaxis.set_major_formatter(FormatStrFormatter('%.2f')); #force a rounded format
                cbar.set_label("delta-vTEC [TECU]"); #tabel the colorbar
                cbar.ax.tick_params(labelsize=FONT_axisTick);
                cbar.mappable.set_clim(vmin=-TEC_plotLimValu, vmax=TEC_plotLimValu);
            #END IF

            #Do the AMPERE plotting
            AMPERE_colorMap = ListedColormap( np.hstack(( np.array( ( (np.linspace(1,0.492063492063492,128)),(np.linspace(1,0.507936507936508,128)),(np.linspace(1,1,128)) ) ) , np.array( ( (np.linspace(0.492063492063492,1,128)) , (np.linspace(0.507936507936508,0,128)) , (np.linspace(1,1,128)) ) ) )).T ); #white to purpleblue to pink (based off of 'cool')
            AMPERE_latLongMapped = geoMap(AMPERE_long_portion,AMPERE_lat_portion); #convert the lat/long arcdeg to the current map coordinates
            imAMP = ax[snaps_rowsArray[i],snaps_colsArray[i]].scatter(AMPERE_latLongMapped[0],AMPERE_latLongMapped[1],s=gif_Scatter_Point_Size_AMPERE,c=AMPERE_jouleHeating_portion,cmap=AMPERE_colorMap, vmin=np.min(AMPERE_plotLimValu), vmax=np.max(AMPERE_plotLimValu), zorder=7);
            if( snaps_colsArray[i] == np.min(snaps_colsArray) ): #only plot the label on the left side
                cbar2 = fig.colorbar(imAMP, cax=cax2, orientation='vertical'); #create a colorbar using the prev. defined cax
    #                cbar2.ax.set_yticklabels(np.linspace(np.min(AMPERE_plotLimValu),np.max(AMPERE_plotLimValu),5)); #create useful tick marks
                cax2.yaxis.set_major_formatter(FormatStrFormatter('%.1f')); #force a rounded format
                cax2.yaxis.set_ticks_position('left'); #move it to the left
                cax2.yaxis.set_label_position('left'); #move it to the left
            
                cbar2.set_label('Joule Heating ['+'$erg/cm^{2}s$]'); #tabel the colorbar
                cbar2.ax.tick_params(labelsize=FONT_axisTick);
                cbar2.mappable.set_clim(vmin=np.min(AMPERE_plotLimValu), vmax=np.max(AMPERE_plotLimValu));
            #END IF
            
            if( snaps_dayNiteLine == 1 ):
                fig.canvas.flush_events(); #this is req. to get get_window_extent() to get the current window size
                #Plot the sunrise/sunset terminators
                dayNite_temp = np.abs(dayNite_sunrise - snaps_times[i]) <= 10/3600; #gets the sunrise locations that are within 10 sec of the current TEC time (2 min had way too many hits, zigzags)
                hLgd_FLG_day = np.sum(dayNite_temp); #plotting flag, shows when legend is active
                #constants will use all the time - only for plotting of day/nite line so minor importance
                #this stuff makes the text angle plotted mostly correct most of the time
                bboxFig = fig.get_window_extent().transformed(fig.dpi_scale_trans.inverted()); #get the entire figure dimensions
                bboxAx0 = ax[snaps_rowsArray[i],snaps_colsArray[i]].get_window_extent().transformed(fig.dpi_scale_trans.inverted()); #get the plot dimensions
#                    plot_ratio = (bboxAx0.width/bboxAx0.height)/( (bboxAx0.width/bboxAx0.height)/(bboxFig.width/bboxFig.height) )**2; #get the plot ratio, will use it to fix up the angle
                plot_ratio = (bboxAx0.width/bboxAx0.height); #get the plot ratio, will use it to fix up the angle
                dayNite_textRotationLenOrig = 35; #length to go up and down the sunrise/sunset line to estimate an angle
                dayNite_savgolFiltLenOrig = 101; #set it as a constant to start off
                dayNite_textLatAbs = (np.max(plotLatRange)-np.min(plotLatRange))*.9 + np.min(plotLatRange); #calc like 80% of the max latitude
                if( hLgd_FLG_day > 0 ): #only do work if it is there
                    #calc all that day/nite stuff in one function to keep it from getting cluttered
                    dayNite_Lat_line, dayNite_Long_line, dayNite_Lat_text, dayNite_Long_text, dayNite_textRotation = GRITI_movieMaker_subfun_dayniteCalc(0,np.sum(dayNite_temp),dayNite_Grid_Long[dayNite_temp],dayNite_Grid_Lat[dayNite_temp],dayNite_textLatAbs,plot_ratio,dayNite_savgolFiltLenOrig,dayNite_textRotationLenOrig);
                    dayNite_latLongMapped = geoMap(dayNite_Long_line,dayNite_Lat_line); #convert the lat/long arcdeg to the current map coordinates
                    imDayNite_day = ax[snaps_rowsArray[i],snaps_colsArray[i]].plot(dayNite_latLongMapped[0],dayNite_latLongMapped[1],color='g',linewidth=1.75,zorder=6); #plots a line to show the sunrise time
                    if( snaps_dayNiteText == 1 ):
                        dayNite_latLongMapped = geoMap(dayNite_Long_text,dayNite_Lat_text); #convert the lat/long arcdeg to the current map coordinates
                        textDayNite_day = ax[snaps_rowsArray[i],snaps_colsArray[i]].text(dayNite_latLongMapped[0], dayNite_latLongMapped[1], "Sunrise", rotation=dayNite_textRotation, color='g', fontsize=FONT_axisTick, zorder=6);
                    #END IF
                #END IF
                
                dayNite_temp = np.abs(dayNite_sunset - snaps_times[i]) <= 10/3600; #gets the sunset locations that are within 10 sec of the current TEC time (2 min had way too many hits, zigzags)
                hLgd_FLG_nite = np.sum(dayNite_temp); #plotting flag, shows when legend is active
                if( hLgd_FLG_nite > 0 ): #only do work if it is there
                    #calc all that day/nite stuff in one function to keep it from getting cluttered
                    dayNite_Lat_line, dayNite_Long_line, dayNite_Lat_text, dayNite_Long_text, dayNite_textRotation = GRITI_movieMaker_subfun_dayniteCalc(1,np.sum(dayNite_temp),dayNite_Grid_Long[dayNite_temp],dayNite_Grid_Lat[dayNite_temp],dayNite_textLatAbs,plot_ratio,dayNite_savgolFiltLenOrig,dayNite_textRotationLenOrig);
                    dayNite_latLongMapped = geoMap(dayNite_Long_line,dayNite_Lat_line); #convert the lat/long arcdeg to the current map coordinates
                    imDayNite_nite = ax[snaps_rowsArray[i],snaps_colsArray[i]].plot(dayNite_latLongMapped[0],dayNite_latLongMapped[1],color='b',linewidth=1.75,zorder=6); #plots a line to show the sunset time
                    if( snaps_dayNiteText == 1 ):
                        dayNite_latLongMapped = geoMap(dayNite_Long_text,dayNite_Lat_text); #convert the lat/long arcdeg to the current map coordinates
                        textDayNite_nite = ax[snaps_rowsArray[i],snaps_colsArray[i]].text(dayNite_latLongMapped[0], dayNite_latLongMapped[1], "Sunset", rotation=dayNite_textRotation, color='b', fontsize=FONT_axisTick, zorder=6);
                    #EMD IF
                #END IF
            elif( snaps_dayNiteLine == 2 ):
                dayNite_currentDay = subfun_dayNum_to_date( np.array((dateRange_dayNum_zeroHr[0],np.int64(TEC_timeUnique[i])),ndmin=2))[0]; #get the current yr/month/day
                dayNite_currentHr = np.int64((TEC_timeUnique[i]-np.int64(TEC_timeUnique[i]))*24); #hr, get the current hour
                dayNite_currentMin = np.int64( ((TEC_timeUnique[i]-np.int64(TEC_timeUnique[i]))*24 - dayNite_currentHr)*60); #min, get the current min
                dayNite_currentSec = np.int64( (((TEC_timeUnique[i]-np.int64(TEC_timeUnique[i]))*24 - dayNite_currentHr)*60 - dayNite_currentMin)*60); #min, get the current min
                dayNite_currentTime = datetime.datetime(dayNite_currentDay[0], dayNite_currentDay[1], dayNite_currentDay[2], dayNite_currentHr, dayNite_currentMin,dayNite_currentSec);
                dayNite_shade = geoMap.nightshade(dayNite_currentTime, color='k', delta=0.25, alpha=0.25, ax=ax[snaps_rowsArray[i],snaps_colsArray[i]], zorder=2);
            #END IF
            
            #Now drawing point of interest
            Millstone_latLongMapped = geoMap(longMillstone,latMillstone); #convert the lat/long arcdeg to the current map coordinates
            imMillstone = ax[snaps_rowsArray[i],snaps_colsArray[i]].plot(Millstone_latLongMapped[0],Millstone_latLongMapped[1],marker=gif_Millstone_Marker, color=gif_Millstone_Marker_Color, markersize=gif_Millstone_Marker_Size, zorder=50); #plot this, 50 always on top
           
        #END FOR i

    #END IF snaps_type
    
    #this just won't activate anywhere else - so putting it at the end
    for i in range(0,snaps_times.size):     
        #Remove the aspect ratio from the basemap so it fills the screen better
        ax[snaps_rowsArray[i],snaps_colsArray[i]].set_aspect('auto');
    #END FOR i
    
#END IF FLG_enable_movieSnaps
    
    
    
    
