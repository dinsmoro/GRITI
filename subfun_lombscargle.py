"""
% LOMBSCARGLE(INPUTDATA, DUPE_ELIM) performs a Lomb-Scargle periodogram (spectral) analysis on an n x 2 matrix of data 
% (inputdata = x(i),y(i)) that are not necessarily evenly spaced. (For evenly spaced data, more traditional
% Fourier-based spectral methods may be more appropriate.)
% 
% DUPE_ELIM (= 0 or 1) is an optional argument that 
% will prompt the program (if dupe_elim == 1) to eliminate duplicated samples from the analysis.
% The default value is 0.
%
% This program will plot and spectrally analyze the input data, and then plot the power spectrum of the data.
% The program is also capable of overlaying a signal of known frequency and amplitude; this may be helpful for
% spectral calibration. The resulting spectrum plot will also include significance levels. Finally, the program
% will reconstruct a plot of frequencies determined to be "significant" (at alpha = 0.05); for this reconstruction,
% frequencies within 5% of the calibration signal (if used) will be discarded. Significant frequencies and powers
% are written to the MATLAB command window.
%
% (This program is based on a Lomb-Scargle implementation in Press, Teukolsky, et al. Numerical Recipes,
% "Spectral Analysis of Unevenly Sampled Data." Use of this program requires an understanding of the
% Press/Teukolsky implementation, inculding the usage of hifac and ofac variables. The user is referred 
% to that source for a thorough discussion of the algorithms. In addition, the references cited in 
% Press/Teukolsky are quite helpful--particularly Scargle 1982, and Horne and Baliunas, 1986.)
%
% Note that there is an over-reliance in this code on global variables, and that no attempts have been made
% to vectorize for loops or to optimize the implementation. Perhaps in the next version....
%
% An optional file (INPUTTOLOMB.M) is also available for download, and includes code for easily generating 
% test data with known frequencies and amplitudes. This file is helpful for users trying to understand the output
% generated by lombscargle.
%
% Written by Brett Shoelson, Ph.D.
% 3/1/1999. Last modification: 10/25/01.
% Modified by Sumanta Sarkhel, Ph.D. on 01 Aug, 2011.
% Rewritten to be efficient by Ross Dinsmore, no useful titles, on sometime
% in 2016
#ported to Python sometime in 2019 by the same guy, no useful titles still, yep
"""

import numpy as np
from numba import jit

@jit(nopython=True,nogil=False,cache=True,fastmath=True)
def subfun_lombscargle(time, signal):
            
    timeMin = np.min(time); #get min/max/size of time
    timeMax = np.max(time);
    timeSize = time.size;
    
    hifac = 1; #G: some sort of scale factor
#    fhi = hifac*timeSize/(2*(timeMax-timeMin)); #G: also some sort of scale factor (unused, but reported in the original's file structure)
    ofac = 4; #G: some sort of scale factor
    
    outSize = np.int64(np.floor(ofac*hifac*timeSize/2));
    signalAvg = np.mean(signal);
    signalVari =  np.var(signal);
    timeDelt = timeMax - timeMin;
    timeAvg = (timeMax + timeMin)/2;
    freqCurrent = 1/(timeDelt*ofac); #freq checks start here, updates as we go
    
    arg = 2*np.pi*( (time - timeAvg)*freqCurrent );
    wpr = -2*np.sin(arg/2)**2;
    wpi = np.sin(arg);
    wr = np.cos(arg);
    wi = wpi;
    
    powerPerFreq = np.zeros( outSize ); #preallocate
    freq = np.zeros( outSize ); #preallocate
    
    for i in range(0,outSize):
        freq[i] = freqCurrent; #write it in, update it as we go
        
        sumsh = np.sum(wr*wi); #replicate sum for loop
        sumc = np.sum( (wr-wi)*(wr+wi) ); #replicate sum for for loop again
        
        wtau = np.arctan2(2*sumsh,sumc)/2;
        swtau = np.sin(wtau);
        cwtau = np.cos(wtau);
        
        ss = (wi*cwtau - wr*swtau); #reused so calc'd once
        cc = (wr*cwtau - wi*swtau); 
        sums = np.sum( ss**2 ); #replicate for loop sum
        sumc = np.sum( cc**2 ); #replicate for loop sum
        sumsy = np.sum( (signal - signalAvg)*ss ); #replcate for loop thing
        sumcy = np.sum( (signal - signalAvg)*cc ); #replcate for loop thing
        wrTemp = wr; #need to hold this for wi
        wr = wr*wpr - wi*wpi + wr; #edit this after that stuff, as per the for loop
        wi = wi*wpr + wrTemp*wpi + wi; #edit this after that stuff, as per the for loop
        
        powerPerFreq[i] = (sumcy**2/sumc+sumsy**2/sums)/(2*signalVari); #calc the power
        freqCurrent = freqCurrent + 1/(timeDelt*ofac); #increment it as we go
    #END FOR i
    
    #effm is an estimate of the number of *independent* frequencies
    #effm = 2*outSize/ofac;
    #The following computation of prob is valid for small values only:
    #    prob=effm*expy.
    #The following computation of prob is always valid, but presupposes no data clumping:
    #    prob=1-(1-expy)^effm.
    #if( (effm.size == 0) & (effm == 0) ):
    #	print('sargleCity: No frequencies to analyze.');
    #END IF
    
    gf = 1 - (.05/freq.size)**( 1/(freq.size-1) );
#    gs = 0.4*gf; #40% of gf, but right now I just want gf
    
    period = 1/freq; #calc the periods to go with the frequencies
    
    powerNormalized = powerPerFreq/np.sum(powerPerFreq); #normalize the power
    
    return period, powerNormalized, gf #return em, right now - no freq or gs is returned